["~#datascript/DB",["^ ","~:schema",["^ ","~:ast/version",["^ "],"~:file/content",["^ "],"~:block/properties-text-values",["^ "],"~:block/alias",["^ ","~:db/valueType","~:db.type/ref","~:db/cardinality","~:db.cardinality/many"],"~:block/pre-block?",["^ "],"~:block/uuid",["^ ","~:db/unique","~:db.unique/identity"],"~:block/priority",["^ "],"~:block/properties",["^ "],"~:block/journal?",["^ "],"~:block/namespace",["^ ","^6","^7"],"~:block/updated-at",["^ "],"~:block/repeated?",["^ "],"~:db/type",["^ "],"~:file/handle",["^ "],"~:block/left",["^ ","^6","^7","~:db/index",true],"~:block/refs",["^ ","^6","^7","^8","^9"],"~:block/scheduled",["^ "],"~:block/properties-order",["^ "],"~:block/created-at",["^ "],"~:block/deadline",["^ "],"~:block/collapsed?",["^ ","^G",true],"~:block/journal-day",["^ "],"~:block/format",["^ "],"~:block/tags",["^ ","^6","^7","^8","^9"],"~:block/content",["^ "],"~:recent/pages",["^ "],"~:block/macros",["^ ","^6","^7","^8","^9"],"~:db/ident",["^ ","^<","^="],"~:block/path-refs",["^ ","^6","^7","^8","^9"],"~:block/parent",["^ ","^6","^7","^G",true],"~:block/type",["^ "],"~:block/page",["^ ","^6","^7","^G",true],"~:block/name",["^ ","^<","^="],"~:file/path",["^ ","^<","^="],"~:block/file",["^ ","^6","^7"],"~:block/marker",["^ "],"~:block/original-name",["^ ","^<","^="],"~:schema/version",["^ "]],"~:datoms",["~#list",[["~#datascript/Datom",[1,"^12",2,536870913]],["^15",[2,"^@",false,536870914]],["^15",[2,"^Y","card",536870913]],["^15",[2,"^11","card",536870913]],["^15",[2,"^;","~u9b44fee9-047e-40cb-89d7-57522b45429f",536881166]],["^15",[3,"^@",false,536870914]],["^15",[3,"^Y","canceled",536870914]],["^15",[3,"^11","CANCELED",536870914]],["^15",[3,"^;","~uaeb9608a-971e-4364-92f8-73be000d06da",536881166]],["^15",[4,"^@",false,536870914]],["^15",[4,"^Y","todo",536870914]],["^15",[4,"^11","TODO",536870914]],["^15",[4,"^;","~uebc4ca71-8969-4360-a235-acced480da7d",536881166]],["^15",[5,"^@",false,536870914]],["^15",[5,"^Y","now",536870914]],["^15",[5,"^11","NOW",536870914]],["^15",[5,"^;","~u598d444a-d48c-469b-a60a-0f1adcc74a43",536881166]],["^15",[6,"^@",false,536870914]],["^15",[6,"^Y","later",536870914]],["^15",[6,"^11","LATER",536870914]],["^15",[6,"^;","~u54fac2fe-2bff-43f6-811c-ca1d1944867d",536881166]],["^15",[7,"^@",false,536870914]],["^15",[7,"^Y","done",536870914]],["^15",[7,"^11","DONE",536870914]],["^15",[7,"^;","~ua61f235c-82e0-4f08-bca7-335e90467eee",536881166]],["^15",[8,"^@",false,536870914]],["^15",[8,"^Y","doing",536870914]],["^15",[8,"^11","DOING",536870914]],["^15",[8,"^;","~u307225e1-037c-4d63-b024-56350fec3d16",536881166]],["^15",[9,"^@",false,536870914]],["^15",[9,"^Y","in-progress",536870914]],["^15",[9,"^11","IN-PROGRESS",536870914]],["^15",[9,"^;","~ubf0f7766-d845-4849-92b7-913b69c500ec",536881166]],["^15",[10,"^@",false,536870914]],["^15",[10,"^Y","c",536870914]],["^15",[10,"^11","C",536870914]],["^15",[10,"^;","~ue97aaf73-0133-4bba-a4e2-b87a018e187e",536881166]],["^15",[11,"^@",false,536870914]],["^15",[11,"^Y","b",536870914]],["^15",[11,"^11","B",536870914]],["^15",[11,"^;","~u917def3d-7df7-40cd-a48f-bfa2bcda678c",536881166]],["^15",[12,"^[",22,536870919]],["^15",[12,"^@",false,536870914]],["^15",[12,"^Y","contents",536870914]],["^15",[12,"^11","Contents",536870914]],["^15",[12,"^;","~u6c2ed903-c27a-4354-86eb-880ffe55db12",536881166]],["^15",[13,"^@",false,536870914]],["^15",[13,"^Y","waiting",536870914]],["^15",[13,"^11","WAITING",536870914]],["^15",[13,"^;","~u69dc538b-f1b4-472b-8c44-70c3887a2b0f",536881166]],["^15",[14,"^@",false,536870914]],["^15",[14,"^Y","favorites",536870914]],["^15",[14,"^11","Favorites",536870914]],["^15",[14,"^;","~u4e5087bd-c957-4887-b24d-409a2c953758",536881166]],["^15",[15,"^@",false,536870914]],["^15",[15,"^Y","a",536870914]],["^15",[15,"^11","A",536870914]],["^15",[15,"^;","~u95ad1a0a-13ad-4401-a7d9-503f80c78d0c",536881166]],["^15",[16,"^@",false,536870914]],["^15",[16,"^Y","cancelled",536870914]],["^15",[16,"^11","CANCELLED",536870914]],["^15",[16,"^;","~u7c4cf8fe-c404-4681-8c4d-ea35e21a48b0",536881166]],["^15",[17,"^@",false,536870914]],["^15",[17,"^Y","wait",536870914]],["^15",[17,"^11","WAIT",536870914]],["^15",[17,"^;","~u045d958f-2eef-4edf-b4c8-b376066e998e",536881166]],["^15",[18,"^K",1685004415046,536870915]],["^15",[18,"^O","~:markdown",536870915]],["^15",[18,"^N",20230525,536870915]],["^15",[18,"^@",true,536870915]],["^15",[18,"^Y","25-05-2023",536870915]],["^15",[18,"^11","25-05-2023",536870915]],["^15",[18,"^B",1685004415046,536870915]],["^15",[18,"^;","~u646f207f-3bb4-4195-b7e2-226d3c1daa01",536870915]],["^15",[19,"^Q","",536870916]],["^15",[19,"^O","^16",536870916]],["^15",[19,"^N",20230525,536870916]],["^15",[19,"^@",true,536870916]],["^15",[19,"^F",18,536870916]],["^15",[19,"^X",18,536870916]],["^15",[19,"^V",18,536870916]],["^15",[19,"^U",18,536870917]],["^15",[19,"^?",["^ "],536870916]],["^15",[19,"~:block/unordered",true,536870916]],["^15",[19,"^;","~u646f207f-1d5a-401a-aae3-0e518e79ab0e",536870916]],["^15",[20,"^3","",536870918]],["^15",[20,"~:file/created-at",1685004415148,536870919]],["^15",[20,"^Z","logseq/custom.css",536870918]],["^15",[21,"^3","{:meta/version 1\n\n ;; Currently, we support either \"Markdown\" or \"Org\".\n ;; This can overwrite your global preference so that\n ;; maybe your personal preferred format is Org but you'd\n ;; need to use Markdown for some projects.\n ;; :preferred-format \"\"\n\n ;; Preferred workflow style.\n ;; Value is either \":now\" for NOW/LATER style,\n ;; or \":todo\" for TODO/DOING style.\n :preferred-workflow :now\n\n ;; The app will ignore those directories or files.\n ;; E.g. :hidden [\"/archived\" \"/test.md\" \"../assets/archived\"]\n :hidden []\n\n ;; When creating the new journal page, the app will use your template if there is one.\n ;; You only need to input your template name here.\n :default-templates\n {:journals \"\"}\n\n ;; Set a custom date format for journal page title\n ;; Example:\n ;; :journal/page-title-format \"EEE, do MMM yyyy\"\n\n ;; Whether to enable hover on tooltip preview feature\n ;; Default is true, you can also toggle this via setting page\n :ui/enable-tooltip? true\n\n ;; Show brackets around page references\n ;; :ui/show-brackets? true\n\n ;; Enable showing the body of blocks when referencing them.\n :ui/show-full-blocks? false\n\n ;; Expand block references automatically when zoom-in\n :ui/auto-expand-block-refs? true\n\n ;; Enable Block timestamp\n :feature/enable-block-timestamps? false\n\n ;; Enable remove accents when searching.\n ;; After toggle this option, please remember to rebuild your search index by press (cmd+c cmd+s).\n :feature/enable-search-remove-accents? true\n\n ;; Enable journals\n ;; :feature/enable-journals? true\n\n ;; Enable flashcards\n ;; :feature/enable-flashcards? true\n\n ;; Enable Whiteboards\n ;; :feature/enable-whiteboards? true\n\n ;; Disable the built-in Scheduled tasks and deadlines query\n ;; :feature/disable-scheduled-and-deadline-query? true\n\n ;; Specify the number of days in the future to display in the\n ;; scheduled tasks and deadlines query, with a default value of 7 which\n ;; displays tasks for the next 7 days.\n ;; Example usage:\n ;; Display all scheduled and deadline blocks for the next 14 days\n ;; :scheduled/future-days 14\n\n ;; Specify the date on which the week starts.\n ;; Goes from 0 to 6 (Monday to Sunday), default to 6\n :start-of-week 6\n\n ;; Specify a custom CSS import\n ;; This option take precedence over your local `logseq/custom.css` file\n ;; You may find a list of awesome logseq themes here:\n ;; https://github.com/logseq/awesome-logseq#css-themes\n ;; Example:\n ;; :custom-css-url \"@import url('https://cdn.jsdelivr.net/gh/dracula/logseq@master/custom.css');\"\n\n ;; Specify a custom js import\n ;; This option take precedence over your local `logseq/custom.js` file\n ;; :custom-js-url \"\"\n\n ;; Set a custom Arweave gateway\n ;; Default gateway: https://arweave.net\n ;; :arweave/gateway \"\"\n\n ;; Set Bullet indentation when exporting\n ;; default option: tab\n ;; Possible options for `:export/bullet-indentation` are\n ;; 1. `:eight-spaces` as eight spaces\n ;; 2. `:four-spaces` as four spaces\n ;; 3. `:two-spaces` as two spaces\n ;; :export/bullet-indentation :tab\n\n ;; When :all-pages-public? true, export repo would export all pages within that repo.\n ;; Regardless of whether you've set any page to public or not.\n ;; Example:\n ;; :publishing/all-pages-public? true\n\n ;; Specify default home page and sidebar status for Logseq\n ;; If not specified, Logseq default opens journals page on startup\n ;; value for `:page` is name of page\n ;; Possible options for `:sidebar` are\n ;; 1. `\"Contents\"` to open up `Contents` in sidebar by default\n ;; 2. `page name` to open up some page in sidebar\n ;; 3. Or multiple pages in an array [\"Contents\" \"Page A\" \"Page B\"]\n ;; If `:sidebar` is not set, sidebar will be hidden\n ;; Example:\n ;; 1. Setup page \"Changelog\" as home page and \"Contents\" in sidebar\n ;; :default-home {:page \"Changelog\", :sidebar \"Contents\"}\n ;; 2. Setup page \"Jun 3rd, 2021\" as home page without sidebar\n ;; :default-home {:page \"Jun 3rd, 2021\"}\n ;; 3. Setup page \"home\" as home page with multiple pages in sidebar\n ;; :default-home {:page \"home\" :sidebar [\"page a\" \"page b\"]}\n\n ;; Tell logseq to use a specific folder in the repo as a default location for notes\n ;; if not specified, notes are stored in `pages` directory\n ;; :pages-directory \"your-directory\"\n\n ;; Tell logseq to use a specific folder in the repo as a default location for journals\n ;; if not specified, journals are stored in `journals` directory\n ;; :journals-directory \"your-directory\"\n\n ;; Set this to true will convert\n ;; `[[Grant Ideas]]` to `[[file:./grant_ideas.org][Grant Ideas]]` for org-mode\n ;; For more, see https://github.com/logseq/logseq/issues/672\n ;; :org-mode/insert-file-link? true\n\n ;; Setup custom shortcuts under `:shortcuts` key\n ;; Syntax:\n ;; 1. `+` means keys pressing simultaneously. eg: `ctrl+shift+a`\n ;; 2. ` ` empty space between keys represents key chords. eg: `t s` means press `t` followed by `s`\n ;; 3. `mod` means `Ctrl` for Windows/Linux  and `Command` for Mac\n ;; 4. use `false` to disable particular shortcut\n ;; 5. you can define multiple bindings for one action, eg `[\"ctrl+j\" \"down\"]`\n ;; full list of configurable shortcuts are available below:\n ;; https://github.com/logseq/logseq/blob/master/src/main/frontend/modules/shortcut/config.cljs\n ;; Example:\n ;; :shortcuts\n ;; {:editor/new-block       \"enter\"\n ;;  :editor/new-line        \"shift+enter\"\n ;;  :editor/insert-link     \"mod+shift+k\"\n ;;  :editor/highlight       false\n ;;  :ui/toggle-settings     \"t s\"\n ;;  :editor/up              [\"ctrl+k\" \"up\"]\n ;;  :editor/down            [\"ctrl+j\" \"down\"]\n ;;  :editor/left            [\"ctrl+h\" \"left\"]\n ;;  :editor/right           [\"ctrl+l\" \"right\"]}\n :shortcuts {}\n\n ;; By default, pressing `Enter` in the document mode will create a new line.\n ;; Set this to `true` so that it's the same behaviour as the usual outliner mode.\n :shortcut/doc-mode-enter-for-new-block? false\n\n ;; Block content larger than `block/content-max-length` will not be searchable\n ;; or editable for performance.\n :block/content-max-length 25000\n\n ;; Whether to show command doc on hover\n :ui/show-command-doc? true\n\n ;; Whether to show empty bullets for non-document mode (the default mode)\n :ui/show-empty-bullets? false\n\n ;; Pre-defined :view function to use with advanced queries\n :query/views\n {:pprint\n  (fn [r] [:pre.code (pprint r)])}\n\n ;; Pre-defined :result-transform function for use with advanced queries\n :query/result-transforms\n {:sort-by-priority\n  (fn [result] (sort-by (fn [h] (get h :block/priority \"Z\")) result))}\n\n ;; The app will show those queries in today's journal page,\n ;; the \"NOW\" query asks the tasks which need to be finished \"now\",\n ;; the \"NEXT\" query asks the future tasks.\n :default-queries\n {:journals\n  [{:title \"🔨 NOW\"\n    :query [:find (pull ?h [*])\n            :in $ ?start ?today\n            :where\n            [?h :block/marker ?marker]\n            [(contains? #{\"NOW\" \"DOING\"} ?marker)]\n            [?h :block/page ?p]\n            [?p :block/journal? true]\n            [?p :block/journal-day ?d]\n            [(>= ?d ?start)]\n            [(<= ?d ?today)]]\n    :inputs [:14d :today]\n    :result-transform (fn [result]\n                        (sort-by (fn [h]\n                                   (get h :block/priority \"Z\")) result))\n    :group-by-page? false\n    :collapsed? false}\n   {:title \"📅 NEXT\"\n    :query [:find (pull ?h [*])\n            :in $ ?start ?next\n            :where\n            [?h :block/marker ?marker]\n            [(contains? #{\"NOW\" \"LATER\" \"TODO\"} ?marker)]\n            [?h :block/page ?p]\n            [?p :block/journal? true]\n            [?p :block/journal-day ?d]\n            [(> ?d ?start)]\n            [(< ?d ?next)]]\n    :inputs [:today :7d-after]\n    :group-by-page? false\n    :collapsed? false}]}\n\n ;; Add your own commands to slash menu to speedup.\n ;; E.g.\n ;; :commands\n ;; [\n ;; [\"js\" \"Javascript\"]\n ;; [\"md\" \"Markdown\"]\n ;; ]\n :commands\n []\n\n ;; By default, a block can only be collapsed if it has some children.\n ;; `:outliner/block-title-collapse-enabled? true` enables a block with a title\n ;; (multiple lines) can be collapsed too. For example:\n ;; - block title\n ;;   block content\n :outliner/block-title-collapse-enabled? false\n\n ;; Macros replace texts and will make you more productive.\n ;; For example:\n ;; Change the :macros value below to:\n ;; {\"poem\" \"Rose is $1, violet's $2. Life's ordered: Org assists you.\"}\n ;; input \"{{poem red,blue}}\"\n ;; becomes\n ;; Rose is red, violet's blue. Life's ordered: Org assists you.\n :macros {}\n\n ;; The default level to be opened for the linked references.\n ;; For example, if we have some example blocks like this:\n ;; - a [[page]] (level 1)\n ;;   - b        (level 2)\n ;;     - c      (level 3)\n ;;       - d    (level 4)\n ;;\n ;; With the default value of level 2, `b` will be collapsed.\n ;; If we set the level's value to 3, `b` will be opened and `c` will be collapsed.\n :ref/default-open-blocks-level 2\n\n :ref/linked-references-collapsed-threshold 50\n\n ;; Favorites to list on the left sidebar\n :favorites [\"Geometry\"]\n\n ;; any number between 0 and 1 (the greater it is the faster the changes of the next-interval of card reviews) (default 0.5)\n ;; :srs/learning-fraction 0.5\n\n ;; the initial interval after the first successful review of a card (default 4)\n ;; :srs/initial-interval 4\n\n ;; hide specific properties for blocks\n ;; E.g. :block-hidden-properties #{:created-at :updated-at}\n ;; :block-hidden-properties #{}\n\n ;; Enable all your properties to have corresponding pages\n :property-pages/enabled? true\n\n ;; Properties to exclude from having property pages\n ;; E.g.:property-pages/excludelist #{:duration :author}\n ;; :property-pages/excludelist\n\n ;; By default, property value separated by commas will not be treated as\n ;; page references. You can add properties to enable it.\n ;; E.g. :property/separated-by-commas #{:alias :tags}\n ;; :property/separated-by-commas #{}\n\n ;; Properties that are ignored when parsing property values for references\n ;; :ignored-page-references-keywords #{:author :startup}\n\n ;; logbook setup\n ;; :logbook/settings\n ;; {:with-second-support? false ;limit logbook to minutes, seconds will be eliminated\n ;;  :enabled-in-all-blocks true ;display logbook in all blocks after timetracking\n ;;  :enabled-in-timestamped-blocks false ;don't display logbook at all\n ;; }\n\n ;; Mobile photo uploading setup\n ;; :mobile/photo\n ;; {:allow-editing? true\n ;;  :quality          80}\n\n ;; Mobile features options\n ;; Gestures\n ;; :mobile\n ;; {:gestures/disabled-in-block-with-tags [\"kanban\"]}\n\n ;; Extra CodeMirror options\n ;; See https://codemirror.net/5/doc/manual.html#config for possible options\n ;; :editor/extra-codemirror-options {:keyMap \"emacs\" :lineWrapping true}\n\n ;; Enable logical outdenting\n ;; :editor/logical-outdenting? true\n\n ;; When both text and a file are in the clipboard, paste the file\n ;; :editor/preferred-pasting-file? true\n\n ;; Quick capture templates for receiving contents from other apps.\n ;; Each template contains three elements {time}, {text} and {url}, which can be auto-expanded\n ;; by received contents from other apps. Note: the {} cannot be omitted.\n ;; - {time}: capture time\n ;; - {date}: capture date using current date format, use `[[{date}]]` to get a page reference\n ;; - {text}: text that users selected before sharing.\n ;; - {url}: url or assets path for media files stored in Logseq.\n ;; You can also reorder them, or even only use one or two of them in the template.\n ;; You can also insert or format any text in the template as shown in the following examples.\n ;; :quick-capture-templates\n ;; {:text \"[[quick capture]] **{time}**: {text} from {url}\"\n ;;  :media \"[[quick capture]] **{time}**: {url}\"}\n\n ;; Quick capture options\n ;; :quick-capture-options {:insert-today? false :redirect-page? false :default-page \"my page\"}\n\n ;; File sync options\n ;; Ignore these files when syncing, regexp is supported.\n ;; :file-sync/ignore-files []\n\n ;; dwim (do what I mean) for Enter key when editing.\n ;; Context-awareness of Enter key makes editing more easily\n ; :dwim/settings {\n ;   :admonition&src?  true\n ;   :markup?          false\n ;   :block-ref?       true\n ;   :page-ref?        true\n ;   :properties?      true\n ;   :list?            true\n ; }\n\n ;; Decide the way to escape the special characters in the page title.\n ;; Warning:\n ;;   This is a dangerous operation. If you want to change the setting,\n ;;   should access the setting `Filename format` and follow the instructions.\n ;;   Or you have to rename all the affected files manually then re-index on all\n ;;   clients after the files are synced. Wrong handling may cause page titles\n ;;   containing special characters to be messy.\n ;; Available values:\n ;;   :file/name-format :triple-lowbar\n ;;     ;use triple underscore `___` for slash `/` in page title\n ;;     ;use Percent-encoding for other invalid characters\n :file/name-format :triple-lowbar\n :graph/settings {:journal? false}\n :journal/page-title-format \"dd-MM-yyyy\"\n\n ;; specify the format of the filename for journal files\n ;; :journal/file-name-format \"yyyy_MM_dd\"\n\n }\n",536875245]],["^15",[21,"^18",1685004415131,536870919]],["^15",[21,"~:file/last-modified-at","~m1688260782408",536875246]],["^15",[21,"^Z","logseq/config.edn",536870919]],["^15",[22,"^3","- [[Geometry]]\n- [[String]]",536870919]],["^15",[22,"^18",1685004415159,536870919]],["^15",[22,"^Z","pages/contents.md",536870919]],["^15",[23,"^K",1685004415255,536870919]],["^15",[23,"^[",27,536870919]],["^15",[23,"^@",false,536870919]],["^15",[23,"^Y","geometry",536870919]],["^15",[23,"^11","Geometry",536870919]],["^15",[23,"^B",1688291520639,536875460]],["^15",[23,"^;","~u646f207f-60f7-453d-866c-7749341b8b3b",536870919]],["^15",[24,"^K",1685004415287,536870919]],["^15",[24,"^[",50,536870919]],["^15",[24,"^@",false,536870919]],["^15",[24,"^Y","string",536870919]],["^15",[24,"^11","String",536870919]],["^15",[24,"^B",1691986229825,536877869]],["^15",[24,"^;","~u646f207f-2656-4dc4-9777-5864f7a44ee6",536870919]],["^15",[25,"^Q","[[Geometry]]",536870919]],["^15",[25,"^O","^16",536870919]],["^15",[25,"^F",12,536870919]],["^15",[25,"^X",12,536870919]],["^15",[25,"^V",12,536870919]],["^15",[25,"^U",12,536870919]],["^15",[25,"^U",23,536870919]],["^15",[25,"^H",23,536870919]],["^15",[25,"^17",true,536870919]],["^15",[25,"^;","~u646f207f-36a5-46f9-981c-fd79fdea66f2",536870919]],["^15",[26,"^Q","[[String]]",536870919]],["^15",[26,"^O","^16",536870919]],["^15",[26,"^F",25,536870919]],["^15",[26,"^X",12,536870919]],["^15",[26,"^V",12,536870919]],["^15",[26,"^U",12,536870919]],["^15",[26,"^U",24,536870919]],["^15",[26,"^H",24,536870919]],["^15",[26,"^17",true,536870919]],["^15",[26,"^;","~u646f207f-4572-4df5-906e-d8f1112aa371",536870919]],["^15",[27,"^3","- We deal with geometric shapes here.\n- [[Complex Number]]: MSVC and GCC have a library <complex> that can be used to represent complex numbers.\n  Now CNs theirselves can use either floating or integer coordinates, so we can do\n  ```cpp\n  #define R real()\n  #define I imag()\n  \n  using CD = complex<long double>;\n  using CI = complex<long long>;\n  \n  and then define a CN with\n  CI c{ CI(4,2) };\n  cout << c.R << c.I << endl;\n  ```\n- CI is deprecated as of C++17, so CD is the only one we can use.\n- We can find |v| which is the +ve length of a vector v from origin to the point (x,y). Here y is the imaginary part and x is the real part. This is done using the abs(<CN>) function. \n  That is, \n  $$\\text{abs(<CN>)} = \\sqrt{x^2+y^2}$$\n  What is $$\\sqrt{x^2+y^2}$$ ?\n  \n  ![image.png](../assets/image_1683264291580_0.png)\n  \n  It is the distance from origin to the point x,y.\n  Since it can be floating, it is better to use CD.\n- We can also calculate distance between 2 points using abs(),\n  to do so say a and b are CD, then\n  ``double dist{ abs(b-a) }; ``\n  will return the distance between them.\n- Angle: We can get the angle \n  \n  ![image.png](../assets/image_1683264991101_0.png)\n  \n  alpha using the function arg(<CN>)\n  This angle has its base on the x axis (so at (x,0) it is 0) and increases counter clockwise. The angle is in radians, where r radians means 180*r/pi or 1 radian = pi/180 degrees.\n- Polar form: We can use polar(s,a) to construct a Complex Number which has length s and angle a (radian) from origin. Polar returns a CD/CI based on the input type.\n  Another use of polar is for vector rotation.\n  A CN can be represented as a vector, and this vector can be rotated by multiplying it with a vector with length 1 and angle a. \n  For ex.:\n  ```cpp\n  CD vec{CD(4,2)};\n  cout<<arg(vec); //0.463\n  vec*=polar(1.0,0.5);\n  cout<<arg(vec); //0.963\n  ```\n- [[Cross Product]]: For 2 vectors (CI/CD), a and b, the cross product is only defined for 3D. But if they are complex numbers then they can use [[Complex Number]] Multiplication and get a scalar value, this scalar value tells us the direction of b when its tail is placed at a’s tip. \n  If $$\\begin{aligned} a \\times b > 0 \\end{aligned}$$, b turns left\n  If $$\\begin{aligned} a \\times b = 0 \\end{aligned}$$, b turns 180 degrees or goes straight ahead\n  If $$\\begin{aligned} a \\times b < 0 \\end{aligned}$$, b turns right.\n  \n  ![image.png](../assets/image_1683265036139_0.png){:height 185, :width 597}\n  \n  $$ a \\times b = a_1*b_2 - a_2*b_1 $$ \n  (for 2D, vector cross product is the CN multiplication), it can be retrieved by\n  ``double result { (conj(a)*b).I };``\n  Here conj turns a’s imaginary part (or y axis) negative, as conjugate of a CN is simply the sign of its imaginary part flipped so we get (a_{1}, -a_{2}) and the CN multiplication of this with b is\n  a_{1}b_{2} - a_{2}b_{1}\n  Yes, C++ performs CN multiplication on multiplication of 2 CNs.\n  \n  This is also to say, that whilst Vector Cross Product isn’t defined for 2D, we can represent the 2D vectors as Complex Numbers and perform Complex Number Multiplication on them. This is not the same as a vector cross product as it doesn’t give a third vector which is perpendicular to both the vectors, nor is it the same as vector dot product which tells us about the projection of a vector onto another. Instead, it simply helps us understand the rotation of the second vector in 2D space.\n\t- Applications of CN multiplication/vector cross product (for 2D):\n\t  \n\t  * Testing point location: If we have 3 points, A, B and P and we wish to know if P is on the line passing through A and B, then we can do so\n\t  ``double R = (P - A) X (P - B)``\n\t  which returns a scalar value, \n\t  0 means P is on the line passing through A and B \n\t  \\>0 means P is on the left of the line\n\t  \\<0 means it is on the right.\n\t  \n\t  For ex.:\n\t  \n\t  ![image.png](../assets/image_1683265668634_0.png)\n\t   \n\t  Here A= (2,3), B= (9,3) and P = (5,3) and after computing R we get R = 0 which means P lies on the line passing through A and B.\n\t  \n\t  So, to use a 2D co-ordinate, we turn it to CN/Vector 2D then we perform the above CN Multiplication/cross product\n\t  like so\n\t        ```cpp\n\t        CD a{p-x};\n\t        CD b{p-y};\n\t        double result{(conj(a)*b).I};\n\t        ```\n\t  This identifies if for a point x and y, another point p falls on the line passing through them, or its left or right.\n\t  \n\t  ** Properties:\n\t  *** Even if P is ahead of AB, it will still give R as 0. This is also to say, we aren’t checking if P lies on the line between A and B, we are checking if P lies on the line that passes through A and B, so it can be that P occurs before A and B, between A and B and after A and B and in all cases R will be 0 as it is on the line that goes through them.\n\t  \n\t  * Intersection of lines: We can determine if 2 straight lines intersect or not.\n\t  Say we are given 4 points a, b, c and d and told there are 2 line segments, ad and cb.\n\t  Then there are 3 cases if 2 lines intersect,\n\t  \n\t  ** Case 1: The line segments are on the same line. In this case there are infinite points of one line intersecting with other wherever they overlap. We just test the given points with simple vector cross product and if they are all 0 then we test if any of the point lies between a line segment.\n\t  \n\t  ![image.png](../assets/image_1683266231798_0.png)\n\t  \n\t  \n\t  First we simply get the vector cross product of all of them with respect to any other 2 points and see if all of these cross products are 0. This tells us if all of them lie on the same line passing through them. If they don’t then that means Case 1 isn’t true as the lines don’t overlap.\n\t  \n\t  Now to check if they intersect, we sort them based on their x or y co-ordinate. This tells us if any point lies on the other line segment, we already know they are on the same line passing through them, and this confirms if a line segment overlaps the other.\n\t  \n\t  So in the above case we get all vector cross products as 0, then we sort the points on x axis and find out the order is a, c, b and d. Meaning at-least c falls between a and d and hence there is an intersect and an overlap.\n\t  \n\t  \n\t  ** Case 2: There is only 1 intersection point, and it is one of the vertices/given points. Here we get the vector cross products of the points of the one line segment’s vertices with respect to the other 2, then do it for the other one and if one of the points is on the line passing through the other line segments vertices then that means that point intersects with this line segment.\n\t  \n\t  For example:\n\t  \n\t  ![image.png](../assets/image_1683266308873_0.png)\n\t  \n\t  We find vector cross product of first c and d with respect to a and b then a and b with respect to c and d, here we find the vector cross product of c on the line a and b as 0 and some negative value for d. This means c lies on the line passing through a and b and hence we have an intersection point.\n\t  \n\t  ** Case 3: There is only 1 intersection point but it is neither of the vertices. In this case we take one line segment and get vector cross product for both its points with respect to the 2 points of the other line segment and then do the same for that line segment. Then, if for both line segments 1 point falls to the left of the other line segment and the other point falls to the right of the other line segment, then they intersect somewhere.\n\t  \n\t  For example:\n\t  \n\t  ![image.png](../assets/image_1683266342566_0.png)\n\t  \n\t  \n\t  Here, we get vector cross product of both c and d AND a and b with respect to a and b and c and d respectively. If they intersect somewhere, as we can see above, then vector cross product of a will be >0 and b will be <0, and the same will be true for c and d. If both these are true as here, then it means ab and cd intersect somewhere.\n\t  \n\t  In C++,\n\t  ```cpp\n\t      // 2D vector cross product aka Complex Number Multiplication\n\t      double crossProduct(CD &a, CD &b, CD &p)\n\t      {\n\t          CD temp1{p - a};\n\t          CD temp2{p - b};\n\t          double result{(conj(temp1) * temp2).I};\n\t  \n\t          return result;\n\t      }\n\t  \n\t      bool comparatorCD(CD &a, CD &b)\n\t      {\n\t          return (a.R == b.R) ? (a.I < b.I) : (a.R < b.R);\n\t      }\n\t      //checks if the point b is in middle on the cartesian plane with respect to the other args.\n\t      bool isMid(CD &a, CD &b, CD &c)\n\t      {\n\t          std::vector<CD> temp{a, b, c};\n\t          std::sort(temp.begin(), temp.end(), comparatorCD);\n\t  \n\t          return temp[1] == b;\n\t      }\n\t  \n\t      void start()\n\t      {\n\t          double resA1{crossProduct(b1, b2, a1)};\n\t  \n\t          double resA2{crossProduct(b1, b2, a2)};\n\t  \n\t          double resB1{crossProduct(a1, a2, b1)};\n\t  \n\t          double resB2{crossProduct(a1, a2, b2)};\n\t  \n\t          result = \"NO\";\n\t  \n\t          if (resB1 == 0 && isMid(a1, b1, a2))\n\t          {\n\t              result = \"YES\";\n\t          }\n\t          else if (resB2 == 0 && isMid(a1, b2, a2))\n\t          {\n\t              result = \"YES\";\n\t          }\n\t          else if (resA1 == 0 && isMid(b1, a1, b2))\n\t          {\n\t              result = \"YES\";\n\t          }\n\t          else if (resA2 == 0 && isMid(b1, a2, b2))\n\t          {\n\t              result = \"YES\";\n\t          }\n\t          if ((resA1 * resA2) < 0 && (resB1 * resB2) < 0) // case 3\n\t          {\n\t              result = \"YES\";\n\t          }\n\t  \n\t          output();\n\t      }\n\t  ```\n\t  The logic is pretty simple, first we test each point against the other line segment. This way we know where each point lies wrt the other line segment. Now if a point is in between the points of the other line segment and lies on the line then we have case 1 or case 2 fulfilled. Lastly if that is not true then we check for case 3  which requires both pairs of points to be on the opposite side of the other line segment. We can check this by simply multiplying the opposite resultant values, it will be -ve if exactly one of them is negative.\n\t  \n\t  * Distance from a point to a line: Using vector cross product we can calculate the distance from a point to a line. This is because we can calculate the area of a triangle using vector cross products using the formula\n\t  $$\\text {Area of a triangle} = \\frac {(\\left| (a-c) \\times (b-c) \\right|)}{2}$$\n\t  | | here means +ve value not vector magnitude because 2D vector cross product returns a scalar value.\n\t  Here a, b and c are 3 points or rather vertices of the triangle.\n\t  \n\t  Using this we can find out the height of the triangle, i.e., shortest distance from c to line passing through a and b using this formula\n\t  \n\t  $$ \\text d= \\frac {(a-c) \\times (b-c)}{(\\left| b – a \\right|)}$$\n\t  This is because for the area of a triangle we have 2 formulae, first is (½)*(|b-a|)*d, which gives the normal area of triangle and then (| (a-c) X (b-c) |) / 2, which is using the vector cross product. Here d is the height.\n\t  For example:\n\t  \n\t  ![image.png](../assets/image_1683266522901_0.png) \n\t  \n\t  In the above image, if we find d using the distance formula then that will give us the shortest distance from p to the line passing through S1 and S2.\n\t  \n\t  * Point in a polygon: We can test if a point is inside a polygon with a simple algorithm. We cast arbitrary number of rays in arbitrary directions from the point, if the rays intersect with any of the boundary of the polygon 0 or even number of times then the point is outside, otherwise it is inside.\n\t  \n\t  For example:\n\t  \n\t  ![image.png](../assets/image_1683266562064_0.png)\n\t  \n\t  \n\t  A naïve approach here would be checking if the ray of sufficient length making a line segment from a given point, say b, intersects with any of the line of the polygon, so we check line segment b to ray end against all line segments of the polygon (we can use case 3 of checking if a line intersects) and see how many lines the ray intersects\n\t  \n\t  In cpp,\n\t  ```cpp\n\t      //Raycasting Alg\n\t      void start()\n\t      {\n\t          CD extPoint{1e9+1,-1e9+1};//Any point on the outside.\n\t                                 //We can use this point to check if any line segment from this point\n\t                                 //to any other point intersects with the polygon and hence\n\t                                 //performing Ray casting.\n\t          bool isBoundary{false};\n\t          for(int i{}, countsPoint{}; i<m;++i, countsPoint=0) {\n\t              isBoundary=false;\n\t              for(int j{}; j<n;++j){\n\t                  CD& p1{points[i]};\n\t                  CD& p2{extPoint};\n\t  \n\t                  CD& pips1{pips[j]};\n\t                  CD& pips2{pips[(j+1)%n]};\n\t  \n\t                  double resPip1{crossProduct(p1, p2, pips1)};\n\t                  double resPip2{crossProduct(p1, p2, pips2)};\n\t                  double resP1{crossProduct(pips1, pips2,p1)};\n\t                  double resP2{crossProduct(pips1, pips2, p2)};\n\t  \n\t                  if(resP1==0 && isMid(pips1, p1,pips2))\n\t                  {\n\t                      isBoundary=true;\n\t                      break;\n\t                  }\n\t                  else if((resPip1*resPip2) < 0 && (resP1*resP2)<0){\n\t                      countsPoint++;\n\t                  }\n\t              }\n\t              if (isBoundary)\n\t              {\n\t                  results[i]=\"BOUNDARY\";\n\t              }\n\t              else if(countsPoint==0 || countsPoint % 2 == 0){\n\t                  results[i]=\"OUTSIDE\";\n\t              }\n\t              else {\n\t                  results[i]=\"INSIDE\";\n\t              }\n\t          }\n\t          output();\n\t      }\n\t  ```\n\t  where ``pips``(size n) are the vertices of the polygon and ``points``(size m) are the points to be tested if they are inside or outside. The logic is pretty simple, we set up an external point (which has to be guaranteed to be outside the polygon) and for each point to be tested, we create a line segment between the point and the external point and then test their line segment against all line segments of the polygon. The end result are 3 conditions, either the point lies on the boundary/in mid of any line segment of the polygon, or it is outside meaning the no. of line segments it intersects are either 0 or divisible by 2, or inside otherwise. \n\t  We need to check the ray against all line segments of the polygon because we don't know which line segments it intersects (unlike how we see visually).\n-\n- Area of a Polygon\n  There are 2 simple ways to calculate the area enclosed by a polygon, dividing a polygon into known shapes and summing the parts. Or using formulae such as shoelace formula, aka Gauss’ Area Formula, aka Surveyor’s Formula. \n  If the shape is a basic regular polygon such as a triangle or rectangle or trapezoid or etc., then using the normal area formula for that shape is faster than using shoelace but otherwise this is a faster and simpler calculation.\n  \n  The formula is\n  $$\\text{Area} = \\frac{1}{2} \\left|\\sum_{i=1}^{n-1} (x_iy_{i+1} - x_{i+1}y_i)\\right|$$\n  \n  or\n  \n  $$\\text{Area} = \\frac{1}{2} \\left|\\sum_{i=1}^{n-1} (p_i \\times p_{i+1})\\right|$$\n  \n  where p is a CN and this is a 2D vector cross product or CN multiplication.\n  p_{i} is any point (x_{i},y_{i}) and p_{i+1} is the point adjacent to it, we follow a direction, i.e., either right or left and then only go in that dirn.\n  For ex.:\n  \n  ![image.png](../assets/image_1683266699836_0.png) \n  \n  Here, p_{1} can be (2,4) then if we go right then p_{2} will be (5,5) and we only go this way for consequent points. Similarly, we can go left to (4,3) and all consequent points will be the next adjacent points.\n  This doesn’t just apply to the CN version but also the normal formula as well.\n  The idea of the formula is to simply compute the area for each trapezoid in the polygon, where the first side is the side of the polygon and the second side is the horizontal axis line at y=0 like so\n  \n  ![image.png](../assets/image_1683280650170_0.png) \n  \n  The area of each trapezoid here is \n  $$Area = (x_{i+1} - x_{i})*\\frac{(y_{i} + y_{i+1})}{2}$$\n  \n  In CPP,\n  ```cpp\n      void start()\n      {\n          double value{};\n          CD* next{nullptr};\n          for(int i{}; i<n;++i) {\n              next= &points[(i+1)%n];\n              value += ((points[i].R* (*next).I) - ((*next).R * points[i].I));\n          }\n  \n          result = static_cast<int>(abs(value)); //multiplying with 1/2 and 2, i.e. 1.\n          output();\n      }\n  \n  ```\n  Here we simply go through each point and its next point and sum this value then simply multiply the result with 1/2 as that's in the formula for each trapezium and multiply with 2 to cancel it out and ensure the integer remains an integer (1/2 of an integer can be double, but the inputs are strictly integer).\n- Pick’s Theorem \n  Tells us the area of a polygon is\n  $$\\text Area = a + \\frac{b}{2} - 1$$\n  where a are the integer points strictly inside the polygon and b are the integer points exactly on the boundary of the polygon. Integer co-ordinates are also known as lattice points.\n  For ex.:\n  ![image.png](../assets/image_1683281026895_0.png)\n   \n  \n  Here, a = 6 and b = 7.\n  So there are said to be 6 lattice points inside and 5 on the boundary.\n- Distance Functions\n  Defines the distance between any 2 points, there’s the standard Euclidean distance, which is the plain and straight distance to a point\n  $$\\text{Euclidean Distance} = \\sqrt{ (x_2 - x_1)^2 + (y_2-y_1)^2 }$$\n  \n  It uses Pythagoras’ theorem in a triangle to calculate the distance.\n  represented like so\n  ![image.png](../assets/image_1683282352124_0.png)\n  *There’s another type of distance metric known as a Manhattan Distance which uses a grid-like path, or rather the sum of the differences in each of the cartesian co-ordinates. \n  That is,\n  $$\\text {Manhattan Distance} = \\left | x_1 - x_2 \\right | + \\left | y_1- y_2 \\right |$$\n  \n  We basically summed the difference of the cartesian co-ordinates, this means we follow a grid-like path to the point and not a straight line like so\n  ![image.png](../assets/image_1683288296272_0.png)\n  \n  * Then there’s the Chessboard distance or the Chebyshev distance, which is the maximum of difference of either coordinates between 2 points.\n  $$\\text {Chebyshev Distance} = \\max ( \\left | x_1 - x_2 \\right |, \\left | y_1 - y_2 \\right | )$$\n  \n  It looks like so \n  ![image.png](../assets/image_1683288436752_0.png) \n  \n  The Chebyshev distance can be thought of as a King’s minimum number of moves to reach another block on a chessboard, as shown here\n  ![image.png](../assets/image_1683288446994_0.png)\n  \n  * Properties\n   ** 1 unit\n  \n  ![image.png](../assets/image_1683288515797_0.png)\n  \n  and with Chebyshev\n  \n  ![image.png](../assets/image_1683288525779_0.png)\n  \n  We can visually see why the Chebyshev is 1 for all green points, it’s because it doesn’t care about the diagonals, just the pure maximum of difference of either axes between any 2 points. Or we can say 1 unit of Chebyshev Distance is the distance travelled on x-axis, or y-axis or on both at the same time (diagonal) so (1,1) is still 1 Chebyshev Distance as we can use both or either of the axes to move.\n  \n  ** As we can see above, a Chebyshev distance can be converted to a Manhattan Distance if we rotate it by 45 degrees, and same for the other way around. This means,\n  \n  ``45 degree Rotated Chebyshev or Manhattan = Manhattan or Chebyshev respectively.``\n  \n  A simple way to rotate a Manhattan to a Chebyshev is,\n  for a point \n  ``p=(x,y)``\n  we transform it as \n  ``p’= (x+y , y-x)``\n  \n  This transforms a point by rotating it 45 degrees and scaling it.\n  \n  For ex.:\n  ![image.png](../assets/image_1683288664305_0.png)\n  \n  \n  We have to find the max. Manhattan Distance between any 2 points here\n  \n  It is BC here and the MD is 5 as we can see.\n  But we can also convert all points to use a CD by rotating all points by 45 degrees, like so\n  ![image.png](../assets/image_1683288686822_0.png)\n   \n  \n  Now for this graph the MD will be different but the CD will give us the MD for graph 1. \n  So for any 2 points in the rotated graph, \n  $$\\text {CD} = \\max ( \\left | x_{1’} - x_{2’}, y_{1’} - y_{2’} \\right|)$$\n  where x’ and y’ are the rotated points. and this CD is actually the MD for the normal graph.\n  \n  This has the benefit that now, we can look at each axis separately, so between any 2 points if their x or their y coordinate has maximum difference then they will give the max. MD.\n- Sweep-Line Algorithms\n  The idea with these algs is to represent a problem in the cartesian plane and its events as points in it. Then we process the events in the increasing order of their x or y co-ordinates.\n  \n  * [[Intersection Points]]\n  * [[Closest Pair]]\n-\n- [[Convex Hull]]",536875463]],["^15",[27,"^18",1685004415259,536870919]],["^15",[27,"^19","~m1688291521516",536875462]],["^15",[27,"^Z","pages/Geometry.md",536870919]],["^15",[28,"^K",1685004415257,536870919]],["^15",[28,"^O","^16",536874122]],["^15",[28,"^@",false,536870919]],["^15",[28,"^Y","complex number",536874524]],["^15",[28,"^11","Complex Number",536874524]],["^15",[28,"^B",1685004415257,536870919]],["^15",[28,"^;","~u646f207f-5120-4005-a212-9dc7bbfbb8ff",536870919]],["^15",[29,"^K",1685004415258,536870919]],["^15",[29,"^@",false,536870919]],["^15",[29,"^Y","cross product",536870919]],["^15",[29,"^11","Cross Product",536870919]],["^15",[29,"^B",1685004415258,536870919]],["^15",[29,"^;","~u646f207f-1dda-44a8-b0fd-342494840a39",536870919]],["^15",[30,"^5",103,536871661]],["^15",[30,"^K",1685004415271,536870919]],["^15",[30,"^[",46,536870919]],["^15",[30,"^@",false,536870919]],["^15",[30,"^Y","intersection points",536870919]],["^15",[30,"^11","Intersection Points",536870919]],["^15",[30,"^?",["^ ","~:alias",["~#set",["Line Intersection"]]],536871661]],["^15",[30,"^4",["^ ","^1:","Line Intersection"],536871661]],["^15",[30,"^B",1686379968061,536871669]],["^15",[30,"^;","~u646f207f-f83a-45db-85fa-558d61dcff03",536870919]],["^15",[31,"^Q","We deal with geometric shapes here.",536870919]],["^15",[31,"^O","^16",536870919]],["^15",[31,"^F",23,536870919]],["^15",[31,"^X",23,536870919]],["^15",[31,"^V",23,536870919]],["^15",[31,"^U",23,536870919]],["^15",[31,"^17",true,536870919]],["^15",[31,"^;","~u646f207f-20d0-40ec-b4bd-7e0e2db05e8e",536870919]],["^15",[32,"^Q","Sweep-Line Algorithms\nThe idea with these algs is to represent a problem in the cartesian plane and its events as points in it. Then we process the events in the increasing order of their x or y co-ordinates.\n\n* [[Intersection Points]]\n* [[Closest Pair]]",536871489]],["^15",[32,"^O","^16",536870919]],["^15",[32,"^F",34,536870919]],["^15",[32,"^X",23,536870919]],["^15",[32,"^V",23,536870919]],["^15",[32,"^U",23,536871490]],["^15",[32,"^U",30,536871490]],["^15",[32,"^U",95,536871490]],["^15",[32,"^?",["^ "],536871489]],["^15",[32,"^H",30,536871489]],["^15",[32,"^H",95,536871489]],["^15",[32,"^17",true,536870919]],["^15",[32,"^;","~u646f207f-395b-4a70-bc4e-0f997b31d1b1",536870919]],["^15",[33,"^Q","Polar form: We can use polar(s,a) to construct a Complex Number which has length s and angle a (radian) from origin. Polar returns a CD/CI based on the input type.\nAnother use of polar is for vector rotation.\nA CN can be represented as a vector, and this vector can be rotated by multiplying it with a vector with length 1 and angle a. \nFor ex.:\n```cpp\nCD vec{CD(4,2)};\ncout<<arg(vec); //0.463\nvec*=polar(1.0,0.5);\ncout<<arg(vec); //0.963\n```",536870919]],["^15",[33,"^O","^16",536870919]],["^15",[33,"^F",42,536870919]],["^15",[33,"^X",23,536870919]],["^15",[33,"^V",23,536870919]],["^15",[33,"^U",23,536870919]],["^15",[33,"^17",true,536870919]],["^15",[33,"^;","~u646f207f-65d9-475b-8477-89729fd0d158",536870919]],["^15",[34,"^Q","Distance Functions\nDefines the distance between any 2 points, there’s the standard Euclidean distance, which is the plain and straight distance to a point\n$$\\text{Euclidean Distance} = \\sqrt{ (x_2 - x_1)^2 + (y_2-y_1)^2 }$$\n\nIt uses Pythagoras’ theorem in a triangle to calculate the distance.\nrepresented like so\n![image.png](../assets/image_1683282352124_0.png)\n*There’s another type of distance metric known as a Manhattan Distance which uses a grid-like path, or rather the sum of the differences in each of the cartesian co-ordinates. \nThat is,\n$$\\text {Manhattan Distance} = \\left | x_1 - x_2 \\right | + \\left | y_1- y_2 \\right |$$\n\nWe basically summed the difference of the cartesian co-ordinates, this means we follow a grid-like path to the point and not a straight line like so\n![image.png](../assets/image_1683288296272_0.png)\n\n* Then there’s the Chessboard distance or the Chebyshev distance, which is the maximum of difference of either coordinates between 2 points.\n$$\\text {Chebyshev Distance} = \\max ( \\left | x_1 - x_2 \\right |, \\left | y_1 - y_2 \\right | )$$\n\nIt looks like so \n![image.png](../assets/image_1683288436752_0.png) \n\nThe Chebyshev distance can be thought of as a King’s minimum number of moves to reach another block on a chessboard, as shown here\n![image.png](../assets/image_1683288446994_0.png)\n\n* Properties\n ** 1 unit\n\n![image.png](../assets/image_1683288515797_0.png)\n\nand with Chebyshev\n\n![image.png](../assets/image_1683288525779_0.png)\n\nWe can visually see why the Chebyshev is 1 for all green points, it’s because it doesn’t care about the diagonals, just the pure maximum of difference of either axes between any 2 points. Or we can say 1 unit of Chebyshev Distance is the distance travelled on x-axis, or y-axis or on both at the same time (diagonal) so (1,1) is still 1 Chebyshev Distance as we can use both or either of the axes to move.\n\n** As we can see above, a Chebyshev distance can be converted to a Manhattan Distance if we rotate it by 45 degrees, and same for the other way around. This means,\n\n``45 degree Rotated Chebyshev or Manhattan = Manhattan or Chebyshev respectively.``\n\nA simple way to rotate a Manhattan to a Chebyshev is,\nfor a point \n``p=(x,y)``\nwe transform it as \n``p’= (x+y , y-x)``\n\nThis transforms a point by rotating it 45 degrees and scaling it.\n\nFor ex.:\n![image.png](../assets/image_1683288664305_0.png)\n\n\nWe have to find the max. Manhattan Distance between any 2 points here\n\nIt is BC here and the MD is 5 as we can see.\nBut we can also convert all points to use a CD by rotating all points by 45 degrees, like so\n![image.png](../assets/image_1683288686822_0.png)\n \n\nNow for this graph the MD will be different but the CD will give us the MD for graph 1. \nSo for any 2 points in the rotated graph, \n$$\\text {CD} = \\max ( \\left | x_{1’} - x_{2’}, y_{1’} - y_{2’} \\right|)$$\nwhere x’ and y’ are the rotated points. and this CD is actually the MD for the normal graph.\n\nThis has the benefit that now, we can look at each axis separately, so between any 2 points if their x or their y coordinate has maximum difference then they will give the max. MD.",536870919]],["^15",[34,"^O","^16",536870919]],["^15",[34,"^F",35,536870919]],["^15",[34,"^X",23,536870919]],["^15",[34,"^V",23,536870919]],["^15",[34,"^U",23,536870919]],["^15",[34,"^17",true,536870919]],["^15",[34,"^;","~u646f207f-88cb-4dcf-a1a4-226d0b85adac",536870919]],["^15",[35,"^Q","Pick’s Theorem \nTells us the area of a polygon is\n$$\\text Area = a + \\frac{b}{2} - 1$$\nwhere a are the integer points strictly inside the polygon and b are the integer points exactly on the boundary of the polygon. Integer co-ordinates are also known as lattice points.\nFor ex.:\n![image.png](../assets/image_1683281026895_0.png)\n \n\nHere, a = 6 and b = 7.\nSo there are said to be 6 lattice points inside and 5 on the boundary.",536870919]],["^15",[35,"^O","^16",536870919]],["^15",[35,"^F",45,536870919]],["^15",[35,"^X",23,536870919]],["^15",[35,"^V",23,536870919]],["^15",[35,"^U",23,536870919]],["^15",[35,"^17",true,536870919]],["^15",[35,"^;","~u646f207f-ff10-421a-9e78-55f079ae72f2",536870919]],["^15",[36,"^Q","[[Cross Product]]: For 2 vectors (CI/CD), a and b, the cross product is only defined for 3D. But if they are complex numbers then they can use [[Complex Number]] Multiplication and get a scalar value, this scalar value tells us the direction of b when its tail is placed at a’s tip. \nIf $$\\begin{aligned} a \\times b > 0 \\end{aligned}$$, b turns left\nIf $$\\begin{aligned} a \\times b = 0 \\end{aligned}$$, b turns 180 degrees or goes straight ahead\nIf $$\\begin{aligned} a \\times b < 0 \\end{aligned}$$, b turns right.\n\n![image.png](../assets/image_1683265036139_0.png){:height 185, :width 597}\n\n$$ a \\times b = a_1*b_2 - a_2*b_1 $$ \n(for 2D, vector cross product is the CN multiplication), it can be retrieved by\n``double result { (conj(a)*b).I };``\nHere conj turns a’s imaginary part (or y axis) negative, as conjugate of a CN is simply the sign of its imaginary part flipped so we get (a_{1}, -a_{2}) and the CN multiplication of this with b is\na_{1}b_{2} - a_{2}b_{1}\nYes, C++ performs CN multiplication on multiplication of 2 CNs.\n\nThis is also to say, that whilst Vector Cross Product isn’t defined for 2D, we can represent the 2D vectors as Complex Numbers and perform Complex Number Multiplication on them. This is not the same as a vector cross product as it doesn’t give a third vector which is perpendicular to both the vectors, nor is it the same as vector dot product which tells us about the projection of a vector onto another. Instead, it simply helps us understand the rotation of the second vector in 2D space.",536875453]],["^15",[36,"^O","^16",536870919]],["^15",[36,"^F",33,536870919]],["^15",[36,"^X",23,536870919]],["^15",[36,"^V",23,536870919]],["^15",[36,"^U",23,536875249]],["^15",[36,"^U",28,536875249]],["^15",[36,"^U",29,536875249]],["^15",[36,"^?",["^ "],536875453]],["^15",[36,"^H",28,536875453]],["^15",[36,"^H",29,536875453]],["^15",[36,"^17",true,536870919]],["^15",[36,"^;","~u646f207f-0b76-4d23-804d-e64b2ba79da0",536870919]],["^15",[37,"^Q","We can also calculate distance between 2 points using abs(),\nto do so say a and b are CD, then\n``double dist{ abs(b-a) }; ``\nwill return the distance between them.",536870919]],["^15",[37,"^O","^16",536870919]],["^15",[37,"^F",43,536870919]],["^15",[37,"^X",23,536870919]],["^15",[37,"^V",23,536870919]],["^15",[37,"^U",23,536870919]],["^15",[37,"^17",true,536870919]],["^15",[37,"^;","~u646f207f-5746-48f7-adc9-752eca69d4ae",536870919]],["^15",[38,"^Q","[[Convex Hull]]",536875460]],["^15",[38,"^O","^16",536870919]],["^15",[38,"^F",96,536871489]],["^15",[38,"^X",23,536870919]],["^15",[38,"^V",23,536870919]],["^15",[38,"^U",23,536875461]],["^15",[38,"^U",244,536875461]],["^15",[38,"^?",["^ "],536875460]],["^15",[38,"^H",244,536875460]],["^15",[38,"^17",true,536870919]],["^15",[38,"^;","~u646f207f-3ad1-4831-87c9-01ce4cdc5228",536870919]],["^15",[39,"^Q","Applications of CN multiplication/vector cross product (for 2D):\n\n* Testing point location: If we have 3 points, A, B and P and we wish to know if P is on the line passing through A and B, then we can do so\n``double R = (P - A) X (P - B)``\nwhich returns a scalar value, \n0 means P is on the line passing through A and B \n\\>0 means P is on the left of the line\n\\<0 means it is on the right.\n\nFor ex.:\n\n![image.png](../assets/image_1683265668634_0.png)\n \nHere A= (2,3), B= (9,3) and P = (5,3) and after computing R we get R = 0 which means P lies on the line passing through A and B.\n\nSo, to use a 2D co-ordinate, we turn it to CN/Vector 2D then we perform the above CN Multiplication/cross product\nlike so\n      ```cpp\n      CD a{p-x};\n      CD b{p-y};\n      double result{(conj(a)*b).I};\n      ```\nThis identifies if for a point x and y, another point p falls on the line passing through them, or its left or right.\n\n** Properties:\n*** Even if P is ahead of AB, it will still give R as 0. This is also to say, we aren’t checking if P lies on the line between A and B, we are checking if P lies on the line that passes through A and B, so it can be that P occurs before A and B, between A and B and after A and B and in all cases R will be 0 as it is on the line that goes through them.\n\n* Intersection of lines: We can determine if 2 straight lines intersect or not.\nSay we are given 4 points a, b, c and d and told there are 2 line segments, ad and cb.\nThen there are 3 cases if 2 lines intersect,\n\n** Case 1: The line segments are on the same line. In this case there are infinite points of one line intersecting with other wherever they overlap. We just test the given points with simple vector cross product and if they are all 0 then we test if any of the point lies between a line segment.\n\n![image.png](../assets/image_1683266231798_0.png)\n\n\nFirst we simply get the vector cross product of all of them with respect to any other 2 points and see if all of these cross products are 0. This tells us if all of them lie on the same line passing through them. If they don’t then that means Case 1 isn’t true as the lines don’t overlap.\n\nNow to check if they intersect, we sort them based on their x or y co-ordinate. This tells us if any point lies on the other line segment, we already know they are on the same line passing through them, and this confirms if a line segment overlaps the other.\n\nSo in the above case we get all vector cross products as 0, then we sort the points on x axis and find out the order is a, c, b and d. Meaning at-least c falls between a and d and hence there is an intersect and an overlap.\n\n\n** Case 2: There is only 1 intersection point, and it is one of the vertices/given points. Here we get the vector cross products of the points of the one line segment’s vertices with respect to the other 2, then do it for the other one and if one of the points is on the line passing through the other line segments vertices then that means that point intersects with this line segment.\n\nFor example:\n\n![image.png](../assets/image_1683266308873_0.png)\n\nWe find vector cross product of first c and d with respect to a and b then a and b with respect to c and d, here we find the vector cross product of c on the line a and b as 0 and some negative value for d. This means c lies on the line passing through a and b and hence we have an intersection point.\n\n** Case 3: There is only 1 intersection point but it is neither of the vertices. In this case we take one line segment and get vector cross product for both its points with respect to the 2 points of the other line segment and then do the same for that line segment. Then, if for both line segments 1 point falls to the left of the other line segment and the other point falls to the right of the other line segment, then they intersect somewhere.\n\nFor example:\n\n![image.png](../assets/image_1683266342566_0.png)\n\n\nHere, we get vector cross product of both c and d AND a and b with respect to a and b and c and d respectively. If they intersect somewhere, as we can see above, then vector cross product of a will be >0 and b will be <0, and the same will be true for c and d. If both these are true as here, then it means ab and cd intersect somewhere.\n\nIn C++,\n```cpp\n    // 2D vector cross product aka Complex Number Multiplication\n    double crossProduct(CD &a, CD &b, CD &p)\n    {\n        CD temp1{p - a};\n        CD temp2{p - b};\n        double result{(conj(temp1) * temp2).I};\n\n        return result;\n    }\n\n    bool comparatorCD(CD &a, CD &b)\n    {\n        return (a.R == b.R) ? (a.I < b.I) : (a.R < b.R);\n    }\n    //checks if the point b is in middle on the cartesian plane with respect to the other args.\n    bool isMid(CD &a, CD &b, CD &c)\n    {\n        std::vector<CD> temp{a, b, c};\n        std::sort(temp.begin(), temp.end(), comparatorCD);\n\n        return temp[1] == b;\n    }\n\n    void start()\n    {\n        double resA1{crossProduct(b1, b2, a1)};\n\n        double resA2{crossProduct(b1, b2, a2)};\n\n        double resB1{crossProduct(a1, a2, b1)};\n\n        double resB2{crossProduct(a1, a2, b2)};\n\n        result = \"NO\";\n\n        if (resB1 == 0 && isMid(a1, b1, a2))\n        {\n            result = \"YES\";\n        }\n        else if (resB2 == 0 && isMid(a1, b2, a2))\n        {\n            result = \"YES\";\n        }\n        else if (resA1 == 0 && isMid(b1, a1, b2))\n        {\n            result = \"YES\";\n        }\n        else if (resA2 == 0 && isMid(b1, a2, b2))\n        {\n            result = \"YES\";\n        }\n        if ((resA1 * resA2) < 0 && (resB1 * resB2) < 0) // case 3\n        {\n            result = \"YES\";\n        }\n\n        output();\n    }\n```\nThe logic is pretty simple, first we test each point against the other line segment. This way we know where each point lies wrt the other line segment. Now if a point is in between the points of the other line segment and lies on the line then we have case 1 or case 2 fulfilled. Lastly if that is not true then we check for case 3  which requires both pairs of points to be on the opposite side of the other line segment. We can check this by simply multiplying the opposite resultant values, it will be -ve if exactly one of them is negative.\n\n* Distance from a point to a line: Using vector cross product we can calculate the distance from a point to a line. This is because we can calculate the area of a triangle using vector cross products using the formula\n$$\\text {Area of a triangle} = \\frac {(\\left| (a-c) \\times (b-c) \\right|)}{2}$$\n| | here means +ve value not vector magnitude because 2D vector cross product returns a scalar value.\nHere a, b and c are 3 points or rather vertices of the triangle.\n\nUsing this we can find out the height of the triangle, i.e., shortest distance from c to line passing through a and b using this formula\n\n$$ \\text d= \\frac {(a-c) \\times (b-c)}{(\\left| b – a \\right|)}$$\nThis is because for the area of a triangle we have 2 formulae, first is (½)*(|b-a|)*d, which gives the normal area of triangle and then (| (a-c) X (b-c) |) / 2, which is using the vector cross product. Here d is the height.\nFor example:\n\n![image.png](../assets/image_1683266522901_0.png) \n\nIn the above image, if we find d using the distance formula then that will give us the shortest distance from p to the line passing through S1 and S2.\n\n* Point in a polygon: We can test if a point is inside a polygon with a simple algorithm. We cast arbitrary number of rays in arbitrary directions from the point, if the rays intersect with any of the boundary of the polygon 0 or even number of times then the point is outside, otherwise it is inside.\n\nFor example:\n\n![image.png](../assets/image_1683266562064_0.png)\n\n\nA naïve approach here would be checking if the ray of sufficient length making a line segment from a given point, say b, intersects with any of the line of the polygon, so we check line segment b to ray end against all line segments of the polygon (we can use case 3 of checking if a line intersects) and see how many lines the ray intersects\n\nIn cpp,\n```cpp\n    //Raycasting Alg\n    void start()\n    {\n        CD extPoint{1e9+1,-1e9+1};//Any point on the outside.\n                               //We can use this point to check if any line segment from this point\n                               //to any other point intersects with the polygon and hence\n                               //performing Ray casting.\n        bool isBoundary{false};\n        for(int i{}, countsPoint{}; i<m;++i, countsPoint=0) {\n            isBoundary=false;\n            for(int j{}; j<n;++j){\n                CD& p1{points[i]};\n                CD& p2{extPoint};\n\n                CD& pips1{pips[j]};\n                CD& pips2{pips[(j+1)%n]};\n\n                double resPip1{crossProduct(p1, p2, pips1)};\n                double resPip2{crossProduct(p1, p2, pips2)};\n                double resP1{crossProduct(pips1, pips2,p1)};\n                double resP2{crossProduct(pips1, pips2, p2)};\n\n                if(resP1==0 && isMid(pips1, p1,pips2))\n                {\n                    isBoundary=true;\n                    break;\n                }\n                else if((resPip1*resPip2) < 0 && (resP1*resP2)<0){\n                    countsPoint++;\n                }\n            }\n            if (isBoundary)\n            {\n                results[i]=\"BOUNDARY\";\n            }\n            else if(countsPoint==0 || countsPoint % 2 == 0){\n                results[i]=\"OUTSIDE\";\n            }\n            else {\n                results[i]=\"INSIDE\";\n            }\n        }\n        output();\n    }\n```\nwhere ``pips``(size n) are the vertices of the polygon and ``points``(size m) are the points to be tested if they are inside or outside. The logic is pretty simple, we set up an external point (which has to be guaranteed to be outside the polygon) and for each point to be tested, we create a line segment between the point and the external point and then test their line segment against all line segments of the polygon. The end result are 3 conditions, either the point lies on the boundary/in mid of any line segment of the polygon, or it is outside meaning the no. of line segments it intersects are either 0 or divisible by 2, or inside otherwise. \nWe need to check the ray against all line segments of the polygon because we don't know which line segments it intersects (unlike how we see visually).",536870919]],["^15",[39,"^O","^16",536870919]],["^15",[39,"^F",36,536870919]],["^15",[39,"^X",23,536870919]],["^15",[39,"^V",36,536870919]],["^15",[39,"^U",23,536875454]],["^15",[39,"^U",28,536875454]],["^15",[39,"^U",29,536875454]],["^15",[39,"^17",true,536870919]],["^15",[39,"^;","~u646f207f-5d4e-4a1f-bb18-9c3e999b2eb7",536870919]],["^15",[40,"^Q","",536870919]],["^15",[40,"^O","^16",536870919]],["^15",[40,"^F",36,536870919]],["^15",[40,"^X",23,536870919]],["^15",[40,"^V",23,536870919]],["^15",[40,"^U",23,536870919]],["^15",[40,"^17",true,536870919]],["^15",[40,"^;","~u646f207f-8555-4f77-acc3-e4e632cfe229",536870919]],["^15",[41,"^Q","CI is deprecated as of C++17, so CD is the only one we can use.",536870919]],["^15",[41,"^O","^16",536870919]],["^15",[41,"^F",44,536870919]],["^15",[41,"^X",23,536870919]],["^15",[41,"^V",23,536870919]],["^15",[41,"^U",23,536870919]],["^15",[41,"^17",true,536870919]],["^15",[41,"^;","~u646f207f-1208-46f8-8a5d-a5a1027c1fd3",536870919]],["^15",[42,"^Q","Angle: We can get the angle \n\n![image.png](../assets/image_1683264991101_0.png)\n\nalpha using the function arg(<CN>)\nThis angle has its base on the x axis (so at (x,0) it is 0) and increases counter clockwise. The angle is in radians, where r radians means 180*r/pi or 1 radian = pi/180 degrees.",536870919]],["^15",[42,"^O","^16",536870919]],["^15",[42,"^F",37,536870919]],["^15",[42,"^X",23,536870919]],["^15",[42,"^V",23,536870919]],["^15",[42,"^U",23,536870919]],["^15",[42,"^17",true,536870919]],["^15",[42,"^;","~u646f207f-4967-42af-92cc-c9c1c8cfe286",536870919]],["^15",[43,"^Q","We can find |v| which is the +ve length of a vector v from origin to the point (x,y). Here y is the imaginary part and x is the real part. This is done using the abs(<CN>) function. \nThat is, \n$$\\text{abs(<CN>)} = \\sqrt{x^2+y^2}$$\nWhat is $$\\sqrt{x^2+y^2}$$ ?\n\n![image.png](../assets/image_1683264291580_0.png)\n\nIt is the distance from origin to the point x,y.\nSince it can be floating, it is better to use CD.",536870919]],["^15",[43,"^O","^16",536870919]],["^15",[43,"^F",41,536870919]],["^15",[43,"^X",23,536870919]],["^15",[43,"^V",23,536870919]],["^15",[43,"^U",23,536870919]],["^15",[43,"^17",true,536870919]],["^15",[43,"^;","~u646f207f-45ef-4c3e-8379-1e8d2a350631",536870919]],["^15",[44,"^Q","[[Complex Number]]: MSVC and GCC have a library <complex> that can be used to represent complex numbers.\nNow CNs theirselves can use either floating or integer coordinates, so we can do\n```cpp\n#define R real()\n#define I imag()\n\nusing CD = complex<long double>;\nusing CI = complex<long long>;\n\nand then define a CN with\nCI c{ CI(4,2) };\ncout << c.R << c.I << endl;\n```",536874525]],["^15",[44,"^O","^16",536870919]],["^15",[44,"^F",31,536870919]],["^15",[44,"^X",23,536870919]],["^15",[44,"^V",23,536870919]],["^15",[44,"^U",23,536870919]],["^15",[44,"^U",28,536870919]],["^15",[44,"^H",28,536870919]],["^15",[44,"^17",true,536870919]],["^15",[44,"^;","~u646f207f-cee4-4560-9e29-101925132000",536870919]],["^15",[45,"^Q","Area of a Polygon\nThere are 2 simple ways to calculate the area enclosed by a polygon, dividing a polygon into known shapes and summing the parts. Or using formulae such as shoelace formula, aka Gauss’ Area Formula, aka Surveyor’s Formula. \nIf the shape is a basic regular polygon such as a triangle or rectangle or trapezoid or etc., then using the normal area formula for that shape is faster than using shoelace but otherwise this is a faster and simpler calculation.\n\nThe formula is\n$$\\text{Area} = \\frac{1}{2} \\left|\\sum_{i=1}^{n-1} (x_iy_{i+1} - x_{i+1}y_i)\\right|$$\n\nor\n\n$$\\text{Area} = \\frac{1}{2} \\left|\\sum_{i=1}^{n-1} (p_i \\times p_{i+1})\\right|$$\n\nwhere p is a CN and this is a 2D vector cross product or CN multiplication.\np_{i} is any point (x_{i},y_{i}) and p_{i+1} is the point adjacent to it, we follow a direction, i.e., either right or left and then only go in that dirn.\nFor ex.:\n\n![image.png](../assets/image_1683266699836_0.png) \n\nHere, p_{1} can be (2,4) then if we go right then p_{2} will be (5,5) and we only go this way for consequent points. Similarly, we can go left to (4,3) and all consequent points will be the next adjacent points.\nThis doesn’t just apply to the CN version but also the normal formula as well.\nThe idea of the formula is to simply compute the area for each trapezoid in the polygon, where the first side is the side of the polygon and the second side is the horizontal axis line at y=0 like so\n\n![image.png](../assets/image_1683280650170_0.png) \n\nThe area of each trapezoid here is \n$$Area = (x_{i+1} - x_{i})*\\frac{(y_{i} + y_{i+1})}{2}$$\n\nIn CPP,\n```cpp\n    void start()\n    {\n        double value{};\n        CD* next{nullptr};\n        for(int i{}; i<n;++i) {\n            next= &points[(i+1)%n];\n            value += ((points[i].R* (*next).I) - ((*next).R * points[i].I));\n        }\n\n        result = static_cast<int>(abs(value)); //multiplying with 1/2 and 2, i.e. 1.\n        output();\n    }\n\n```\nHere we simply go through each point and its next point and sum this value then simply multiply the result with 1/2 as that's in the formula for each trapezium and multiply with 2 to cancel it out and ensure the integer remains an integer (1/2 of an integer can be double, but the inputs are strictly integer).",536870919]],["^15",[45,"^O","^16",536870919]],["^15",[45,"^F",40,536870919]],["^15",[45,"^X",23,536870919]],["^15",[45,"^V",23,536870919]],["^15",[45,"^U",23,536870919]],["^15",[45,"^17",true,536870919]],["^15",[45,"^;","~u646f207f-c5a2-4400-9b83-54fbb595f883",536870919]],["^15",[46,"^3","alias:: Line Intersection\n\n- Suppose we have orthogonal line segments like so\n  ![image.png](../assets/image_1684566689683_0.png)\n  \n  As we can see, there are 3 intersection points.\n- There are 2 types of line intersection algs, orthogonal and general case ([Bowdoin.edu]( https://tildesites.bowdoin.edu/~ltoma/teaching/cs3250-CompGeom/spring17/Lectures/orthosegmintersect-6up.pdf)). The former is quite simpler as we can simply 'sweep' from left to right (Leftmost segment X axis) or top to bottom (Topmost segment Y axis) and count number of intersections.\n- In orthogonal line segment intersection, we focus on 3 events, \n  1. Horizontal LS begins\n  2. Horizontal LS ends\n  3. Vertical LS occurs. \n  The logic for this sweep line is simple, we start from the leftmost X axis point and then go rightwards  processing all 3 events on the X axis. \n  The starting point itself could belong to either a VLS or an HLS, now if we face event 1, we store the Y co-ordinate of the HLS in a data structure like a Set, if we face event 2 we search for the Y co-ordinate and remove it from our data structure and if we face event 3 we check for all the Y co-ordinates stored in our data structure within the range [VLS' start Y co-ordinate, VLS' end Y co-ordinate].\n  In C++,\n  ```cpp\n  enum SegType {\n   H, //Horizontal\n   V  //Vertical\n  };\n  int testCases{1};\n  int n{};\n  std::vector<std::pair<CD,SegType>> totalSegs; //\n  int result{};\n  si activeSegs{};\n  \n  namespace Algorithm\n  {\n      using namespace std;\n      void start();\n      void output();\n      bool comparator(pair<CD,SegType>& , pair<CD,SegType>& );\n  \n      void setup()\n      {\n          IOS;\n  #ifdef LOCAL\n          FILE *inpStream;\n          FILE *outStream;\n          freopen_s(&inpStream, \"input.txt\", \"r\", stdin);\n          freopen_s(&outStream, \"output.txt\", \"w\", stdout);\n  #endif\n          // INPUT(testCases);\n  \n          while (testCases-- > 0)\n          {\n              INPUT(n);\n              double arg1{};\n              double arg2{};\n              double arg3{};\n              double arg4{};\n  \n  \n              for (int i{}; i < n; ++i)\n              {\n                  SegType s{};\n                  INPUT(arg1, arg2, arg3, arg4);\n  \n                  if(arg1==arg3) { // Vertical Segment\n                      s=SegType{V};\n                  }\n                  else{\n                      s= SegType{H};\n                  }\n  \n  \n                  totalSegs.pb(pair(CD({arg1,arg2}), s));\n                  totalSegs.pb(pair(CD({arg3,arg4}), s));\n              }\n              sort(totalSegs.begin(), totalSegs.end(), comparator);\n              n*=2;\n              start();\n          }\n      }\n  \n      bool comparator(pair<CD,SegType>& a, pair<CD,SegType>& b ) {\n          return (a.first.R == b.first.R) ? a.first.I > b.first.I : a.first.R < b.first.R;\n      }\n  \n  \n     void start()\n      {\n          CD* firstV{nullptr};\n          CD* secondV{nullptr};\n          for(int i{0}; i< n; ++i) {\n              SegType& sType{totalSegs[i].second};\n              CD& point{totalSegs[i].first};\n  \n              if(sType == SegType{H}) {\n                  if(activeSegs.find(point.I)== activeSegs.end()) {\n                      activeSegs.insert(point.I);\n                  }\n                  else if(firstV != nullptr) {\n                      result++;\n                      activeSegs.erase(point.I);\n                  }\n                  else {\n                      activeSegs.erase(point.I);\n                  }\n              }\n              else {\n                  if(firstV == nullptr) {\n                      firstV=&point;\n                  }\n                  else{\n                  secondV=&point;\n  \n                  for(int elem: activeSegs){\n                      if(elem >= secondV->I && elem <= firstV->I) { //The way we sort enables us the assumption that the element that comes later in totalSegs has greater Y axis (I)\n                          result++;\n                      }\n                   }\n                  firstV=nullptr;\n                  secondV=nullptr;\n                  }\n              }\n              \n          }\n  \n          \n          output();\n      }\n  \n      void output()\n      {\n  \n          std::cout << result  << '\\n';\n  \n          std::cout << std::endl;\n      }\n  \n  \n  \n  }\n  ```\n  Here, the logic is pretty straight forward. If given n line segments \n  we\n  * Identify if it is a VLS or an HLS, it is VLS if the x axis of both points of the LS are same. Then store them. \n  * Sort all points based on X axis in ascending order, if X axis is same then sort based on Y axis (descending order). We do this to sweep from left to right, and if for any 2 points X is same like if it's the starting point of an HLS and a VLS is already being tracked, this ensures the point comes whilst the VLS is already being tracked so we don't miss processing the HLS within it.\n  So we store the points like so\n  ![image.png](../assets/image_1685786141621_0.png)\n  \n  * Then begins our main logic, we loop over all the sorted points. \n  * If the current point belongs to a VLS then we store it if we don't have a tracked VLS pair and wait for it's other point, the way we sorted ensures that we first get the higher Y axis point of the VLS then the lower one. Once we get both the points in our iteration, we simply search for all tracked LS' Y axis between the Y axis of this VLS and add it to our result.\n  \n  If the current point belongs to an HLS, we either store it if it isn't already stored, if it is stored then we see if we are on a VLS, if we are we add 1 to result and remove it and if we aren't then we simply remove the point indicating this HLS ended.\n-\n-",536871671]],["^15",[46,"^18",1685004415273,536870919]],["^15",[46,"^19","~m1686379968893",536871670]],["^15",[46,"^Z","pages/Intersection Points.md",536870919]],["^15",[47,"^Q","Suppose we have orthogonal line segments like so\n![image.png](../assets/image_1684566689683_0.png)\n\nAs we can see, there are 3 intersection points.",536870919]],["^15",[47,"^O","^16",536870919]],["^15",[47,"^F",102,536871669]],["^15",[47,"^X",30,536870919]],["^15",[47,"^V",30,536870919]],["^15",[47,"^U",30,536870919]],["^15",[47,"^17",true,536870919]],["^15",[47,"^;","~u646f207f-c16e-4bbb-8a69-7a962a75f033",536870919]],["^15",[48,"^Q","There are 2 types of line intersection algs, orthogonal and general case ([Bowdoin.edu]( https://tildesites.bowdoin.edu/~ltoma/teaching/cs3250-CompGeom/spring17/Lectures/orthosegmintersect-6up.pdf)). The former is quite simpler as we can simply 'sweep' from left to right (Leftmost segment X axis) or top to bottom (Topmost segment Y axis) and count number of intersections.",536870976]],["^15",[48,"^O","^16",536870919]],["^15",[48,"^F",47,536870919]],["^15",[48,"^X",30,536870919]],["^15",[48,"^V",30,536870919]],["^15",[48,"^U",30,536870919]],["^15",[48,"^?",["^ "],536870976]],["^15",[48,"^17",true,536870919]],["^15",[48,"^;","~u646f207f-845a-4219-b1c0-b0c61a161e46",536870919]],["^15",[49,"^Q","In orthogonal line segment intersection, we focus on 3 events, \n1. Horizontal LS begins\n2. Horizontal LS ends\n3. Vertical LS occurs. \nThe logic for this sweep line is simple, we start from the leftmost X axis point and then go rightwards  processing all 3 events on the X axis. \nThe starting point itself could belong to either a VLS or an HLS, now if we face event 1, we store the Y co-ordinate of the HLS in a data structure like a Set, if we face event 2 we search for the Y co-ordinate and remove it from our data structure and if we face event 3 we check for all the Y co-ordinates stored in our data structure within the range [VLS' start Y co-ordinate, VLS' end Y co-ordinate].\nIn C++,\n```cpp\nenum SegType {\n H, //Horizontal\n V  //Vertical\n};\nint testCases{1};\nint n{};\nstd::vector<std::pair<CD,SegType>> totalSegs; //\nint result{};\nsi activeSegs{};\n\nnamespace Algorithm\n{\n    using namespace std;\n    void start();\n    void output();\n    bool comparator(pair<CD,SegType>& , pair<CD,SegType>& );\n\n    void setup()\n    {\n        IOS;\n#ifdef LOCAL\n        FILE *inpStream;\n        FILE *outStream;\n        freopen_s(&inpStream, \"input.txt\", \"r\", stdin);\n        freopen_s(&outStream, \"output.txt\", \"w\", stdout);\n#endif\n        // INPUT(testCases);\n\n        while (testCases-- > 0)\n        {\n            INPUT(n);\n            double arg1{};\n            double arg2{};\n            double arg3{};\n            double arg4{};\n\n\n            for (int i{}; i < n; ++i)\n            {\n                SegType s{};\n                INPUT(arg1, arg2, arg3, arg4);\n\n                if(arg1==arg3) { // Vertical Segment\n                    s=SegType{V};\n                }\n                else{\n                    s= SegType{H};\n                }\n\n\n                totalSegs.pb(pair(CD({arg1,arg2}), s));\n                totalSegs.pb(pair(CD({arg3,arg4}), s));\n            }\n            sort(totalSegs.begin(), totalSegs.end(), comparator);\n            n*=2;\n            start();\n        }\n    }\n\n    bool comparator(pair<CD,SegType>& a, pair<CD,SegType>& b ) {\n        return (a.first.R == b.first.R) ? a.first.I > b.first.I : a.first.R < b.first.R;\n    }\n\n\n   void start()\n    {\n        CD* firstV{nullptr};\n        CD* secondV{nullptr};\n        for(int i{0}; i< n; ++i) {\n            SegType& sType{totalSegs[i].second};\n            CD& point{totalSegs[i].first};\n\n            if(sType == SegType{H}) {\n                if(activeSegs.find(point.I)== activeSegs.end()) {\n                    activeSegs.insert(point.I);\n                }\n                else if(firstV != nullptr) {\n                    result++;\n                    activeSegs.erase(point.I);\n                }\n                else {\n                    activeSegs.erase(point.I);\n                }\n            }\n            else {\n                if(firstV == nullptr) {\n                    firstV=&point;\n                }\n                else{\n                secondV=&point;\n\n                for(int elem: activeSegs){\n                    if(elem >= secondV->I && elem <= firstV->I) { //The way we sort enables us the assumption that the element that comes later in totalSegs has greater Y axis (I)\n                        result++;\n                    }\n                 }\n                firstV=nullptr;\n                secondV=nullptr;\n                }\n            }\n            \n        }\n\n        \n        output();\n    }\n\n    void output()\n    {\n\n        std::cout << result  << '\\n';\n\n        std::cout << std::endl;\n    }\n\n\n\n}\n```\nHere, the logic is pretty straight forward. If given n line segments \nwe\n* Identify if it is a VLS or an HLS, it is VLS if the x axis of both points of the LS are same. Then store them. \n* Sort all points based on X axis in ascending order, if X axis is same then sort based on Y axis (descending order). We do this to sweep from left to right, and if for any 2 points X is same like if it's the starting point of an HLS and a VLS is already being tracked, this ensures the point comes whilst the VLS is already being tracked so we don't miss processing the HLS within it.\nSo we store the points like so\n![image.png](../assets/image_1685786141621_0.png)\n\n* Then begins our main logic, we loop over all the sorted points. \n* If the current point belongs to a VLS then we store it if we don't have a tracked VLS pair and wait for it's other point, the way we sorted ensures that we first get the higher Y axis point of the VLS then the lower one. Once we get both the points in our iteration, we simply search for all tracked LS' Y axis between the Y axis of this VLS and add it to our result.\n\nIf the current point belongs to an HLS, we either store it if it isn't already stored, if it is stored then we see if we are on a VLS, if we are we add 1 to result and remove it and if we aren't then we simply remove the point indicating this HLS ended.",536871474]],["^15",[49,"^O","^16",536870919]],["^15",[49,"^F",48,536870919]],["^15",[49,"^X",30,536870919]],["^15",[49,"^V",30,536870919]],["^15",[49,"^U",30,536870980]],["^15",[49,"^?",["^ "],536871474]],["^15",[49,"^17",true,536870919]],["^15",[49,"^;","~u646f207f-1055-4157-ae9e-45ba9e9ceea3",536870919]],["^15",[50,"^3","- String s of n characters with alphabets({a,b,....z}, i.e., [[Set]] of lower-case Latin characters) is an array from s[0],s[1]....s[n-1].\n- [[Substring]]\n- [[Subsequence]]\n- A ``prefix`` of a string s is any substring p formed from s that starts with the first character of s. For ex.:\n  ```\n  s= \"BYTE\"\n  p= {\"B\", \"BY\", \"BYT\", \"BYTE\"} //p can be any of the substring from this set.\n  ```\n- A ``suffix`` of a string s is any substring p formed from s that ends with the last character of s. For ex.:\n  ```\n  s= \"BYTE\"\n  p= {\"E\", \"TE\", \"YTE\", \"BYTE\"} //p can be any of the substring from this set.\n  ```\n- A ``border`` of a string s is any substring p formed from s that is both the prefix and the suffix of s. For ex.:\n  ```\n  s= \"ABCDAB\"\n  p = \"AB\"; //AB can be both prefix and suffix for s, hence it is a border.\n  ```\n- A ``rotation`` of a string s is another string r that can be created by repeatedly shifting the first character to the end of s.\n  For ex.:\n  ```\n  s= \"STAR\"\n  r= \"TARS\"; //then r can be ARST then RSTA and so on.\n  ```\n- [[Trie]]\n- [[Longest Common Subsequence]]\n-\n-",536877871]],["^15",[50,"^18",1685004415289,536870919]],["^15",[50,"^19","~m1691986230405",536877870]],["^15",[50,"^Z","pages/String.md",536870919]],["^15",[53,"^Q","[[Trie]]",536870945]],["^15",[53,"^O","^16",536870919]],["^15",[53,"^F",59,536870919]],["^15",[53,"^X",24,536870919]],["^15",[53,"^V",24,536870919]],["^15",[53,"^U",24,536870946]],["^15",[53,"^U",67,536870946]],["^15",[53,"^?",["^ "],536870945]],["^15",[53,"^H",67,536870945]],["^15",[53,"^17",true,536870919]],["^15",[53,"^;","~u646f207f-05c7-44d0-bc3e-36cfabca265d",536870919]],["^15",[54,"^Q","",536870919]],["^15",[54,"^O","^16",536870919]],["^15",[54,"^F",321,536877819]],["^15",[54,"^X",24,536870919]],["^15",[54,"^V",24,536870919]],["^15",[54,"^U",24,536870919]],["^15",[54,"^17",true,536870919]],["^15",[54,"^;","~u646f207f-f7e7-405b-9046-a35d4b83f656",536870919]],["^15",[55,"^Q","",536870919]],["^15",[55,"^O","^16",536870919]],["^15",[55,"^F",54,536870919]],["^15",[55,"^X",24,536870919]],["^15",[55,"^V",24,536870919]],["^15",[55,"^U",24,536870919]],["^15",[55,"^17",true,536870919]],["^15",[55,"^;","~u646f207f-5539-4e98-8117-df0d0756adbd",536870919]],["^15",[56,"^Q","[[Substring]]",536877866]],["^15",[56,"^O","^16",536870919]],["^15",[56,"^F",57,536870919]],["^15",[56,"^X",24,536870919]],["^15",[56,"^V",24,536870919]],["^15",[56,"^U",24,536877838]],["^15",[56,"^U",324,536877838]],["^15",[56,"^?",["^ "],536877866]],["^15",[56,"^H",324,536877866]],["^15",[56,"^17",true,536870919]],["^15",[56,"^;","~u646f207f-0a49-4b0d-80ec-4c02276d2769",536870919]],["^15",[57,"^Q","String s of n characters with alphabets({a,b,....z}, i.e., [[Set]] of lower-case Latin characters) is an array from s[0],s[1]....s[n-1].",536876221]],["^15",[57,"^O","^16",536870919]],["^15",[57,"^F",24,536870919]],["^15",[57,"^X",24,536870919]],["^15",[57,"^V",24,536870919]],["^15",[57,"^U",24,536876218]],["^15",[57,"^U",113,536876218]],["^15",[57,"^?",["^ "],536876221]],["^15",[57,"^H",113,536876221]],["^15",[57,"^17",true,536870919]],["^15",[57,"^;","~u646f207f-d0ad-4b7d-a271-e4b403d5948e",536870919]],["^15",[58,"^Q","[[Subsequence]]",536877869]],["^15",[58,"^O","^16",536870919]],["^15",[58,"^F",56,536870919]],["^15",[58,"^X",24,536870919]],["^15",[58,"^V",24,536870919]],["^15",[58,"^U",24,536877828]],["^15",[58,"^U",323,536877828]],["^15",[58,"^?",["^ "],536877869]],["^15",[58,"^H",323,536877869]],["^15",[58,"^17",true,536870919]],["^15",[58,"^;","~u646f207f-7697-4ee6-88c4-5248ac608c5c",536870919]],["^15",[59,"^Q","A ``rotation`` of a string s is another string r that can be created by repeatedly shifting the first character to the end of s.\nFor ex.:\n```\ns= \"STAR\"\nr= \"TARS\"; //then r can be ARST then RSTA and so on.\n```",536870919]],["^15",[59,"^O","^16",536870919]],["^15",[59,"^F",61,536870919]],["^15",[59,"^X",24,536870919]],["^15",[59,"^V",24,536870919]],["^15",[59,"^U",24,536870919]],["^15",[59,"^17",true,536870919]],["^15",[59,"^;","~u646f207f-307c-420d-b9ac-4e2861113dc5",536870919]],["^15",[60,"^Q","A ``suffix`` of a string s is any substring p formed from s that ends with the last character of s. For ex.:\n```\ns= \"BYTE\"\np= {\"E\", \"TE\", \"YTE\", \"BYTE\"} //p can be any of the substring from this set.\n```",536870919]],["^15",[60,"^O","^16",536870919]],["^15",[60,"^F",62,536870919]],["^15",[60,"^X",24,536870919]],["^15",[60,"^V",24,536870919]],["^15",[60,"^U",24,536870919]],["^15",[60,"^17",true,536870919]],["^15",[60,"^;","~u646f207f-eb72-4ec7-b7ae-6b550de1d2c6",536870919]],["^15",[61,"^Q","A ``border`` of a string s is any substring p formed from s that is both the prefix and the suffix of s. For ex.:\n```\ns= \"ABCDAB\"\np = \"AB\"; //AB can be both prefix and suffix for s, hence it is a border.\n```",536870919]],["^15",[61,"^O","^16",536870919]],["^15",[61,"^F",60,536870919]],["^15",[61,"^X",24,536870919]],["^15",[61,"^V",24,536870919]],["^15",[61,"^U",24,536870919]],["^15",[61,"^17",true,536870919]],["^15",[61,"^;","~u646f207f-fd63-4325-a297-934aa987e98a",536870919]],["^15",[62,"^Q","A ``prefix`` of a string s is any substring p formed from s that starts with the first character of s. For ex.:\n```\ns= \"BYTE\"\np= {\"B\", \"BY\", \"BYT\", \"BYTE\"} //p can be any of the substring from this set.\n```",536870919]],["^15",[62,"^O","^16",536870919]],["^15",[62,"^F",58,536870919]],["^15",[62,"^X",24,536870919]],["^15",[62,"^V",24,536870919]],["^15",[62,"^U",24,536870919]],["^15",[62,"^17",true,536870919]],["^15",[62,"^;","~u646f207f-1ac0-4e9c-a1e0-7ead77f2d05f",536870919]],["^15",[63,"^3","alias:: GNU Policy Based Data Structures\n\n- G++/GCC has some optimized versions of important data structures like [[Trie]] implemented and ready to be used in the libraries inside #include ``<ext/pb_ds/...>`` where ... represents the appropriate structure name.\n  For ex.:\n  ```cpp \n  #include <ext/pb_ds/tree_policy.hpp>\n  ```\n- Read more: https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/ and also https://codeforces.com/blog/entry/11080\n-",536870919]],["^15",[63,"^18",1685004415308,536870919]],["^15",[63,"^Z","pages/gnu_pbds.md",536870919]],["^15",[64,"^5",65,536870919]],["^15",[64,"^K",1685004415307,536870919]],["^15",[64,"^[",63,536870919]],["^15",[64,"^@",false,536870919]],["^15",[64,"^Y","gnu_pbds",536870919]],["^15",[64,"^11","gnu_pbds",536870919]],["^15",[64,"^?",["^ ","^1:",["^1;",["GNU Policy Based Data Structures"]]],536870919]],["^15",[64,"^4",["^ ","^1:","GNU Policy Based Data Structures"],536870919]],["^15",[64,"^B",1685004415307,536870919]],["^15",[64,"^;","~u646f207f-8b68-4199-a892-45405cc1e089",536870919]],["^15",[65,"^5",64,536870919]],["^15",[65,"^K",1685004415306,536870919]],["^15",[65,"^@",false,536870919]],["^15",[65,"^Y","gnu policy based data structures",536870919]],["^15",[65,"^11","GNU Policy Based Data Structures",536870919]],["^15",[65,"^B",1685004415306,536870919]],["^15",[65,"^;","~u646f207f-8102-4301-ab1e-101f58f2a29c",536870919]],["^15",[66,"^K",1685004415308,536870919]],["^15",[66,"^@",false,536870919]],["^15",[66,"^Y","include",536870919]],["^15",[66,"^11","include",536870919]],["^15",[66,"^B",1685004415308,536870919]],["^15",[66,"^;","~u646f207f-664e-43a3-95ef-b9d9404b90d8",536870919]],["^15",[67,"^K",1685004415308,536870919]],["^15",[67,"^[",79,536870955]],["^15",[67,"^O","^16",536870949]],["^15",[67,"^@",false,536870919]],["^15",[67,"^Y","trie",536870919]],["^15",[67,"^11","Trie",536870919]],["^15",[67,"^B",1691985981915,536877816]],["^15",[67,"^;","~u646f207f-589a-4c29-8a8f-124d175edc58",536870919]],["^15",[68,"^Q","alias:: GNU Policy Based Data Structures\n\n",536870919]],["^15",[68,"^O","^16",536870919]],["^15",[68,"~:block/invalid-properties",["^1;",[]],536870919]],["^15",[68,"^F",64,536870919]],["^15",[68,"^X",64,536870919]],["^15",[68,"^V",64,536870919]],["^15",[68,"^U",64,536870919]],["^15",[68,"^U",65,536870919]],["^15",[68,"^:",true,536870919]],["^15",[68,"^?",["^ ","^1:",["^1;",["GNU Policy Based Data Structures"]]],536870919]],["^15",[68,"^J",["^1:"],536870919]],["^15",[68,"^4",["^ ","^1:","GNU Policy Based Data Structures"],536870919]],["^15",[68,"^H",65,536870919]],["^15",[68,"^17",true,536870919]],["^15",[68,"^;","~u646f207f-8be7-4c8d-80ea-cee62ad8242a",536870919]],["^15",[69,"^Q","G++/GCC has some optimized versions of important data structures like [[Trie]] implemented and ready to be used in the libraries inside #include ``<ext/pb_ds/...>`` where ... represents the appropriate structure name.\nFor ex.:\n```cpp \n#include <ext/pb_ds/tree_policy.hpp>\n```",536870919]],["^15",[69,"^O","^16",536870919]],["^15",[69,"^F",68,536870919]],["^15",[69,"^X",64,536870919]],["^15",[69,"^V",64,536870919]],["^15",[69,"^U",64,536870919]],["^15",[69,"^U",66,536870919]],["^15",[69,"^U",67,536870919]],["^15",[69,"^H",66,536870919]],["^15",[69,"^H",67,536870919]],["^15",[69,"^17",true,536870919]],["^15",[69,"^;","~u646f207f-a299-4a2e-8d70-43b5b6515474",536870919]],["^15",[70,"^Q","Read more: https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/ and also https://codeforces.com/blog/entry/11080",536870919]],["^15",[70,"^O","^16",536870919]],["^15",[70,"^F",69,536870919]],["^15",[70,"^X",64,536870919]],["^15",[70,"^V",64,536870919]],["^15",[70,"^U",64,536870919]],["^15",[70,"^17",true,536870919]],["^15",[70,"^;","~u646f207f-c416-49a8-9b44-53b24f74d846",536870919]],["^15",[71,"^Q","",536870919]],["^15",[71,"^O","^16",536870919]],["^15",[71,"^F",70,536870919]],["^15",[71,"^X",64,536870919]],["^15",[71,"^V",64,536870919]],["^15",[71,"^U",64,536870919]],["^15",[71,"^17",true,536870919]],["^15",[71,"^;","~u646f207f-d28b-4b5c-8580-95752eff62eb",536870919]],["^15",[72,"^2",1,536870920]],["^15",[72,"^T","^2",536870920]],["^15",[73,"^T","^R",536870921]],["^15",[73,"^R",["^14",["geometry","31-01-2024","longest common subsequence","hackerrank","cses_1068","cses_1731","cses_1608","cses","algorithm","closest pair","divide and conquer","subsequence","substring","default code explanation format","default c++ template"]],536881171]],["^15",[74,"^Q","",536870933]],["^15",[74,"^O","^16",536870933]],["^15",[74,"^@",false,536870933]],["^15",[74,"^?",["^ "],536870933]],["^15",[74,"^17",true,536870933]],["^15",[74,"^;","~u646f20f9-19da-43d7-a291-ecc98d83f547",536870933]],["^15",[75,"^12",2,536870936]],["^15",[76,"^Q","aka prefix tree or digital tree.\nThis is a [[Rooted Tree]] data structure that allows for fast insert, delete and search operation on a [[Set]] of strings. Each character in a string is consecutively stored in the [[Tree]] as individual nodes and if 2 strings contain the same prefix characters, then the same chain of the graph is used. The node representing the end character of a string is marked to know what strings are stored in the trie.\nFor ex.:\n![image.png](../assets/image_1684410092705_0.png)\nHere, the trie has the given strings stored and as we can see CAT and CATTLE share the same chain, the T and E is marked to denote that from the root, the chain C->A->T and C->A->T->T->L->E are the strings here.",536876232]],["^15",[76,"^O","^16",536870950]],["^15",[76,"^@",false,536870950]],["^15",[76,"^F",67,536870950]],["^15",[76,"^X",67,536870950]],["^15",[76,"^V",67,536870950]],["^15",[76,"^U",67,536876229]],["^15",[76,"^U",77,536876229]],["^15",[76,"^U",78,536876229]],["^15",[76,"^U",113,536876229]],["^15",[76,"^?",["^ "],536876232]],["^15",[76,"^H",77,536876232]],["^15",[76,"^H",78,536876232]],["^15",[76,"^H",113,536876232]],["^15",[76,"^17",true,536870950]],["^15",[76,"^;","~u646f6313-cc93-4277-8d2b-dba47a8a685b",536870950]],["^15",[77,"^K",1685021463579,536870953]],["^15",[77,"^@",false,536870953]],["^15",[77,"^Y","tree",536870953]],["^15",[77,"^11","Tree",536870953]],["^15",[77,"^B",1685021463579,536870953]],["^15",[77,"^;","~u646f6317-50d0-4505-8bec-ccc14e853921",536870953]],["^15",[78,"^K",1685021463579,536870953]],["^15",[78,"^@",false,536870953]],["^15",[78,"^Y","rooted tree",536870953]],["^15",[78,"^11","Rooted Tree",536870953]],["^15",[78,"^B",1685021463579,536870953]],["^15",[78,"^;","~u646f6317-2e90-4d1c-b665-ffdf4855a032",536870953]],["^15",[79,"^3","- aka prefix tree or digital tree.\n  This is a [[Rooted Tree]] data structure that allows for fast insert, delete and search operation on a [[Set]] of strings. Each character in a string is consecutively stored in the [[Tree]] as individual nodes and if 2 strings contain the same prefix characters, then the same chain of the graph is used. The node representing the end character of a string is marked to know what strings are stored in the trie.\n  For ex.:\n  ![image.png](../assets/image_1684410092705_0.png)\n  Here, the trie has the given strings stored and as we can see CAT and CATTLE share the same chain, the T and E is marked to denote that from the root, the chain C->A->T and C->A->T->T->L->E are the strings here.\n- To implement a trie\n  \n  * We can use a [[Linked List]] like [[Data Structure]] to store unique chains of letters separately and non-unique chains in existing chains.\n  * We can also use a simple 2-Dimensional [[C++ Array]] to represent chains. \n  \n  Implementing the 2nd one here, the 1st can be easily understood from it as well.\n  \n  ```cpp\n  void setup() {\n    INPUT(k, A, c);\n    trie = vvi(cN, vi(A, 0));\n    eos = vb(cN, false);\n    counter = 0;\n    {\n      string arg{};\n      cin.ignore(intmax, '\\n');\n      for (int i{}; i < k; ++i) {\n        getline(cin, arg);\n        trie_insert(arg);\n      }\n    }\n  }\n  \n  // Trie\n  void compute() {\n    string arg{};\n    while (c-- > 0) {\n      getline(cin, arg);\n      output(search(arg));\n    }\n  }\n  \n  void trie_insert(string_view s) {\n    int sz{cast(s.size())};\n    int next{};\n  \n    for (int i{}; i < sz; ++i) {\n      int &elem{trie[next][cast(s[i] % A)]};\n      if (!elem)\n        elem = ++counter;\n  \n      next = elem;\n    }\n    eos[next] = true;\n  }\n  \n  bool search(string_view s) {\n    int sz{cast(s.size())};\n    int next{};\n    for (int i{}; i < sz; ++i) {\n      int &elem{trie[next][cast(s[i] % A)]};\n      if (!elem)\n        return false;\n  \n      next = elem;\n    }\n    return eos[next];\n  }\n  ```\n  Using [[Default C++ Template]]\n  \n  The logic is quite simple.\n  We use 2 variables, ``eos`` and ``trie``. ``trie`` is a 2-D Array with size ``trie[N][A]`` where ``N`` is the total size of all input [[C++ String]]'s size and ``A`` is the alphabet size. In a string ``s`` we store each ``s[i]`` in ``trie[i]`` and then we use the ``s[i]%A`` position of the array ``trie[i]`` to store a value indicating where at which ``i`` in trie the next character of the string is, this value is named ``counter``. The reason we do this is because ``s[i]`` corresponds to ``trie[i]`` only when the same chain stored in ``trie[i]`` is followed. If it is not, we jump to the next ``trie[n]`` where no char has been stored. This is where the ``counter``'s value comes in handy. ``counter`` essentially keeps track of how many indices in ``trie`` have been used to allow a string to find the next empty index.\n  The ``eos`` variable helps in marking indices of ``trie`` where a string has come to an end. The guarantee here is that each unique string stored in the ``trie`` will have a unique end index, and it will be checked only when a search string expects an index to be an end index.\n  \n  For ex.:\n  For these 4 input strings\n  ```\n  car\n  cat\n  caid\n  bard\n  ```\n  \n  And these 2 strings to be searched in the trie\n  ```\n  card\n  cat\n  ```\n  \n  We store inputs like so, in the order they are given above,\n  ![image.png](../assets/image_1691133074322_0.png)\n  The ``eos`` will be true for 2,5,9.\n  \n  As can be seen from the code and from the image, if an index is already used, it indicates the letter is already stored, and each character stores the index of the next empty row, and except the diverging letter, all letters are stored on new rows. This guarantees, if an index is already used in a row, it means it's part of an existing chain, and if it is not then it is empty and hence our character is the diverging character which will show the next index where we can find the rest of the string. \n  \n  This allows search to be trivial as well. \n  So when we search for ``card``, we get ``c``, ``a`` and even ``r`` but when we look at ``d``, it is empty in the ``trie``, hence ``card`` isn't stored in the ``trie``.\n  \n  [[TC]] is O(n) for storage and O(n) for retrieval as well, but with a fixed constant time overhead of the fixed size of ``trie`` and ``eos``.  For [[SC]], Space is constant O(1) here, but it can also be dependent on the input size, in which case the constant time overhead for TC will be lower as well.",536877818]],["^15",[79,"^19","~m1691985982239",536877817]],["^15",[79,"^Z","pages/Trie.md",536870955]],["^15",[80,"^12",2,536870959]],["^15",[81,"^K",1685044025622,536870960]],["^15",[81,"^O","^16",536870960]],["^15",[81,"^N",20230526,536870960]],["^15",[81,"^@",true,536870960]],["^15",[81,"^Y","26-05-2023",536870960]],["^15",[81,"^11","26-05-2023",536870960]],["^15",[81,"^B",1685044025622,536870960]],["^15",[81,"^;","~u646fbb39-3bac-4981-999b-492b4877f34e",536870960]],["^15",[82,"^Q","",536870961]],["^15",[82,"^O","^16",536870961]],["^15",[82,"^N",20230526,536870961]],["^15",[82,"^@",true,536870961]],["^15",[82,"^F",81,536870961]],["^15",[82,"^X",81,536870961]],["^15",[82,"^V",81,536870961]],["^15",[82,"^U",81,536870962]],["^15",[82,"^?",["^ "],536870961]],["^15",[82,"^17",true,536870961]],["^15",[82,"^;","~u646fbb39-b944-436c-94a8-eb30307003d6",536870961]],["^15",[83,"^12",2,536870964]],["^15",[84,"^K",1685686741605,536870965]],["^15",[84,"^O","^16",536870965]],["^15",[84,"^N",20230602,536870965]],["^15",[84,"^@",true,536870965]],["^15",[84,"^Y","02-06-2023",536870965]],["^15",[84,"^11","02-06-2023",536870965]],["^15",[84,"^B",1685686741605,536870965]],["^15",[84,"^;","~u647989d5-808c-402b-b1f3-b0f3edc955b5",536870965]],["^15",[85,"^Q","",536870966]],["^15",[85,"^O","^16",536870966]],["^15",[85,"^N",20230602,536870966]],["^15",[85,"^@",true,536870966]],["^15",[85,"^F",84,536870966]],["^15",[85,"^X",84,536870966]],["^15",[85,"^V",84,536870966]],["^15",[85,"^U",84,536870967]],["^15",[85,"^?",["^ "],536870966]],["^15",[85,"^17",true,536870966]],["^15",[85,"^;","~u647989d5-d8d3-481c-b23d-024cf8a9ff75",536870966]],["^15",[86,"^K",1685686758153,536870969]],["^15",[86,"^@",false,536870969]],["^15",[86,"^Y","object",536870969]],["^15",[86,"^11","object",536870969]],["^15",[86,"^B",1685686758153,536870969]],["^15",[86,"^;","~u647989e6-8e33-4bd7-9fd7-fee329908a53",536870969]],["^15",[87,"^12",2,536870971]],["^15",[88,"^K",1685785190965,536870972]],["^15",[88,"^O","^16",536870972]],["^15",[88,"^N",20230603,536870972]],["^15",[88,"^@",true,536870972]],["^15",[88,"^Y","03-06-2023",536870972]],["^15",[88,"^11","03-06-2023",536870972]],["^15",[88,"^B",1685785190965,536870972]],["^15",[88,"^;","~u647b0a66-dabc-467f-bdaa-f1c59636966b",536870972]],["^15",[89,"^Q","",536870973]],["^15",[89,"^O","^16",536870973]],["^15",[89,"^N",20230603,536870973]],["^15",[89,"^@",true,536870973]],["^15",[89,"^F",88,536870973]],["^15",[89,"^X",88,536870973]],["^15",[89,"^V",88,536870973]],["^15",[89,"^U",88,536870974]],["^15",[89,"^?",["^ "],536870973]],["^15",[89,"^17",true,536870973]],["^15",[89,"^;","~u647b0a66-e6bf-4e4c-8c60-bad31595b62e",536870973]],["^15",[90,"^Q","",536870995]],["^15",[90,"^O","^16",536870995]],["^15",[90,"^F",91,536871062]],["^15",[90,"^X",30,536870995]],["^15",[90,"^V",30,536870995]],["^15",[90,"^U",30,536870996]],["^15",[90,"^?",["^ "],536870995]],["^15",[90,"^17",true,536870995]],["^15",[90,"^;","~u647b0ac7-8688-429b-9c74-233ca599a1fd",536870995]],["^15",[91,"^Q","",536871062]],["^15",[91,"^O","^16",536871062]],["^15",[91,"^F",49,536871062]],["^15",[91,"^X",30,536871062]],["^15",[91,"^V",30,536871062]],["^15",[91,"^U",30,536871063]],["^15",[91,"^?",["^ "],536871062]],["^15",[91,"^17",true,536871062]],["^15",[91,"^;","~u647b0b5d-1389-4444-bc84-4a3da71fbb5c",536871062]],["^15",[92,"^12",2,536871478]],["^15",[93,"^K",1686378724186,536871479]],["^15",[93,"^O","^16",536871479]],["^15",[93,"^N",20230610,536871479]],["^15",[93,"^@",true,536871479]],["^15",[93,"^Y","10-06-2023",536871479]],["^15",[93,"^11","10-06-2023",536871479]],["^15",[93,"^B",1686378724186,536871479]],["^15",[93,"^;","~u648418e4-6ef7-4d6c-9d85-c46d6bc49ceb",536871479]],["^15",[94,"^Q","",536871480]],["^15",[94,"^O","^16",536871480]],["^15",[94,"^N",20230610,536871480]],["^15",[94,"^@",true,536871480]],["^15",[94,"^F",93,536871480]],["^15",[94,"^X",93,536871480]],["^15",[94,"^V",93,536871480]],["^15",[94,"^U",93,536871481]],["^15",[94,"^?",["^ "],536871480]],["^15",[94,"^17",true,536871480]],["^15",[94,"^;","~u648418e4-981b-4c5d-b75d-a937b8a51076",536871480]],["^15",[95,"^K",1686379234901,536871489]],["^15",[95,"^[",98,536871498]],["^15",[95,"^O","^16",536871493]],["^15",[95,"^@",false,536871489]],["^15",[95,"^Y","closest pair",536871489]],["^15",[95,"^11","Closest Pair",536871489]],["^15",[95,"^B",1688145780422,536875226]],["^15",[95,"^;","~u64841ae2-a578-47d5-9d74-557cb200be58",536871489]],["^15",[96,"^Q","",536871489]],["^15",[96,"^O","^16",536871489]],["^15",[96,"^F",32,536871489]],["^15",[96,"^X",23,536871489]],["^15",[96,"^V",23,536871489]],["^15",[96,"^U",23,536871490]],["^15",[96,"^?",["^ "],536871489]],["^15",[96,"^17",true,536871489]],["^15",[96,"^;","~u64841ae2-85f9-4c1c-acda-3df610ff94c2",536871489]],["^15",[97,"^Q","In this problem, given a set of points in the 2D [[Cartesian Plane]], we are to find 2 points closest to each other where the distance is [[Euclidean Distance]]. \n\nLIke shown here\n![image.png](../assets/image_1686379346764_0.png){:height 222, :width 629}",536871746]],["^15",[97,"^O","^16",536871494]],["^15",[97,"^@",false,536871494]],["^15",[97,"^F",95,536871494]],["^15",[97,"^X",95,536871494]],["^15",[97,"^V",95,536871494]],["^15",[97,"^U",95,536871747]],["^15",[97,"^U",100,536871747]],["^15",[97,"^U",106,536871747]],["^15",[97,"^?",["^ "],536871746]],["^15",[97,"^H",100,536871746]],["^15",[97,"^H",106,536871746]],["^15",[97,"^17",true,536871494]],["^15",[97,"^;","~u64841ae4-0d75-4dba-a466-a5728284b833",536871494]],["^15",[98,"^3","- In this problem, given a set of points in the 2D [[Cartesian Plane]], we are to find 2 points closest to each other where the distance is [[Euclidean Distance]]. \n  \n  LIke shown here\n  ![image.png](../assets/image_1686379346764_0.png){:height 222, :width 629}\n- To solve this problem the logic is like so, we go through the sorted points from left-to-right and keep track of minimum [[Euclidean Distance]] ``d`` between any 2 points. \n  If we have an ``MED``, i.e., ``d``, if there's any point with distance less than ``d`` with any other point then that pair is the closest pair, and we do so until we have processed all the points. We only check the distance with the points already processed, i.e., points on the left.\n  \n  To check if the E.D between any 2 points is the closest, we simply check it's co-ordinates, so if a point is at A $$(x_1, y_1)$$ and we have another point B $$(x_2, y_2)$$ , then for E.D of A to B to be smaller than B, the $$x_1 - x_2 $$ must be within the range $$[x, x+d]$$ (because we are only comparing \n   x_1 with points already processed on the left, this also means that x_1 will always be >= to x_2) and the abs($$y_2 - y_1 $$) must be within the range $$[y-d, y+d]$$.\n  \n  Remember, the E.D between any 2 points is given by $$\\text{Euclidean Distance} = \\sqrt{ (x_2 - x_1)^2 + (y_2-y_1)^2 }$$\n  \n  So in this image\n  ![image.png](../assets/image_1686381685021_0.png){:height 400, :width 400}\n  Say A is at the black point, we are using [[Integer]] co-ordinates, the distance d is given in red, then the green semi-box represents the range within which our points must be to be <= ``d``. The blue points are the only possible points within that range so B must be any of those points to be <= ``d``, there are fixed no. of points inside this box as if we only have Integer co-ordinates then it can be shown that there will be a constant number of points in a fixed region inside the d X d rectangle.\n- For our [[Algorithm]] we use the same idea,\n  \n  * First we sort the points based on their x-axes, and y-axes if x is the same. Unlike in [[Line Intersection]], the y-axis can be sorted in either asc/desc order.\n  ![image.png](../assets/image_1686380077516_0.png){:height 222, :width 225} \n  \n  * Next we create the MED, ``d`` initialized at Infinity and a [[C++ Set]] which will have the processed points in it sorted by their y-axes.\n  \n  * Next, we go through the sorted points in left-to-right iteration. \n  \n  * At each iteration, we check if the x axis of the points stored in the set exceed ``d``, if they do they are removed. \n  Now this is not the same as just plainly removing points if they exceed ``d``, we only consider the x axis here. This is based on the observation that the points farther than d on x axis are guaranteed to be farther than d for all points on the right, but the points farther than d on y axis can potentially be close on the x axis.\n  For ex.: \n  ![image.png](../assets/image_1686388114869_0.png){:height 255, :width 255} \n  Here, even though B and C are close on the y axis, they are much farther from A on the x axis. So if we reach C, and we get d from B and C then A will be removed as no point will ever be <=d to A when we sweep from left-to-right.\n  Similarly,\n  ![image.png](../assets/image_1686388251857_0.png){:height 255, :width 255}\n  Here, when we sweep from left-to-right, we can easily see that to consider point A from C, we mustn't remove A from the set based on its y axis.\n  \n  Hence, in both the cases we can see x axis as the determining factor for a point to have an ED <= d, i.e., if its greater than d on the x axis it will never be forming the closest pair. \n   \n  \n  * Now we simply need to iterate over the points with their y axes in the range $$[y-d, y+d]$$. In the processed points, we already have the guarantee that all points are within $$[x,x+d]$$x of the current point, so now we only need to go through the points whose y is within d as well. This is where creating the set on y axis helps, as the range y-d to y+d will be a continuous range as all points are sorted based on y axis.\n  \n  * In the iteration over the range, we check if the current d is less than the ED between current point in the iteration to the point from the set.\n  \n  * Lastly we insert this point in the set of processed points.\n  \n  In C++,\n  ```cpp\n   int dist(CI& a, CI b) {\n  \n          return ((a.R-b.R)*(a.R-b.R)) + ((a.I-b.I)*(a.I-b.I));\n  \n      }\n  \n   int d{INF};\n          std::set<pii> pp{}; //processed points\n          pp.insert(pii(totalSegs[0].I,totalSegs[0].R));\n  \n          for(int i{1}, j{0}; i<n ;++i) {\n              CI& current{totalSegs[i]};\n              int ed= ceil(sqrt(d)); //euclidean distance converted to int\n              while(j < i && current.R-totalSegs[j].R > ed){ //current.R or x axis will be always greater or equal to the points before\n                                                             //because of how we sorted totalSegs\n                  pp.erase({totalSegs[j].I,totalSegs[j].R});\n                  j++;\n              }\n  \n              auto itLB{pp.lower_bound({current.I - ed, 0})}; //iterator lower bound\n              auto itUB{pp.upper_bound({current.I + ed, 0})};\n              while(itLB != itUB)\n              {\n                  d= min(d, dist(current, {itLB->second,itLB->first}));\n                  itLB++;\n              }\n              pp.insert({current.I,current.R});\n          }\n  \n          output(d);\n  \n  ```\n  We use lower bound which gives the first point greater than the given point, upper bound which gives the last point lesser than the given point, dist() which gives the ED squared,  and j which is a simple optimization to only consider unprocessed (x axis removal) points on the x axis, so if for points 1,2,3 it did not trigger, but for point 4 it triggers then it must go from point 1 to 3, on the other hand if it triggered for point 1 and 2 then for point 4 it only needs to process point 3 as point 1 and 2 are already removed.  \n  \n  \n  \n  *\n- Alternate Algorithm: If we simply go through the points and only consider the last point to compare distance with, then we may miss out on cases where point 1 and 3 are closer than point 1 and 2 and point 2 and 3. Like shown here\n  ![image.png](../assets/image_1686380077516_0.png){:height 222, :width 225}\n  \n  An alternate algorithm that works is by simply going to each point and checking the distance against all other points. TC is $$\\text{O}\\lparen n^2 \\rparen$$\n  \n  Another alternate alg is using [[Divide And Conquer]] but it is trickier to implement.\n-\n- References: Page 246 of [[CPH]]\n  [Robin Visser's Note from University of Cape Town](https://saco-evaluator.org.za/presentations/2015%20Camp%203/Line%20Sweep%20Algorithms%20(Robin%20Visser).pdf)\n  [Codeforces Blog](https://codeforces.com/blog/entry/58747)\n-",536875229]],["^15",[98,"^19","~m1688145780631",536875228]],["^15",[98,"^Z","pages/Closest Pair.md",536871498]],["^15",[100,"^K",1686379307194,536871538]],["^15",[100,"^@",false,536871538]],["^15",[100,"^Y","cartesian plane",536871538]],["^15",[100,"^11","Cartesian Plane",536871538]],["^15",[100,"^B",1686379307194,536871538]],["^15",[100,"^;","~u64841b2b-f344-4c7c-adaf-a18115778114",536871538]],["^15",[101,"^Q","To solve this problem the logic is like so, we go through the sorted points from left-to-right and keep track of minimum [[Euclidean Distance]] ``d`` between any 2 points. \nIf we have an ``MED``, i.e., ``d``, if there's any point with distance less than ``d`` with any other point then that pair is the closest pair, and we do so until we have processed all the points. We only check the distance with the points already processed, i.e., points on the left.\n\nTo check if the E.D between any 2 points is the closest, we simply check it's co-ordinates, so if a point is at A $$(x_1, y_1)$$ and we have another point B $$(x_2, y_2)$$ , then for E.D of A to B to be smaller than B, the $$x_1 - x_2 $$ must be within the range $$[x, x+d]$$ (because we are only comparing \n x_1 with points already processed on the left, this also means that x_1 will always be >= to x_2) and the abs($$y_2 - y_1 $$) must be within the range $$[y-d, y+d]$$.\n\nRemember, the E.D between any 2 points is given by $$\\text{Euclidean Distance} = \\sqrt{ (x_2 - x_1)^2 + (y_2-y_1)^2 }$$\n\nSo in this image\n![image.png](../assets/image_1686381685021_0.png){:height 400, :width 400}\nSay A is at the black point, we are using [[Integer]] co-ordinates, the distance d is given in red, then the green semi-box represents the range within which our points must be to be <= ``d``. The blue points are the only possible points within that range so B must be any of those points to be <= ``d``, there are fixed no. of points inside this box as if we only have Integer co-ordinates then it can be shown that there will be a constant number of points in a fixed region inside the d X d rectangle.",536872982]],["^15",[101,"^O","^16",536871554]],["^15",[101,"^@",false,536871554]],["^15",[101,"^F",97,536871554]],["^15",[101,"^X",95,536871554]],["^15",[101,"^V",95,536871554]],["^15",[101,"^U",95,536872328]],["^15",[101,"^U",106,536872328]],["^15",[101,"^U",109,536872328]],["^15",[101,"^?",["^ "],536872982]],["^15",[101,"^H",106,536872982]],["^15",[101,"^H",109,536872982]],["^15",[101,"^17",true,536871554]],["^15",[101,"^;","~u64841b56-368d-46cc-9aa4-8d879641b1aa",536871554]],["^15",[102,"^Q","alias:: Line Intersection",536871661]],["^15",[102,"^O","^16",536871654]],["^15",[102,"^1<",["^1;",[]],536871661]],["^15",[102,"^F",30,536871654]],["^15",[102,"^X",30,536871654]],["^15",[102,"^V",30,536871654]],["^15",[102,"^U",30,536871662]],["^15",[102,"^U",103,536871662]],["^15",[102,"^:",true,536871661]],["^15",[102,"^?",["^ ","^1:",["^1;",["Line Intersection"]]],536871661]],["^15",[102,"^J",["^14",["^1:"]],536871661]],["^15",[102,"^4",["^ ","^1:","Line Intersection"],536871661]],["^15",[102,"^H",103,536871661]],["^15",[102,"^17",true,536871654]],["^15",[102,"^;","~u64841db8-e82d-48f7-af67-11bd0df10437",536871654]],["^15",[103,"^K",1686379966194,536871661]],["^15",[103,"^@",false,536871661]],["^15",[103,"^Y","line intersection",536871661]],["^15",[103,"^11","Line Intersection",536871661]],["^15",[103,"^B",1686379966194,536871661]],["^15",[105,"^Q","References: Page 246 of [[CPH]]\n[Robin Visser's Note from University of Cape Town](https://saco-evaluator.org.za/presentations/2015%20Camp%203/Line%20Sweep%20Algorithms%20(Robin%20Visser).pdf)\n[Codeforces Blog](https://codeforces.com/blog/entry/58747)",536872682]],["^15",[105,"^O","^16",536871712]],["^15",[105,"^@",false,536871712]],["^15",[105,"^F",107,536872197]],["^15",[105,"^X",95,536871712]],["^15",[105,"^V",95,536871712]],["^15",[105,"^U",95,536872573]],["^15",[105,"^U",114,536872573]],["^15",[105,"^?",["^ "],536872682]],["^15",[105,"^H",114,536872682]],["^15",[105,"^17",true,536871712]],["^15",[105,"^;","~u64841e17-d220-4075-87a6-0253a949e564",536871712]],["^15",[106,"^K",1686380168696,536871746]],["^15",[106,"^@",false,536871746]],["^15",[106,"^Y","euclidean distance",536871746]],["^15",[106,"^11","Euclidean Distance",536871746]],["^15",[106,"^B",1686380168696,536871746]],["^15",[106,"^;","~u64841e88-510d-4d3f-ac90-6228872f22e6",536871746]],["^15",[107,"^Q","",536872197]],["^15",[107,"^O","^16",536872197]],["^15",[107,"^@",false,536872197]],["^15",[107,"^F",121,536873242]],["^15",[107,"^X",95,536872197]],["^15",[107,"^V",95,536872197]],["^15",[107,"^U",95,536872198]],["^15",[107,"^?",["^ "],536873000]],["^15",[107,"^17",true,536872197]],["^15",[107,"^;","~u648421f0-a6b9-481e-8d85-bb77cf9d4177",536872197]],["^15",[109,"^K",1686381728037,536872327]],["^15",[109,"^@",false,536872327]],["^15",[109,"^Y","integer",536872327]],["^15",[109,"^11","Integer",536872327]],["^15",[109,"^B",1686381728037,536872327]],["^15",[109,"^;","~u648424a0-40c1-4975-84d0-e3ce6967d2f7",536872327]],["^15",[110,"^Q","For our [[Algorithm]] we use the same idea,\n\n* First we sort the points based on their x-axes, and y-axes if x is the same. Unlike in [[Line Intersection]], the y-axis can be sorted in either asc/desc order.\n![image.png](../assets/image_1686380077516_0.png){:height 222, :width 225} \n\n* Next we create the MED, ``d`` initialized at Infinity and a [[C++ Set]] which will have the processed points in it sorted by their y-axes.\n\n* Next, we go through the sorted points in left-to-right iteration. \n\n* At each iteration, we check if the x axis of the points stored in the set exceed ``d``, if they do they are removed. \nNow this is not the same as just plainly removing points if they exceed ``d``, we only consider the x axis here. This is based on the observation that the points farther than d on x axis are guaranteed to be farther than d for all points on the right, but the points farther than d on y axis can potentially be close on the x axis.\nFor ex.: \n![image.png](../assets/image_1686388114869_0.png){:height 255, :width 255} \nHere, even though B and C are close on the y axis, they are much farther from A on the x axis. So if we reach C, and we get d from B and C then A will be removed as no point will ever be <=d to A when we sweep from left-to-right.\nSimilarly,\n![image.png](../assets/image_1686388251857_0.png){:height 255, :width 255}\nHere, when we sweep from left-to-right, we can easily see that to consider point A from C, we mustn't remove A from the set based on its y axis.\n\nHence, in both the cases we can see x axis as the determining factor for a point to have an ED <= d, i.e., if its greater than d on the x axis it will never be forming the closest pair. \n \n\n* Now we simply need to iterate over the points with their y axes in the range $$[y-d, y+d]$$. In the processed points, we already have the guarantee that all points are within $$[x,x+d]$$x of the current point, so now we only need to go through the points whose y is within d as well. This is where creating the set on y axis helps, as the range y-d to y+d will be a continuous range as all points are sorted based on y axis.\n\n* In the iteration over the range, we check if the current d is less than the ED between current point in the iteration to the point from the set.\n\n* Lastly we insert this point in the set of processed points.\n\nIn C++,\n```cpp\n int dist(CI& a, CI b) {\n\n        return ((a.R-b.R)*(a.R-b.R)) + ((a.I-b.I)*(a.I-b.I));\n\n    }\n\n int d{INF};\n        std::set<pii> pp{}; //processed points\n        pp.insert(pii(totalSegs[0].I,totalSegs[0].R));\n\n        for(int i{1}, j{0}; i<n ;++i) {\n            CI& current{totalSegs[i]};\n            int ed= ceil(sqrt(d)); //euclidean distance converted to int\n            while(j < i && current.R-totalSegs[j].R > ed){ //current.R or x axis will be always greater or equal to the points before\n                                                           //because of how we sorted totalSegs\n                pp.erase({totalSegs[j].I,totalSegs[j].R});\n                j++;\n            }\n\n            auto itLB{pp.lower_bound({current.I - ed, 0})}; //iterator lower bound\n            auto itUB{pp.upper_bound({current.I + ed, 0})};\n            while(itLB != itUB)\n            {\n                d= min(d, dist(current, {itLB->second,itLB->first}));\n                itLB++;\n            }\n            pp.insert({current.I,current.R});\n        }\n\n        output(d);\n\n```\nWe use lower bound which gives the first point greater than the given point, upper bound which gives the last point lesser than the given point, dist() which gives the ED squared,  and j which is a simple optimization to only consider unprocessed (x axis removal) points on the x axis, so if for points 1,2,3 it did not trigger, but for point 4 it triggers then it must go from point 1 to 3, on the other hand if it triggered for point 1 and 2 then for point 4 it only needs to process point 3 as point 1 and 2 are already removed.  \n\n\n\n*",536875226]],["^15",[110,"^O","^16",536872867]],["^15",[110,"^@",false,536872867]],["^15",[110,"^F",101,536872867]],["^15",[110,"^X",95,536872867]],["^15",[110,"^V",95,536872867]],["^15",[110,"^U",95,536875227]],["^15",[110,"^U",103,536875227]],["^15",[110,"^U",111,536875227]],["^15",[110,"^U",234,536875227]],["^15",[110,"^?",["^ "],536875226]],["^15",[110,"^H",103,536875226]],["^15",[110,"^H",111,536875226]],["^15",[110,"^H",234,536875226]],["^15",[110,"^17",true,536872867]],["^15",[110,"^;","~u6484277f-5e42-438c-8cd9-f5dde86db252",536872867]],["^15",[111,"^K",1686382527907,536872467]],["^15",[111,"^[",355,536879599]],["^15",[111,"^O","^16",536879593]],["^15",[111,"^@",false,536872467]],["^15",[111,"^Y","algorithm",536872467]],["^15",[111,"^11","Algorithm",536872467]],["^15",[111,"^B",1702917271179,536879950]],["^15",[111,"^;","~u648427bf-655e-4ebb-8046-1d5d5332520f",536872467]],["^15",[113,"^K",1686382630987,536872538]],["^15",[113,"^@",false,536872538]],["^15",[113,"^Y","set",536872538]],["^15",[113,"^11","Set",536872538]],["^15",[113,"^B",1686382630987,536872538]],["^15",[113,"^;","~u64842826-9015-4960-91a2-fc327f9f603a",536872538]],["^15",[114,"^K",1686382731919,536872572]],["^15",[114,"^[",116,536872581]],["^15",[114,"^O","^16",536872576]],["^15",[114,"^@",false,536872572]],["^15",[114,"^Y","cph",536872572]],["^15",[114,"^11","CPH",536872572]],["^15",[114,"^B",1686382797843,536872612]],["^15",[114,"^;","~u6484288b-5da6-4ff0-aa40-a73b94c56c02",536872572]],["^15",[115,"^Q","Competitive Programmer's Handbook\nGuide to Competitive Programming by Antti Laaksonen \n2nd Edition",536872612]],["^15",[115,"^O","^16",536872577]],["^15",[115,"^@",false,536872577]],["^15",[115,"^F",114,536872577]],["^15",[115,"^X",114,536872577]],["^15",[115,"^V",114,536872577]],["^15",[115,"^U",114,536872578]],["^15",[115,"^?",["^ "],536872612]],["^15",[115,"^17",true,536872577]],["^15",[115,"^;","~u6484288d-1633-45f8-9763-09d6eed4dfae",536872577]],["^15",[116,"^3","- Competitive Programmer's Handbook\n  Guide to Competitive Programming by Antti Laaksonen \n  2nd Edition\n-",536872614]],["^15",[116,"^19","~m1686382798699",536872613]],["^15",[116,"^Z","pages/CPH.md",536872581]],["^15",[117,"^Q","",536872599]],["^15",[117,"^O","^16",536872599]],["^15",[117,"^@",false,536872599]],["^15",[117,"^F",115,536872599]],["^15",[117,"^X",114,536872599]],["^15",[117,"^V",114,536872599]],["^15",[117,"^U",114,536872600]],["^15",[117,"^?",["^ "],536872599]],["^15",[117,"^17",true,536872599]],["^15",[117,"^;","~u648428aa-c4fa-4409-86c5-2c8c739d5a0a",536872599]],["^15",[118,"^Q","",536872673]],["^15",[118,"^O","^16",536872673]],["^15",[118,"^@",false,536872673]],["^15",[118,"^F",105,536872673]],["^15",[118,"^X",95,536872673]],["^15",[118,"^V",95,536872673]],["^15",[118,"^U",95,536872674]],["^15",[118,"^?",["^ "],536872673]],["^15",[118,"^17",true,536872673]],["^15",[118,"^;","~u64842931-6a12-4a62-92d0-9aec750133a8",536872673]],["^15",[121,"^Q","Alternate Algorithm: If we simply go through the points and only consider the last point to compare distance with, then we may miss out on cases where point 1 and 3 are closer than point 1 and 2 and point 2 and 3. Like shown here\n![image.png](../assets/image_1686380077516_0.png){:height 222, :width 225}\n\nAn alternate algorithm that works is by simply going to each point and checking the distance against all other points. TC is $$\\text{O}\\lparen n^2 \\rparen$$\n\nAnother alternate alg is using [[Divide And Conquer]] but it is trickier to implement.",536873242]],["^15",[121,"^O","^16",536873242]],["^15",[121,"^@",false,536873242]],["^15",[121,"^F",110,536873242]],["^15",[121,"^X",95,536873242]],["^15",[121,"^V",95,536873242]],["^15",[121,"^U",95,536873243]],["^15",[121,"^U",122,536873243]],["^15",[121,"^?",["^ "],536873242]],["^15",[121,"^H",122,536873242]],["^15",[121,"^17",true,536873242]],["^15",[121,"^;","~u64843c1d-a534-4b47-968a-77f93033ce61",536873242]],["^15",[122,"^O","^16",536879588]],["^15",[122,"^@",false,536873242]],["^15",[122,"^Y","divide and conquer",536873242]],["^15",[122,"^11","Divide And Conquer",536873242]],["^15",[122,"^;","~u64843bfd-698e-44a9-a645-39f67f5ee978",536873242]],["^15",[123,"^12",2,536874115]],["^15",[124,"^12",2,536874117]],["^15",[125,"^K",1688143512790,536874118]],["^15",[125,"^O","^16",536874118]],["^15",[125,"^N",20230630,536874118]],["^15",[125,"^@",true,536874118]],["^15",[125,"^Y","30-06-2023",536874118]],["^15",[125,"^11","30-06-2023",536874118]],["^15",[125,"^B",1688143512790,536874118]],["^15",[125,"^;","~u649f0698-a332-4772-927c-d7ec850d96a9",536874118]],["^15",[126,"^Q","",536874119]],["^15",[126,"^O","^16",536874119]],["^15",[126,"^N",20230630,536874119]],["^15",[126,"^@",true,536874119]],["^15",[126,"^F",125,536874119]],["^15",[126,"^X",125,536874119]],["^15",[126,"^V",125,536874119]],["^15",[126,"^U",125,536874120]],["^15",[126,"^?",["^ "],536874119]],["^15",[126,"^17",true,536874119]],["^15",[126,"^;","~u649f0698-4b00-42a3-ae64-b12a23e90898",536874119]],["^15",[127,"^Q","",536874123]],["^15",[127,"^O","^16",536874123]],["^15",[127,"^@",false,536874123]],["^15",[127,"^F",28,536874123]],["^15",[127,"^X",28,536874123]],["^15",[127,"^V",28,536874123]],["^15",[127,"^U",28,536874124]],["^15",[127,"^?",["^ "],536874123]],["^15",[127,"^17",true,536874123]],["^15",[127,"^;","~u649f06b5-f647-45c9-99de-a23709d8009d",536874123]],["^15",[128,"^T","~:recent/search",536874126]],["^15",[128,"^1=",["^14",["CSES_1608","Equation"]],536879873]],["^15",[129,"^K",1688143711491,536874127]],["^15",[129,"^[",136,536874133]],["^15",[129,"^O","^16",536874127]],["^15",[129,"^@",false,536874127]],["^15",[129,"^Y","equation",536874127]],["^15",[129,"^11","Equation",536874127]],["^15",[129,"^B",1688145171082,536875032]],["^15",[129,"^;","~u649f075f-25af-46dc-b709-ce2d64e627b9",536874127]],["^15",[130,"^Q","It’s a mathematical statement that defines the relation between 2 algebraic\nexpressions. The relation can be <,>, = or their mix. We may also have\nthe inequality relation such as ax != bx, however then it may not necessarily\nbe true that f(ax) != f(bx), such as\n$$-1 \\ne 1$$\nis true\nbut\n$$(-1)^2 \\ne (1)^2 \\\\\\\n1 \\ne 1 $$\nis false.",536874258]],["^15",[130,"^O","^16",536874128]],["^15",[130,"^@",false,536874128]],["^15",[130,"^F",129,536874128]],["^15",[130,"^X",129,536874128]],["^15",[130,"^V",129,536874128]],["^15",[130,"^U",129,536874129]],["^15",[130,"^?",["^ "],536874258]],["^15",[130,"^17",true,536874128]],["^15",[130,"^;","~u649f075f-f01a-4e93-9218-66669073eb69",536874128]],["^15",[131,"^U",129,536874132]],["^15",[132,"^U",129,536874132]],["^15",[133,"^U",129,536874132]],["^15",[134,"^U",129,536874132]],["^15",[135,"^U",129,536874132]],["^15",[136,"^3","- It’s a mathematical statement that defines the relation between 2 algebraic\n  expressions. The relation can be <,>, = or their mix. We may also have\n  the inequality relation such as ax != bx, however then it may not necessarily\n  be true that f(ax) != f(bx), such as\n  $$-1 \\ne 1$$\n  is true\n  but\n  $$(-1)^2 \\ne (1)^2 \\\\\\\n  1 \\ne 1 $$\n  is false.\n- The equations theirselves are of diff. types such as [[Linear Equation]], [[Quadratic Equation]],\n  [[Cubic Equation]] etc.\n- Form of an eq.\n  ![image.png](../assets/image_1688144012925_0.png)\n- Degree of an equation \n  It is the highest exponent amongst all terms. For 2x+9 it is 1 as 1\n  is the highest power for a term. Same for $$2x+9^2$$, because $$9^2$$\n  can be directly solved giving us 81.\n  but\n  $$2x^2 +3y+2$$ when simplified remains the same, so here degree is 2 because the highest exponent is 2.\n- All equations can be represented in a [[Virtual Plane]], generally the [[Cartesian Plane]] is used but eqns with [[Complex Number]] or [[Vector]] use the [[Complex Plane]]. \n  \n  [[Function]]s for any point are defined by equations so\n  f(x) = 0\n  here the equation can be ``x*0=0``\n  and as we can see the function is defined by the equation ``x*0``. Now f can be easily\n  described by a single axis plane. We simply plot all the results of f(x).\n  \n  * Another eqn is\n    $$y = f(x)$$\n     where f can be ``2x+9``\n     Now here we have 2 [[Variable]]s, each variable represents the magnitude in its axis for a point which is why we use x and y as variables. But we can use other variables too, its just simpler\n  to get x and y directly and plot them. Here we have 2 variables so we get a 2 axes plane and for each value of x we get f(x) which is its y.\n  \n  * $$F=ma$$\n  force = mass\\*acceleration\n  Here we can use \n  y= x\\*z\n  And we can see there are 3 variables so it will require a 3-dimensional plane.\n- Zero of a [[Function]]\n  If $$f(c) = 0$$\n  then the [[Number]] ``c`` is called the zero of f.\n- Constant [[Function]]\n  If $$f(c)=b $$ \n  where c and b are constant [[Number]]s then the function is called\n  a constant function and its graph is a horizontal line with y-intercept with\n  (0,b).\n- Real solution\n  A solution to an equation is the ordered pair of points at which the\n  equations satisfies the relation.\n  More formally,\n  A solution is the [[Set]] of all possible values of a [[Variable]] which satisfy the equation. The solution\n  is a real solution if the set only accepts [[Real Number]]s.\n  For ex.:\n  $$2x+9=0$$\n  so for ``x=-4.5``\n  $$-9+9=0 \\\\\\ 0=0$$\n  so``-4.5``  is a solution to the equation 2x+9=0. Since it is a real number, it is a real solution.\n-",536875034]],["^15",[136,"^19","~m1688145172028",536875033]],["^15",[136,"^Z","pages/Equation.md",536874133]],["^15",[142,"^Q","The equations theirselves are of diff. types such as [[Linear Equation]], [[Quadratic Equation]],\n[[Cubic Equation]] etc.",536874264]],["^15",[142,"^O","^16",536874233]],["^15",[142,"^@",false,536874233]],["^15",[142,"^F",130,536874233]],["^15",[142,"^X",129,536874233]],["^15",[142,"^V",129,536874233]],["^15",[142,"^U",129,536874265]],["^15",[142,"^U",143,536874265]],["^15",[142,"^U",144,536874265]],["^15",[142,"^U",145,536874265]],["^15",[142,"^?",["^ "],536874264]],["^15",[142,"^H",143,536874264]],["^15",[142,"^H",144,536874264]],["^15",[142,"^H",145,536874264]],["^15",[142,"^17",true,536874233]],["^15",[142,"^;","~u649f07e5-dcf0-4101-adf6-3c7b39770fd1",536874233]],["^15",[143,"^K",1688143996552,536874264]],["^15",[143,"^@",false,536874264]],["^15",[143,"^Y","cubic equation",536874264]],["^15",[143,"^11","Cubic Equation",536874264]],["^15",[143,"^B",1688143996552,536874264]],["^15",[143,"^;","~u649f087c-f956-41cc-aec6-bb8583502146",536874264]],["^15",[144,"^K",1688143996554,536874264]],["^15",[144,"^@",false,536874264]],["^15",[144,"^Y","quadratic equation",536874264]],["^15",[144,"^11","Quadratic Equation",536874264]],["^15",[144,"^B",1688143996554,536874264]],["^15",[144,"^;","~u649f087c-993e-4e67-b2c5-204a52c08da7",536874264]],["^15",[145,"^K",1688143996555,536874264]],["^15",[145,"^[",226,536875040]],["^15",[145,"^O","^16",536875035]],["^15",[145,"^@",false,536874264]],["^15",[145,"^Y","linear equation",536874264]],["^15",[145,"^11","Linear Equation",536874264]],["^15",[145,"^B",1688145588918,536875221]],["^15",[145,"^;","~u649f087c-2610-4cbb-ab77-41b641e7161a",536874264]],["^15",[146,"^Q","Form of an eq.\n![image.png](../assets/image_1688144012925_0.png)",536874275]],["^15",[146,"^O","^16",536874268]],["^15",[146,"^@",false,536874268]],["^15",[146,"^F",142,536874268]],["^15",[146,"^X",129,536874268]],["^15",[146,"^V",129,536874268]],["^15",[146,"^U",129,536874269]],["^15",[146,"^?",["^ "],536874275]],["^15",[146,"^17",true,536874268]],["^15",[146,"^;","~u649f087e-f556-4312-8071-331b571c7416",536874268]],["^15",[147,"^Q","Degree of an equation \nIt is the highest exponent amongst all terms. For 2x+9 it is 1 as 1\nis the highest power for a term. Same for $$2x+9^2$$, because $$9^2$$\ncan be directly solved giving us 81.\nbut\n$$2x^2 +3y+2$$ when simplified remains the same, so here degree is 2 because the highest exponent is 2.",536874394]],["^15",[147,"^O","^16",536874275]],["^15",[147,"^@",false,536874275]],["^15",[147,"^F",146,536874275]],["^15",[147,"^X",129,536874275]],["^15",[147,"^V",129,536874275]],["^15",[147,"^U",129,536874276]],["^15",[147,"^?",["^ "],536874394]],["^15",[147,"^17",true,536874275]],["^15",[147,"^;","~u649f088d-0357-4d63-b2df-9a31358ef972",536874275]],["^15",[151,"^Q","All equations can be represented in a [[Virtual Plane]], generally the [[Cartesian Plane]] is used but eqns with [[Complex Number]] or [[Vector]] use the [[Complex Plane]]. \n\n[[Function]]s for any point are defined by equations so\nf(x) = 0\nhere the equation can be ``x*0=0``\nand as we can see the function is defined by the equation ``x*0``. Now f can be easily\ndescribed by a single axis plane. We simply plot all the results of f(x).\n\n* Another eqn is\n  $$y = f(x)$$\n   where f can be ``2x+9``\n   Now here we have 2 [[Variable]]s, each variable represents the magnitude in its axis for a point which is why we use x and y as variables. But we can use other variables too, its just simpler\nto get x and y directly and plot them. Here we have 2 variables so we get a 2 axes plane and for each value of x we get f(x) which is its y.\n\n* $$F=ma$$\nforce = mass\\*acceleration\nHere we can use \ny= x\\*z\nAnd we can see there are 3 variables so it will require a 3-dimensional plane.",536874893]],["^15",[151,"^O","^16",536874397]],["^15",[151,"^@",false,536874397]],["^15",[151,"^F",147,536874397]],["^15",[151,"^X",129,536874397]],["^15",[151,"^V",129,536874397]],["^15",[151,"^U",28,536874890]],["^15",[151,"^U",100,536874890]],["^15",[151,"^U",129,536874890]],["^15",[151,"^U",203,536874890]],["^15",[151,"^U",204,536874890]],["^15",[151,"^U",205,536874890]],["^15",[151,"^U",206,536874890]],["^15",[151,"^U",221,536874890]],["^15",[151,"^?",["^ "],536874893]],["^15",[151,"^H",28,536874893]],["^15",[151,"^H",100,536874893]],["^15",[151,"^H",203,536874893]],["^15",[151,"^H",204,536874893]],["^15",[151,"^H",205,536874893]],["^15",[151,"^H",206,536874893]],["^15",[151,"^H",221,536874893]],["^15",[151,"^17",true,536874397]],["^15",[151,"^;","~u649f0919-55c5-4c7c-b956-315405de4688",536874397]],["^15",[152,"^U",129,536874402]],["^15",[153,"^U",129,536874402]],["^15",[154,"^U",129,536874402]],["^15",[155,"^U",129,536874402]],["^15",[156,"^U",129,536874402]],["^15",[157,"^U",129,536874402]],["^15",[158,"^U",129,536874402]],["^15",[159,"^U",129,536874402]],["^15",[160,"^U",129,536874402]],["^15",[161,"^U",129,536874402]],["^15",[162,"^U",129,536874402]],["^15",[163,"^U",129,536874402]],["^15",[164,"^U",129,536874402]],["^15",[165,"^U",129,536874402]],["^15",[166,"^U",129,536874402]],["^15",[167,"^U",129,536874402]],["^15",[168,"^U",129,536874402]],["^15",[169,"^U",129,536874410]],["^15",[170,"^U",129,536874410]],["^15",[171,"^U",129,536874410]],["^15",[172,"^U",129,536874410]],["^15",[173,"^U",129,536874410]],["^15",[174,"^U",129,536874410]],["^15",[175,"^U",129,536874410]],["^15",[176,"^U",129,536874410]],["^15",[177,"^U",129,536874410]],["^15",[178,"^U",129,536874410]],["^15",[179,"^U",129,536874410]],["^15",[180,"^U",129,536874410]],["^15",[181,"^U",129,536874410]],["^15",[182,"^U",129,536874410]],["^15",[183,"^U",129,536874410]],["^15",[184,"^U",129,536874410]],["^15",[185,"^U",129,536874410]],["^15",[203,"^K",1688144525007,536874498]],["^15",[203,"^@",false,536874498]],["^15",[203,"^Y","virtual plane",536874498]],["^15",[203,"^11","Virtual Plane",536874498]],["^15",[203,"^B",1688144525007,536874498]],["^15",[203,"^;","~u649f0a8d-eec9-45e7-9802-a58a265cb6f4",536874498]],["^15",[204,"^K",1688144568617,536874519]],["^15",[204,"^@",false,536874519]],["^15",[204,"^Y","complex plane",536874519]],["^15",[204,"^11","Complex Plane",536874519]],["^15",[204,"^B",1688144568617,536874519]],["^15",[204,"^;","~u649f0ab8-46e2-4bca-9cae-1e2dd15c9a97",536874519]],["^15",[205,"^K",1688144605844,536874547]],["^15",[205,"^@",false,536874547]],["^15",[205,"^Y","vector",536874547]],["^15",[205,"^11","Vector",536874547]],["^15",[205,"^B",1688144605844,536874547]],["^15",[205,"^;","~u649f0add-9454-4260-af76-95a598ac8015",536874547]],["^15",[206,"^K",1688144733860,536874662]],["^15",[206,"^@",false,536874662]],["^15",[206,"^Y","variable",536874662]],["^15",[206,"^11","Variable",536874662]],["^15",[206,"^B",1688144733860,536874662]],["^15",[206,"^;","~u649f0b5d-5064-417d-8c9b-78959302b709",536874662]],["^15",[207,"^Q","Zero of a [[Function]]\nIf $$f(c) = 0$$\nthen the [[Number]] ``c`` is called the zero of f.",536874885]],["^15",[207,"^O","^16",536874756]],["^15",[207,"^@",false,536874756]],["^15",[207,"^F",151,536874756]],["^15",[207,"^X",129,536874756]],["^15",[207,"^V",129,536874756]],["^15",[207,"^U",129,536874886]],["^15",[207,"^U",218,536874886]],["^15",[207,"^U",221,536874886]],["^15",[207,"^?",["^ "],536874885]],["^15",[207,"^H",218,536874885]],["^15",[207,"^H",221,536874885]],["^15",[207,"^17",true,536874756]],["^15",[207,"^;","~u649f0bd0-87e4-4adb-81b8-ac5115011642",536874756]],["^15",[209,"^Q","Real solution\nA solution to an equation is the ordered pair of points at which the\nequations satisfies the relation.\nMore formally,\nA solution is the [[Set]] of all possible values of a [[Variable]] which satisfy the equation. The solution\nis a real solution if the set only accepts [[Real Number]]s.\nFor ex.:\n$$2x+9=0$$\nso for ``x=-4.5``\n$$-9+9=0 \\\\\\ 0=0$$\nso``-4.5``  is a solution to the equation 2x+9=0. Since it is a real number, it is a real solution.",536875032]],["^15",[209,"^O","^16",536874781]],["^15",[209,"^F",219,536874860]],["^15",[209,"^X",129,536874781]],["^15",[209,"^V",129,536874781]],["^15",[209,"^U",113,536874944]],["^15",[209,"^U",129,536874944]],["^15",[209,"^U",206,536874944]],["^15",[209,"^U",223,536874947]],["^15",[209,"^?",["^ "],536875032]],["^15",[209,"^H",113,536875032]],["^15",[209,"^H",206,536875032]],["^15",[209,"^H",223,536875032]],["^15",[209,"^17",true,536874781]],["^15",[209,"^;","~u649f0c1d-0f1b-4b2d-91c4-66ec83bd44c3",536874781]],["^15",[218,"^K",1688144956527,536874812]],["^15",[218,"^O","^16",536874896]],["^15",[218,"^@",false,536874812]],["^15",[218,"^Y","number",536874812]],["^15",[218,"^11","Number",536874812]],["^15",[218,"^B",1688144956527,536874812]],["^15",[218,"^;","~u649f0c3c-a04f-4b83-9954-bf1630a76131",536874812]],["^15",[219,"^Q","Constant [[Function]]\nIf $$f(c)=b $$ \nwhere c and b are constant [[Number]]s then the function is called\na constant function and its graph is a horizontal line with y-intercept with\n(0,b).",536874907]],["^15",[219,"^O","^16",536874834]],["^15",[219,"^@",false,536874834]],["^15",[219,"^F",207,536874834]],["^15",[219,"^X",129,536874834]],["^15",[219,"^V",129,536874834]],["^15",[219,"^U",129,536874901]],["^15",[219,"^U",218,536874901]],["^15",[219,"^U",221,536874901]],["^15",[219,"^?",["^ "],536874907]],["^15",[219,"^H",218,536874907]],["^15",[219,"^H",221,536874907]],["^15",[219,"^17",true,536874834]],["^15",[219,"^;","~u649f0c47-366b-4a5c-b9b7-7472c7909256",536874834]],["^15",[221,"^K",1688145016093,536874885]],["^15",[221,"^@",false,536874885]],["^15",[221,"^Y","function",536874885]],["^15",[221,"^11","Function",536874885]],["^15",[221,"^B",1688145016093,536874885]],["^15",[221,"^;","~u649f0c78-f42a-4297-85c6-675d7413d4dd",536874885]],["^15",[222,"^Q","",536874897]],["^15",[222,"^O","^16",536874897]],["^15",[222,"^@",false,536874897]],["^15",[222,"^F",218,536874897]],["^15",[222,"^X",218,536874897]],["^15",[222,"^V",218,536874897]],["^15",[222,"^U",218,536874898]],["^15",[222,"^?",["^ "],536874897]],["^15",[222,"^17",true,536874897]],["^15",[222,"^;","~u649f0c80-9265-44d5-bf0b-7fd2bebd1efa",536874897]],["^15",[223,"^K",1688145099524,536874947]],["^15",[223,"^@",false,536874947]],["^15",[223,"^Y","real number",536874947]],["^15",[223,"^11","Real Number",536874947]],["^15",[223,"^B",1688145099524,536874947]],["^15",[223,"^;","~u649f0ccb-432f-4a6b-88c2-153fd2552c3e",536874947]],["^15",[224,"^Q","",536875028]],["^15",[224,"^O","^16",536875028]],["^15",[224,"^F",209,536875028]],["^15",[224,"^X",129,536875028]],["^15",[224,"^V",129,536875028]],["^15",[224,"^U",129,536875029]],["^15",[224,"^?",["^ "],536875028]],["^15",[224,"^17",true,536875028]],["^15",[224,"^;","~u649f0d06-d6a5-4dd5-a78d-b92ddc8d14e4",536875028]],["^15",[225,"^Q","Degree 1 [[Equation]]. \nCan be 1 [[Variable]] , like $$2x+9=0$$\nOr 2 variable such as $$2x+9y=0$$\nor 3 variable $$2x+9y+3z=0 $$ \nand so on.",536875112]],["^15",[225,"^O","^16",536875036]],["^15",[225,"^@",false,536875036]],["^15",[225,"^F",145,536875036]],["^15",[225,"^X",145,536875036]],["^15",[225,"^V",145,536875036]],["^15",[225,"^U",129,536875048]],["^15",[225,"^U",145,536875048]],["^15",[225,"^U",206,536875048]],["^15",[225,"^?",["^ "],536875112]],["^15",[225,"^H",129,536875112]],["^15",[225,"^H",206,536875112]],["^15",[225,"^17",true,536875036]],["^15",[225,"^;","~u649f0d3c-8aef-446a-8bee-bc7fd6b2eb8e",536875036]],["^15",[226,"^3","- Degree 1 [[Equation]]. \n  Can be 1 [[Variable]] , like $$2x+9=0$$\n  Or 2 variable such as $$2x+9y=0$$\n  or 3 variable $$2x+9y+3z=0 $$ \n  and so on.\n- General form\n  $$f(x) = ax+b$$\n  where a and b are [[Real Number]]s and ``a!=0``\n- Intercept\n  If the [[Line]] of [[Function]] f on the [[Virtual Plane]] intersects the *x-axis* at (a,0) then (a,0) is an *x-intercept*. For *y-intercept* it should intersect at (0,b) and similarly for other dimensions.\n-",536875224]],["^15",[226,"^19","~m1688145589247",536875223]],["^15",[226,"^Z","pages/Linear Equation.md",536875040]],["^15",[228,"^Q","General form\n$$f(x) = ax+b$$\nwhere a and b are [[Real Number]]s and ``a!=0``",536875154]],["^15",[228,"^O","^16",536875115]],["^15",[228,"^@",false,536875115]],["^15",[228,"^F",225,536875115]],["^15",[228,"^X",145,536875115]],["^15",[228,"^V",145,536875115]],["^15",[228,"^U",145,536875145]],["^15",[228,"^U",223,536875145]],["^15",[228,"^?",["^ "],536875154]],["^15",[228,"^H",223,536875154]],["^15",[228,"^17",true,536875115]],["^15",[228,"^;","~u649f0d8a-ebc8-4373-a257-1645fff39ca9",536875115]],["^15",[231,"^Q","Intercept\nIf the [[Line]] of [[Function]] f on the [[Virtual Plane]] intersects the *x-axis* at (a,0) then (a,0) is an *x-intercept*. For *y-intercept* it should intersect at (0,b) and similarly for other dimensions.",536875221]],["^15",[231,"^O","^16",536875157]],["^15",[231,"^@",false,536875157]],["^15",[231,"^F",228,536875157]],["^15",[231,"^X",145,536875157]],["^15",[231,"^V",145,536875157]],["^15",[231,"^U",145,536875222]],["^15",[231,"^U",203,536875222]],["^15",[231,"^U",221,536875222]],["^15",[231,"^U",232,536875222]],["^15",[231,"^?",["^ "],536875221]],["^15",[231,"^H",203,536875221]],["^15",[231,"^H",221,536875221]],["^15",[231,"^H",232,536875221]],["^15",[231,"^17",true,536875157]],["^15",[231,"^;","~u649f0dba-02f9-4861-acbc-8417c07b5111",536875157]],["^15",[232,"^K",1688145417133,536875170]],["^15",[232,"^@",false,536875170]],["^15",[232,"^Y","line",536875170]],["^15",[232,"^11","Line",536875170]],["^15",[232,"^B",1688145417133,536875170]],["^15",[232,"^;","~u649f0e09-c9b3-4e35-830d-3634204a6cee",536875170]],["^15",[233,"^Q","",536875217]],["^15",[233,"^O","^16",536875217]],["^15",[233,"^@",false,536875217]],["^15",[233,"^F",231,536875217]],["^15",[233,"^X",145,536875217]],["^15",[233,"^V",145,536875217]],["^15",[233,"^U",145,536875218]],["^15",[233,"^?",["^ "],536875217]],["^15",[233,"^17",true,536875217]],["^15",[233,"^;","~u649f0e51-981e-43b7-9da3-6884c24c311f",536875217]],["^15",[234,"^K",1688145780419,536875226]],["^15",[234,"^@",false,536875226]],["^15",[234,"^Y","c++ set",536875226]],["^15",[234,"^11","C++ Set",536875226]],["^15",[234,"^B",1688145780419,536875226]],["^15",[234,"^;","~u649f0f74-60f6-47eb-b0cf-1b290b44977e",536875226]],["^15",[235,"^12",2,536875232]],["^15",[236,"^K",1688210242683,536875233]],["^15",[236,"^O","^16",536875233]],["^15",[236,"^N",20230701,536875233]],["^15",[236,"^@",true,536875233]],["^15",[236,"^Y","01-07-2023",536875233]],["^15",[236,"^11","01-07-2023",536875233]],["^15",[236,"^B",1688210242683,536875233]],["^15",[236,"^;","~u64a00b42-fff4-4ef6-b1c6-725818ed1425",536875233]],["^15",[237,"^Q","",536875234]],["^15",[237,"^O","^16",536875234]],["^15",[237,"^N",20230701,536875234]],["^15",[237,"^@",true,536875234]],["^15",[237,"^F",236,536875234]],["^15",[237,"^X",236,536875234]],["^15",[237,"^V",236,536875234]],["^15",[237,"^U",236,536875235]],["^15",[237,"^?",["^ "],536875234]],["^15",[237,"^17",true,536875234]],["^15",[237,"^;","~u64a00b42-e0bf-415f-9b38-2d62e07d3490",536875234]],["^15",[238,"^12",2,536875237]],["^15",[239,"^12",2,536875239]],["^15",[240,"^K",1688260711419,536875240]],["^15",[240,"^O","^16",536875240]],["^15",[240,"^N",20230702,536875240]],["^15",[240,"^@",true,536875240]],["^15",[240,"^Y","02-07-2023",536875240]],["^15",[240,"^11","02-07-2023",536875240]],["^15",[240,"^B",1688260711419,536875240]],["^15",[240,"^;","~u64a0d067-b0e8-4ef2-8de4-a8d304d2888e",536875240]],["^15",[241,"^Q","",536875241]],["^15",[241,"^O","^16",536875241]],["^15",[241,"^N",20230702,536875241]],["^15",[241,"^@",true,536875241]],["^15",[241,"^F",240,536875241]],["^15",[241,"^X",240,536875241]],["^15",[241,"^V",240,536875241]],["^15",[241,"^U",240,536875242]],["^15",[241,"^?",["^ "],536875241]],["^15",[241,"^17",true,536875241]],["^15",[241,"^;","~u64a0d067-8571-4711-a2c7-f6b2dbe782f4",536875241]],["^15",[242,"^12",2,536875244]],["^15",[243,"^12",2,536875459]],["^15",[244,"^K",1688291520639,536875460]],["^15",[244,"^[",246,536875469]],["^15",[244,"^O","^16",536875464]],["^15",[244,"^@",false,536875460]],["^15",[244,"^Y","convex hull",536875460]],["^15",[244,"^11","Convex Hull",536875460]],["^15",[244,"^B",1688292705373,536876199]],["^15",[244,"^;","~u64a148c0-ac89-4d92-a79b-6b929808a8f6",536875460]],["^15",[245,"^Q","A convex hull is the smallest convex [[Polygon]] (a convex polygon is a polygon where the boundaries of the polygon don't go inside) that contains all the points of a given [[Set]] of a [[Virtual Plane]] and none extra point, so it uses the points of the set itself to define the polygon's vertices.\n\nFor ex.:\n![image.png](../assets/image_1688291618886_0.png)\nis a convex polygon which contains all the points in the set of all points here",536875908]],["^15",[245,"^O","^16",536875465]],["^15",[245,"^@",false,536875465]],["^15",[245,"^F",244,536875465]],["^15",[245,"^X",244,536875465]],["^15",[245,"^V",244,536875465]],["^15",[245,"^U",113,536875511]],["^15",[245,"^U",203,536875511]],["^15",[245,"^U",244,536875511]],["^15",[245,"^U",247,536875511]],["^15",[245,"^?",["^ "],536875908]],["^15",[245,"^H",113,536875908]],["^15",[245,"^H",203,536875908]],["^15",[245,"^H",247,536875908]],["^15",[245,"^17",true,536875465]],["^15",[245,"^;","~u64a148c1-d286-409a-8cfa-e11eb121f731",536875465]],["^15",[246,"^3","- A convex hull is the smallest convex [[Polygon]] (a convex polygon is a polygon where the boundaries of the polygon don't go inside) that contains all the points of a given [[Set]] of a [[Virtual Plane]] and none extra point, so it uses the points of the set itself to define the polygon's vertices.\n  \n  For ex.:\n  ![image.png](../assets/image_1688291618886_0.png)\n  is a convex polygon which contains all the points in the set of all points here\n- To compute the convex hull for a given set of points we can use Andrew's Algorithm which goes like so\n  \n  * First we sort all the points primarily on x-axis component and secondarily on y-axis component\n  * Next we are ready to construct 2 ``hulls``, the upper hull and the lower hull. A hull is simply an enclosure, so here we construct the upper half of the polygon and then the lower half of the polygon.\n  \n  So we get our starting point, which is the left-most point we insert it to both our hulls\n  * Now we can begin constructing the upper hull, to do so we simply go through the sorted points and make sure each subsequent point does not lie to the left of the previous 2 points, if it does, we remove the previous point and then check again. The idea is to have the upper hull as the outermost set of points.\n  For ex.:\n  ![image.png](../assets/image_1688292223497_0.png)\n  Here we can see that the 4th point causes the hull to turn left, so we remove the 3rd point and now our hull only turns right. \n  We follow this same logic and process all the points, and for each point check if the hull hasn't turned left, if it has we remove all points from the hull that cause it to go left. It is always the last point before the current point so we can do it in a simple loop.\n  \n  * Now we get our upper hull like so\n  ![image.png](../assets/image_1688292398658_0.png)\n  \n  * Then, we do the same for the lower hull with the only difference being that we check that the hull doesn't turn right. \n  This then generates a hull which has the same ending point and we make sure the starting point remains the same for both the hulls giving us our final convex polygon.\n  \n  In C++,\n  ```cpp\n  void setup() {\n  \n    INPUT(n);\n    points = vci(n, CI());\n    upperHull = vci();\n    lowerHull = vci();\n    for (int i{}, arg1{}, arg2{}; i < n; ++i) {\n  \n      INPUT(arg1, arg2);\n  \n      points[i] = CI({arg1, arg2});\n    }\n    sort(points.begin(), points.end(), comparator);\n  }\n  \n  // Andrew's Algorithm\n  void compute() {\n    std::function<bool(int)> check{\n        [](int res) { return res > 0; }}; // point is to the left\n  \n    upperHull.pb(points[0]);\n    lowerHull.pb(points[0]);\n  \n    int kUpper{solveHull(upperHull, check)};\n  \n    check = {[](int res) { return res < 0; }}; // point is to the right\n  \n    int kLower{solveHull(lowerHull, check)};\n  \n  }\n  \n  int solveHull(vci &results, std::function<bool(int)> &check) {\n    int k{1};\n  \n    for (int i{1}; i < n; ++i) {\n  \n      while (k >= 2 && check(dirn(results[k - 2], results[k - 1], points[i]))) {\n        results.pop_back();\n        --k;\n      }\n  \n      results.pb(points[i]);\n      ++k;\n    }\n  \n    return k;\n  }\n  bool comparator(CI &a, CI &b) { return (a.X == b.X) ? a.Y < b.Y : a.X < b.X; }\n  int dirn(CI &x, CI &y, CI &p) {\n    CI a{p - x};\n    CI b{p - y};\n    int res{cast((conj(a) * b).Y)};\n    return res;\n  }\n  ```\n  \n  Here ``solveHull`` is the main logic, which simply goes over the points and inserts them all. For each point we check if the hull hasn't turned in the wrong direction and if it does we remove the last point in the hull and check again until either there aren't enough points (excluding the starting point) or if the hull turns in the right direction at the last point for the current one.\n-",536876203]],["^15",[246,"^19","~m1688292706040",536876204]],["^15",[246,"^Z","pages/Convex Hull.md",536875469]],["^15",[247,"^K",1688291577136,536875481]],["^15",[247,"^@",false,536875481]],["^15",[247,"^Y","polygon",536875481]],["^15",[247,"^11","polygon",536875481]],["^15",[247,"^B",1688291577136,536875481]],["^15",[247,"^;","~u64a148f9-b8ca-4a1f-985e-9ce8b33026a4",536875481]],["^15",[248,"^Q","To compute the convex hull for a given set of points we can use Andrew's Algorithm which goes like so\n\n* First we sort all the points primarily on x-axis component and secondarily on y-axis component\n* Next we are ready to construct 2 ``hulls``, the upper hull and the lower hull. A hull is simply an enclosure, so here we construct the upper half of the polygon and then the lower half of the polygon.\n\nSo we get our starting point, which is the left-most point we insert it to both our hulls\n* Now we can begin constructing the upper hull, to do so we simply go through the sorted points and make sure each subsequent point does not lie to the left of the previous 2 points, if it does, we remove the previous point and then check again. The idea is to have the upper hull as the outermost set of points.\nFor ex.:\n![image.png](../assets/image_1688292223497_0.png)\nHere we can see that the 4th point causes the hull to turn left, so we remove the 3rd point and now our hull only turns right. \nWe follow this same logic and process all the points, and for each point check if the hull hasn't turned left, if it has we remove all points from the hull that cause it to go left. It is always the last point before the current point so we can do it in a simple loop.\n\n* Now we get our upper hull like so\n![image.png](../assets/image_1688292398658_0.png)\n\n* Then, we do the same for the lower hull with the only difference being that we check that the hull doesn't turn right. \nThis then generates a hull which has the same ending point and we make sure the starting point remains the same for both the hulls giving us our final convex polygon.\n\nIn C++,\n```cpp\nvoid setup() {\n\n  INPUT(n);\n  points = vci(n, CI());\n  upperHull = vci();\n  lowerHull = vci();\n  for (int i{}, arg1{}, arg2{}; i < n; ++i) {\n\n    INPUT(arg1, arg2);\n\n    points[i] = CI({arg1, arg2});\n  }\n  sort(points.begin(), points.end(), comparator);\n}\n\n// Andrew's Algorithm\nvoid compute() {\n  std::function<bool(int)> check{\n      [](int res) { return res > 0; }}; // point is to the left\n\n  upperHull.pb(points[0]);\n  lowerHull.pb(points[0]);\n\n  int kUpper{solveHull(upperHull, check)};\n\n  check = {[](int res) { return res < 0; }}; // point is to the right\n\n  int kLower{solveHull(lowerHull, check)};\n\n}\n\nint solveHull(vci &results, std::function<bool(int)> &check) {\n  int k{1};\n\n  for (int i{1}; i < n; ++i) {\n\n    while (k >= 2 && check(dirn(results[k - 2], results[k - 1], points[i]))) {\n      results.pop_back();\n      --k;\n    }\n\n    results.pb(points[i]);\n    ++k;\n  }\n\n  return k;\n}\nbool comparator(CI &a, CI &b) { return (a.X == b.X) ? a.Y < b.Y : a.X < b.X; }\nint dirn(CI &x, CI &y, CI &p) {\n  CI a{p - x};\n  CI b{p - y};\n  int res{cast((conj(a) * b).Y)};\n  return res;\n}\n```\n\nHere ``solveHull`` is the main logic, which simply goes over the points and inserts them all. For each point we check if the hull hasn't turned in the wrong direction and if it does we remove the last point in the hull and check again until either there aren't enough points (excluding the starting point) or if the hull turns in the right direction at the last point for the current one.",536876199]],["^15",[248,"^O","^16",536875589]],["^15",[248,"^@",false,536875589]],["^15",[248,"^F",245,536875589]],["^15",[248,"^X",244,536875589]],["^15",[248,"^V",244,536875589]],["^15",[248,"^U",244,536875590]],["^15",[248,"^?",["^ "],536876199]],["^15",[248,"^17",true,536875589]],["^15",[248,"^;","~u64a14979-9227-40cc-bf2e-225cff3ccb80",536875589]],["^15",[249,"^Q","",536876200]],["^15",[249,"^O","^16",536876200]],["^15",[249,"^@",false,536876200]],["^15",[249,"^F",248,536876200]],["^15",[249,"^X",244,536876200]],["^15",[249,"^V",244,536876200]],["^15",[249,"^U",244,536876201]],["^15",[249,"^?",["^ "],536876200]],["^15",[249,"^17",true,536876200]],["^15",[249,"^;","~u64a14d61-c329-4590-978c-4a37da5d4223",536876200]],["^15",[250,"^12",2,536876206]],["^15",[251,"^K",1688357352198,536876207]],["^15",[251,"^O","^16",536876207]],["^15",[251,"^N",20230703,536876207]],["^15",[251,"^@",true,536876207]],["^15",[251,"^Y","03-07-2023",536876207]],["^15",[251,"^11","03-07-2023",536876207]],["^15",[251,"^B",1688357352198,536876207]],["^15",[251,"^;","~u64a249e8-1806-4320-ab1c-2f3693cc2980",536876207]],["^15",[252,"^Q","",536876208]],["^15",[252,"^O","^16",536876208]],["^15",[252,"^N",20230703,536876208]],["^15",[252,"^@",true,536876208]],["^15",[252,"^F",251,536876208]],["^15",[252,"^X",251,536876208]],["^15",[252,"^V",251,536876208]],["^15",[252,"^U",251,536876209]],["^15",[252,"^?",["^ "],536876208]],["^15",[252,"^17",true,536876208]],["^15",[252,"^;","~u64a249e8-f9cf-4bdd-addd-8a7f0cdfbe6b",536876208]],["^15",[253,"^12",2,536876236]],["^15",[254,"^K",1691036722960,536876237]],["^15",[254,"^O","^16",536876237]],["^15",[254,"^N",20230803,536876237]],["^15",[254,"^@",true,536876237]],["^15",[254,"^Y","03-08-2023",536876237]],["^15",[254,"^11","03-08-2023",536876237]],["^15",[254,"^B",1691036722960,536876237]],["^15",[254,"^;","~u64cb2c32-63fc-4141-9ccb-7f6a9b2496af",536876237]],["^15",[255,"^Q","",536876238]],["^15",[255,"^O","^16",536876238]],["^15",[255,"^N",20230803,536876238]],["^15",[255,"^@",true,536876238]],["^15",[255,"^F",254,536876238]],["^15",[255,"^X",254,536876238]],["^15",[255,"^V",254,536876238]],["^15",[255,"^U",254,536876239]],["^15",[255,"^?",["^ "],536876238]],["^15",[255,"^;","~u64cb2c32-887b-4d4f-9a2b-0c1dbd491832",536876238]],["^15",[256,"^K",1691119923319,536876241]],["^15",[256,"^O","^16",536876241]],["^15",[256,"^N",20230804,536876241]],["^15",[256,"^@",true,536876241]],["^15",[256,"^Y","04-08-2023",536876241]],["^15",[256,"^11","04-08-2023",536876241]],["^15",[256,"^B",1691119923319,536876241]],["^15",[256,"^;","~u64cc7133-8bb9-4476-b886-e3488c05f2e4",536876241]],["^15",[257,"^Q","",536876242]],["^15",[257,"^O","^16",536876242]],["^15",[257,"^N",20230804,536876242]],["^15",[257,"^@",true,536876242]],["^15",[257,"^F",256,536876242]],["^15",[257,"^X",256,536876242]],["^15",[257,"^V",256,536876242]],["^15",[257,"^U",256,536876243]],["^15",[257,"^?",["^ "],536876242]],["^15",[257,"^;","~u64cc7133-3ea5-4412-bb81-a8811400900b",536876242]],["^15",[258,"^Q","To implement a trie\n\n* We can use a [[Linked List]] like [[Data Structure]] to store unique chains of letters separately and non-unique chains in existing chains.\n* We can also use a simple 2-Dimensional [[C++ Array]] to represent chains. \n\nImplementing the 2nd one here, the 1st can be easily understood from it as well.\n\n```cpp\nvoid setup() {\n  INPUT(k, A, c);\n  trie = vvi(cN, vi(A, 0));\n  eos = vb(cN, false);\n  counter = 0;\n  {\n    string arg{};\n    cin.ignore(intmax, '\\n');\n    for (int i{}; i < k; ++i) {\n      getline(cin, arg);\n      trie_insert(arg);\n    }\n  }\n}\n\n// Trie\nvoid compute() {\n  string arg{};\n  while (c-- > 0) {\n    getline(cin, arg);\n    output(search(arg));\n  }\n}\n\nvoid trie_insert(string_view s) {\n  int sz{cast(s.size())};\n  int next{};\n\n  for (int i{}; i < sz; ++i) {\n    int &elem{trie[next][cast(s[i] % A)]};\n    if (!elem)\n      elem = ++counter;\n\n    next = elem;\n  }\n  eos[next] = true;\n}\n\nbool search(string_view s) {\n  int sz{cast(s.size())};\n  int next{};\n  for (int i{}; i < sz; ++i) {\n    int &elem{trie[next][cast(s[i] % A)]};\n    if (!elem)\n      return false;\n\n    next = elem;\n  }\n  return eos[next];\n}\n```\nUsing [[Default C++ Template]]\n\nThe logic is quite simple.\nWe use 2 variables, ``eos`` and ``trie``. ``trie`` is a 2-D Array with size ``trie[N][A]`` where ``N`` is the total size of all input [[C++ String]]'s size and ``A`` is the alphabet size. In a string ``s`` we store each ``s[i]`` in ``trie[i]`` and then we use the ``s[i]%A`` position of the array ``trie[i]`` to store a value indicating where at which ``i`` in trie the next character of the string is, this value is named ``counter``. The reason we do this is because ``s[i]`` corresponds to ``trie[i]`` only when the same chain stored in ``trie[i]`` is followed. If it is not, we jump to the next ``trie[n]`` where no char has been stored. This is where the ``counter``'s value comes in handy. ``counter`` essentially keeps track of how many indices in ``trie`` have been used to allow a string to find the next empty index.\nThe ``eos`` variable helps in marking indices of ``trie`` where a string has come to an end. The guarantee here is that each unique string stored in the ``trie`` will have a unique end index, and it will be checked only when a search string expects an index to be an end index.\n\nFor ex.:\nFor these 4 input strings\n```\ncar\ncat\ncaid\nbard\n```\n\nAnd these 2 strings to be searched in the trie\n```\ncard\ncat\n```\n\nWe store inputs like so, in the order they are given above,\n![image.png](../assets/image_1691133074322_0.png)\nThe ``eos`` will be true for 2,5,9.\n\nAs can be seen from the code and from the image, if an index is already used, it indicates the letter is already stored, and each character stores the index of the next empty row, and except the diverging letter, all letters are stored on new rows. This guarantees, if an index is already used in a row, it means it's part of an existing chain, and if it is not then it is empty and hence our character is the diverging character which will show the next index where we can find the rest of the string. \n\nThis allows search to be trivial as well. \nSo when we search for ``card``, we get ``c``, ``a`` and even ``r`` but when we look at ``d``, it is empty in the ``trie``, hence ``card`` isn't stored in the ``trie``.\n\n[[TC]] is O(n) for storage and O(n) for retrieval as well, but with a fixed constant time overhead of the fixed size of ``trie`` and ``eos``.  For [[SC]], Space is constant O(1) here, but it can also be dependent on the input size, in which case the constant time overhead for TC will be lower as well.",536877816]],["^15",[258,"^O","^16",536876244]],["^15",[258,"^@",false,536876244]],["^15",[258,"^F",76,536876244]],["^15",[258,"^X",67,536876244]],["^15",[258,"^V",67,536876244]],["^15",[258,"^U",67,536877784]],["^15",[258,"^U",259,536877784]],["^15",[258,"^U",260,536877784]],["^15",[258,"^U",261,536877784]],["^15",[258,"^U",262,536877784]],["^15",[258,"^U",277,536877784]],["^15",[258,"^U",316,536877784]],["^15",[258,"^U",317,536877784]],["^15",[258,"^?",["^ "],536877816]],["^15",[258,"^H",259,536877816]],["^15",[258,"^H",260,536877816]],["^15",[258,"^H",261,536877816]],["^15",[258,"^H",262,536877816]],["^15",[258,"^H",277,536877816]],["^15",[258,"^H",316,536877816]],["^15",[258,"^H",317,536877816]],["^15",[258,"^;","~u64cc8e3f-a693-41fb-8919-7e5286ca117f",536876244]],["^15",[259,"^K",1691127385655,536876272]],["^15",[259,"^@",false,536876272]],["^15",[259,"^Y","linked list",536876272]],["^15",[259,"^11","Linked List",536876272]],["^15",[259,"^B",1691127385655,536876272]],["^15",[259,"^;","~u64cc8e59-ef1c-4202-8348-02b0008dbad6",536876272]],["^15",[260,"^K",1691127395564,536876282]],["^15",[260,"^@",false,536876282]],["^15",[260,"^Y","data structure",536876282]],["^15",[260,"^11","Data Structure",536876282]],["^15",[260,"^B",1691127395564,536876282]],["^15",[260,"^;","~u64cc8e63-8a44-43a9-8434-71a3912c4b90",536876282]],["^15",[261,"^K",1691127517391,536876355]],["^15",[261,"^@",false,536876355]],["^15",[261,"^Y","c++ array",536876355]],["^15",[261,"^11","C++ Array",536876355]],["^15",[261,"^B",1691127517391,536876355]],["^15",[261,"^;","~u64cc8edd-cefd-4715-8a11-32077710c7cc",536876355]],["^15",[262,"^K",1691127974352,536876401]],["^15",[262,"^[",264,536876410]],["^15",[262,"^O","^16",536876405]],["^15",[262,"^@",false,536876401]],["^15",[262,"^Y","default c++ template",536876401]],["^15",[262,"^11","Default C++ Template",536876401]],["^15",[262,"^B",1692429309007,536879805]],["^15",[262,"^;","~u64cc90a6-2771-4336-bcaf-4f7b513593b4",536876401]],["^15",[263,"^Q","The template that can be to understand the rest of the code snippet.\nNot kept updated, check the [[Git Repo]] for template named cpp files or latest commit to see latest changes.",536876468]],["^15",[263,"^O","^16",536876406]],["^15",[263,"^@",false,536876406]],["^15",[263,"^F",262,536876406]],["^15",[263,"^X",262,536876406]],["^15",[263,"^V",262,536876406]],["^15",[263,"^U",262,536876429]],["^15",[263,"^U",265,536876429]],["^15",[263,"^?",["^ "],536876468]],["^15",[263,"^H",265,536876468]],["^15",[263,"^;","~u64cc90a7-1217-4c80-8fd7-d83edee8372d",536876406]],["^15",[264,"^3","- The template that can be to understand the rest of the code snippet.\n  Not kept updated, check the [[Git Repo]] for template named cpp files or latest commit to see latest changes.\n- Basic Structure\n  \n  3 Files in each Project directory,\n  ``Input.txt``: Defines the input\n  ``Output.txt``: Receives the output from ``stdout``.\n  ``<problem name>.cpp``: Compile this with [[Default Compilation Flow]] to execute it.\n- Template for [[CSES]] and general problems\n  ```cpp\n  //<problem link>\n  \n  #define LOCAL\n  \n  #pragma region Headers\n  \n  #ifdef LOCAL\n  #include \"../../Helpers/Easybench/Easybench.h\"\n  #include <algorithm>\n  #include <array>\n  #include <complex>\n  #include <functional>\n  #include <iostream>\n  #include <map>\n  #include <memory>\n  #include <queue>\n  #include <set>\n  #include <stack>\n  #include <stdio.h>\n  #include <string_view>\n  #include <tuple>\n  #include <unordered_map>\n  #include <unordered_set>\n  #include <vector>\n  #else\n  #include <bits/stdc++.h>\n  #endif // LOCAL\n  #pragma endregion\n  \n  #pragma region Defines\n  #define int long long\n  #define double long double\n  #define LOG(x) static_cast<int>(std::floor(std::log2(x)))\n  #define IOS                                                                    \\\n    std::ios_base::sync_with_stdio(false);                                       \\\n    std::cin.tie(0);                                                             \\\n    std::cout.tie(0);\n  template <typename... T> void INPUT(T &...args) { ((std::cin >> args), ...); }\n  template <typename... T> void OUTPUT(T &...args) {\n    ((std::cout << args << \" \"), ...);\n    std::cout << \"\\n\";\n  }\n  #define ARR_INPUT(arr, x)                                                      \\\n    for (int i{0}; i < x; ++i) {                                                 \\\n      int y;                                                                     \\\n      std::cin >> y;                                                             \\\n      arr.push_back(y);                                                          \\\n    }\n  #define cast(i) static_cast<int>(i)\n  #define intmax std::numeric_limits<int>::max()\n  #define intmin std::numeric_limits<int>::min()\n  #define revit std::reverse_iterator\n  #define pb push_back\n  #define sk std::stack\n  #define X real()\n  #define Y imag()\n  #define tiii std::tuple<int, int, int>\n  #define mmi std::make_move_iterator\n  #pragma endregion\n  \n  #pragma region Constants\n  constexpr int mod10{10000007};\n  constexpr int cN{200005}; // const N\n  constexpr int INF{std::numeric_limits<int>::max()};\n  constexpr int mINF{std::numeric_limits<int>::min()};\n  #pragma endregion\n  \n  #pragma region Usings\n  using usi = std::unordered_set<int>;\n  using umi = std::unordered_map<int, int>;\n  using vi = std::vector<int>;\n  using si = std::set<int>;\n  using sd = std::set<double>;\n  using vvi = std::vector<vi>;\n  using pivi = std::pair<int, vi>; // first is node's value and second is node's\n                                   // adjacent elements\n  using pii = std::pair<int, int>;\n  using vpii = std::vector<pii>; // edge list\n  using vtiii = std::vector<tiii>;\n  using vvtiii = std::vector<vtiii>; // adjacency list with adjacent node id, edge\n                                     // weight and an extra value.\n  using vpivi = std::vector<pivi>;\n  using vvpii =\n      std::vector<vpii>; // adjacency list with edge weights, the pii has first as\n                         // node id and second as the edge weight\n  using mii = std::map<int, int>;\n  using vmii = std::vector<mii>;\n  using vb = std::vector<bool>; // vector<bool> is a special explicit definition\n                                // of vector and behaves more like a bitset than a\n                                // vector, also it is faster than array<bool>\n                                // https://stackoverflow.com/a/55762317/13036358\n  using vvb = std::vector<vb>;\n  using ri = revit<vi::iterator>;\n  using ski = sk<int>;\n  using CD = std::complex<double>;\n  using CI = std::complex<int>; // DEPRECATED\n  using pqd = std::priority_queue<double>;\n  using pqi = std::priority_queue<int>;\n  using pqpii = std::priority_queue<pii>;\n  using vcd = std::vector<CD>;\n  using vci = std::vector<CI>;\n  using pcd = std::pair<CD, CD>;\n  using pci = std::pair<CI, CI>;\n  using vpcd = std::vector<pcd>;\n  using vpci = std::vector<pci>;\n  using vs = std::vector<std::string_view>;\n  #pragma endregion\n  \n  namespace Algorithm {\n  using namespace std;\n  \n  #pragma region Variables\n  int testCases{1};\n  int k{};\n  int c{};\n  int A{};    // alphabet set/lexicon size\n  vvi trie{}; // we can use std::array too but the call-stack size is limited,\n              // rather use heap\n  int result{};\n  vb eos{}; // end-of-string\n  int counter{};\n  \n  #pragma endregion\n  \n  void start();\n  void output(bool);\n  void compute();\n  void setup();\n  void commonSetupAndCleanInit();\n  void trie_insert(string_view);\n  bool search(string_view);\n  \n  void start() {\n    IOS;\n  #ifdef LOCAL\n  #ifdef freopen_s // windows\n    FILE *inpStream;\n    FILE *outStream;\n  \n    freopen_s(&inpStream, \"input.txt\", \"r\", stdin);\n    freopen_s(&outStream, \"output.txt\", \"w\", stdout);\n  #else // linux\n    freopen64(\"input.txt\", \"r\", stdin);\n    freopen64(\"output.txt\", \"w\", stdout);\n  #endif\n  \n  #endif\n    //    INPUT(testCases);\n    while (testCases-- > 0) {\n      commonSetupAndCleanInit();\n      setup();\n      compute();\n    }\n  }\n  \n  void setup() {\n    INPUT(k, A, c);\n    trie = vvi(cN, vi(A, 0));\n    eos = vb(cN, false);\n    counter = 0;\n    {\n      string arg{};\n      cin.ignore(intmax, '\\n');\n      for (int i{}; i < k; ++i) {\n        getline(cin, arg);\n        trie_insert(arg);\n      }\n    }\n  }\n  \n  // Trie\n  void compute() {\n    string arg{};\n    while (c-- > 0) {\n      getline(cin, arg);\n      output(search(arg));\n    }\n  }\n  \n  void trie_insert(string_view s) {\n    int sz{cast(s.size())};\n    int next{};\n  \n    for (int i{}; i < sz; ++i) {\n      int &elem{trie[next][cast(s[i] % A)]};\n      if (!elem)\n        elem = ++counter;\n  \n      next = elem;\n    }\n    eos[next] = true;\n  }\n  \n  bool search(string_view s) {\n    int sz{cast(s.size())};\n    int next{};\n    for (int i{}; i < sz; ++i) {\n      int &elem{trie[next][cast(s[i] % A)]};\n      if (!elem)\n        return false;\n  \n      next = elem;\n    }\n    return eos[next];\n  }\n  \n  void output(bool result) {\n    cout << boolalpha;\n    cout << result << \"\\n\";\n  }\n  \n  void commonSetupAndCleanInit() {}\n  \n  } // namespace Algorithm\n  \n  signed main() {\n  #ifdef LOCAL\n    EasyBench eb{};\n  #endif\n  \n    Algorithm::start();\n  \n  #ifdef LOCAL\n    eb.showresult();\n  #endif\n    return 0;\n  }\n  \n  ```\n- Template for Leetcode\n  ```cpp\n  // https://leetcode.com/problems/two-sum/description/\n  \n  #define LOCAL\n  \n  #pragma region Headers\n  \n  #ifdef LOCAL\n  #include \"../Helpers/Easybench/Easybench.h\"\n  #include <algorithm>\n  #include <array>\n  #include <complex>\n  #include <iostream>\n  #include <map>\n  #include <memory>\n  #include <queue>\n  #include <set>\n  #include <stack>\n  #include <stdio.h>\n  #include <string_view>\n  #include <tuple>\n  #include <unordered_set>\n  #include <vector>\n  #else\n  #include <bits/stdc++.h>\n  #endif // LOCAL\n  #pragma endregion\n  \n  #pragma region Defines\n  //#define int long long\n  //#define double long double\n  #define LOG(x) static_cast<int>(std::floor(std::log2(x)))\n  #define IOS                                                                    \\\n    std::ios_base::sync_with_stdio(false);                                       \\\n    std::cin.tie(0);                                                             \\\n    std::cout.tie(0);\n  template <typename... T> void INPUT(T &...args) { ((std::cin >> args), ...); }\n  template <typename... T> void OUTPUT(T &...args) {\n    ((std::cout << args << \" \"), ...);\n    std::cout << \"\\n\";\n  }\n  #define ARR_INPUT(arr, x)                                                      \\\n    for (int i{0}; i < x; ++i) {                                                 \\\n      int y;                                                                     \\\n      std::cin >> y;                                                             \\\n      arr.push_back(y);                                                          \\\n    }\n  #define cast(i) static_cast<int>(i)\n  #define intmax std::numeric_limits<int>::max()\n  #define intmin std::numeric_limits<int>::min()\n  #define revit std::reverse_iterator\n  #define pb push_back\n  #define sk std::stack\n  #define R real()\n  #define I imag()\n  #define tiii std::tuple<int, int, int>\n  #define mmi std::make_move_iterator\n  #pragma endregion\n  \n  #pragma region Constants\n  constexpr int mod10{10000007};\n  constexpr int cN{200005}; // const N\n  constexpr int INF{std::numeric_limits<int>::max()};\n  constexpr int mINF{std::numeric_limits<int>::min()};\n  #pragma endregion\n  \n  #pragma region Usings\n  using usi = std::unordered_set<int>;\n  using umi = std::unordered_map<int, int>;\n  using vi = std::vector<int>;\n  using si = std::set<int>;\n  using sd = std::set<double>;\n  using vvi = std::vector<vi>;\n  using pivi = std::pair<int, vi>; // first is node's value and second is node's\n                                   // adjacent elements\n  using pii = std::pair<int, int>;\n  using vpii = std::vector<pii>; // edge list\n  using vtiii = std::vector<tiii>;\n  using vvtiii = std::vector<vtiii>; // adjacency list with adjacent node id, edge\n                                     // weight and an extra value.\n  using vpivi = std::vector<pivi>;\n  using vvpii =\n      std::vector<vpii>; // adjacency list with edge weights, the pii has first as\n                         // node id and second as the edge weight\n  using mii = std::map<int, int>;\n  using vmii = std::vector<mii>;\n  using vb = std::vector<bool>; // vector<bool> is a special explicit definition\n                                // of vector and behaves more like a bitset than a\n                                // vector, also it is faster than array<bool>\n                                // https://stackoverflow.com/a/55762317/13036358\n  using vvb = std::vector<vb>;\n  using ri = revit<vi::iterator>;\n  using ski = sk<int>;\n  using CD = std::complex<double>;\n  using CI = std::complex<int>; // DEPRECATED\n  using pqd = std::priority_queue<double>;\n  using pqi = std::priority_queue<int>;\n  using pqpii = std::priority_queue<pii>;\n  using vcd = std::vector<CD>;\n  using vci = std::vector<CI>;\n  using pcd = std::pair<CD, CD>;\n  using pci = std::pair<CI, CI>;\n  using vpcd = std::vector<pcd>;\n  using vpci = std::vector<pci>;\n  using vs = std::vector<std::string_view>;\n  #pragma endregion\n  \n  namespace Algorithm {\n  using namespace std;\n  \n  #pragma region Variables\n  vi result{};\n  vi nums{};\n  int target{};\n  int n{};\n  umi ht{}; // hash table\n  #pragma endregion\n  \n  void start();\n  void output();\n  void localSetup();\n  void commonSetupAndCleanInit(); // needs to be cleaned up and setup, cleanup\n                                  // here because it resets results so must be\n                                  // done before other logic\n  \n  void nonLocalSetup();\n  \n  void localSetup() {\n    IOS;\n  #ifdef freopen_s // windows\n    FILE *inpStream;\n    FILE *outStream;\n  \n    freopen_s(&inpStream, \"input.txt\", \"r\", stdin);\n    freopen_s(&outStream, \"output.txt\", \"w\", stdout);\n  #else // linux\n    freopen64(\"input.txt\", \"r\", stdin);\n    freopen64(\"output.txt\", \"w\", stdout);\n  #endif\n    INPUT(n);\n    INPUT(target);\n    ARR_INPUT(nums, n);\n  }\n  \n  void commonSetupAndCleanInit() {\n    ht = umi();\n    result = vi();\n  }\n  \n  void nonLocalSetup() { n = cast(nums.size()); }\n  \n  void start() {\n    for (int i{}, elem{}; i < (n * 2); ++i) {\n      elem = nums[i % n];\n  \n      umi::iterator it{ht.find(target - elem)};\n      if (it != ht.end()) {\n        result.pb(i);\n        result.pb(it->second);\n        return;\n      } else {\n        ht.insert({elem, i});\n      }\n    }\n  }\n  \n  void output() {\n  \n    for (int elem : result) {\n      std::cout << elem << \" \";\n    }\n  \n    std::cout << std::endl;\n  }\n  \n  void cleanup() {\n  \n    result.clear();\n    ht.clear();\n    n = 0;\n    nums.clear();\n    target = 0;\n  }\n  \n  } // namespace Algorithm\n  \n  #define START                                                                  \\\n    Algorithm::nums = nums;                                                      \\\n    Algorithm::target = target;                                                  \\\n    Algorithm::commonSetupAndCleanInit();                                        \\\n    Algorithm::nonLocalSetup();                                                  \\\n    Algorithm::start();                                                          \\\n    Algorithm::output();                                                         \\\n    return Algorithm::result;\n  \n  namespace {\n  using namespace std;\n  class Solution {\n  public:\n    /// Local Test Method\n    void entrypoint() {\n      Algorithm::localSetup();\n      Algorithm::commonSetupAndCleanInit();\n      Algorithm::start();\n      Algorithm::output();\n    }\n  \n    /// LC calls this method\n    vector<int> twoSum(vector<int> &nums, int target) { START; }\n  };\n  } // namespace\n  \n  #ifdef LOCAL\n  signed main() {\n  \n    EasyBench eb{};\n  \n    Solution().entrypoint();\n  \n    eb.showresult();\n  \n    return 0;\n  }\n  #endif\n  \n  ```",536879807]],["^15",[264,"^19","~m1692429309637",536879806]],["^15",[264,"^Z","pages/Default C++ Template.md",536876410]],["^15",[265,"^K",1691128023788,536876428]],["^15",[265,"^@",false,536876428]],["^15",[265,"^Y","git repo",536876428]],["^15",[265,"^11","Git Repo",536876428]],["^15",[265,"^B",1691128023788,536876428]],["^15",[265,"^;","~u64cc90d7-294c-439c-854e-8ae81f37191e",536876428]],["^15",[266,"^Q","Basic Structure\n\n3 Files in each Project directory,\n``Input.txt``: Defines the input\n``Output.txt``: Receives the output from ``stdout``.\n``<problem name>.cpp``: Compile this with [[Default Compilation Flow]] to execute it.",536876570]],["^15",[266,"^O","^16",536876471]],["^15",[266,"^@",false,536876471]],["^15",[266,"^F",263,536876471]],["^15",[266,"^X",262,536876471]],["^15",[266,"^V",262,536876471]],["^15",[266,"^U",262,536876567]],["^15",[266,"^U",268,536876567]],["^15",[266,"^?",["^ "],536876570]],["^15",[266,"^H",268,536876570]],["^15",[266,"^;","~u64cc90ff-560f-4204-93bf-4a225b18eed8",536876471]],["^15",[268,"^K",1691128182388,536876566]],["^15",[268,"^@",false,536876566]],["^15",[268,"^Y","default compilation flow",536876566]],["^15",[268,"^11","Default Compilation Flow",536876566]],["^15",[268,"^B",1691128182388,536876566]],["^15",[268,"^;","~u64cc9176-0ddb-40e4-bb7b-61df578d540f",536876566]],["^15",[269,"^Q","Template for [[CSES]] and general problems\n```cpp\n//<problem link>\n\n#define LOCAL\n\n#pragma region Headers\n\n#ifdef LOCAL\n#include \"../../Helpers/Easybench/Easybench.h\"\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdio.h>\n#include <string_view>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#else\n#include <bits/stdc++.h>\n#endif // LOCAL\n#pragma endregion\n\n#pragma region Defines\n#define int long long\n#define double long double\n#define LOG(x) static_cast<int>(std::floor(std::log2(x)))\n#define IOS                                                                    \\\n  std::ios_base::sync_with_stdio(false);                                       \\\n  std::cin.tie(0);                                                             \\\n  std::cout.tie(0);\ntemplate <typename... T> void INPUT(T &...args) { ((std::cin >> args), ...); }\ntemplate <typename... T> void OUTPUT(T &...args) {\n  ((std::cout << args << \" \"), ...);\n  std::cout << \"\\n\";\n}\n#define ARR_INPUT(arr, x)                                                      \\\n  for (int i{0}; i < x; ++i) {                                                 \\\n    int y;                                                                     \\\n    std::cin >> y;                                                             \\\n    arr.push_back(y);                                                          \\\n  }\n#define cast(i) static_cast<int>(i)\n#define intmax std::numeric_limits<int>::max()\n#define intmin std::numeric_limits<int>::min()\n#define revit std::reverse_iterator\n#define pb push_back\n#define sk std::stack\n#define X real()\n#define Y imag()\n#define tiii std::tuple<int, int, int>\n#define mmi std::make_move_iterator\n#pragma endregion\n\n#pragma region Constants\nconstexpr int mod10{10000007};\nconstexpr int cN{200005}; // const N\nconstexpr int INF{std::numeric_limits<int>::max()};\nconstexpr int mINF{std::numeric_limits<int>::min()};\n#pragma endregion\n\n#pragma region Usings\nusing usi = std::unordered_set<int>;\nusing umi = std::unordered_map<int, int>;\nusing vi = std::vector<int>;\nusing si = std::set<int>;\nusing sd = std::set<double>;\nusing vvi = std::vector<vi>;\nusing pivi = std::pair<int, vi>; // first is node's value and second is node's\n                                 // adjacent elements\nusing pii = std::pair<int, int>;\nusing vpii = std::vector<pii>; // edge list\nusing vtiii = std::vector<tiii>;\nusing vvtiii = std::vector<vtiii>; // adjacency list with adjacent node id, edge\n                                   // weight and an extra value.\nusing vpivi = std::vector<pivi>;\nusing vvpii =\n    std::vector<vpii>; // adjacency list with edge weights, the pii has first as\n                       // node id and second as the edge weight\nusing mii = std::map<int, int>;\nusing vmii = std::vector<mii>;\nusing vb = std::vector<bool>; // vector<bool> is a special explicit definition\n                              // of vector and behaves more like a bitset than a\n                              // vector, also it is faster than array<bool>\n                              // https://stackoverflow.com/a/55762317/13036358\nusing vvb = std::vector<vb>;\nusing ri = revit<vi::iterator>;\nusing ski = sk<int>;\nusing CD = std::complex<double>;\nusing CI = std::complex<int>; // DEPRECATED\nusing pqd = std::priority_queue<double>;\nusing pqi = std::priority_queue<int>;\nusing pqpii = std::priority_queue<pii>;\nusing vcd = std::vector<CD>;\nusing vci = std::vector<CI>;\nusing pcd = std::pair<CD, CD>;\nusing pci = std::pair<CI, CI>;\nusing vpcd = std::vector<pcd>;\nusing vpci = std::vector<pci>;\nusing vs = std::vector<std::string_view>;\n#pragma endregion\n\nnamespace Algorithm {\nusing namespace std;\n\n#pragma region Variables\nint testCases{1};\nint k{};\nint c{};\nint A{};    // alphabet set/lexicon size\nvvi trie{}; // we can use std::array too but the call-stack size is limited,\n            // rather use heap\nint result{};\nvb eos{}; // end-of-string\nint counter{};\n\n#pragma endregion\n\nvoid start();\nvoid output(bool);\nvoid compute();\nvoid setup();\nvoid commonSetupAndCleanInit();\nvoid trie_insert(string_view);\nbool search(string_view);\n\nvoid start() {\n  IOS;\n#ifdef LOCAL\n#ifdef freopen_s // windows\n  FILE *inpStream;\n  FILE *outStream;\n\n  freopen_s(&inpStream, \"input.txt\", \"r\", stdin);\n  freopen_s(&outStream, \"output.txt\", \"w\", stdout);\n#else // linux\n  freopen64(\"input.txt\", \"r\", stdin);\n  freopen64(\"output.txt\", \"w\", stdout);\n#endif\n\n#endif\n  //    INPUT(testCases);\n  while (testCases-- > 0) {\n    commonSetupAndCleanInit();\n    setup();\n    compute();\n  }\n}\n\nvoid setup() {\n  INPUT(k, A, c);\n  trie = vvi(cN, vi(A, 0));\n  eos = vb(cN, false);\n  counter = 0;\n  {\n    string arg{};\n    cin.ignore(intmax, '\\n');\n    for (int i{}; i < k; ++i) {\n      getline(cin, arg);\n      trie_insert(arg);\n    }\n  }\n}\n\n// Trie\nvoid compute() {\n  string arg{};\n  while (c-- > 0) {\n    getline(cin, arg);\n    output(search(arg));\n  }\n}\n\nvoid trie_insert(string_view s) {\n  int sz{cast(s.size())};\n  int next{};\n\n  for (int i{}; i < sz; ++i) {\n    int &elem{trie[next][cast(s[i] % A)]};\n    if (!elem)\n      elem = ++counter;\n\n    next = elem;\n  }\n  eos[next] = true;\n}\n\nbool search(string_view s) {\n  int sz{cast(s.size())};\n  int next{};\n  for (int i{}; i < sz; ++i) {\n    int &elem{trie[next][cast(s[i] % A)]};\n    if (!elem)\n      return false;\n\n    next = elem;\n  }\n  return eos[next];\n}\n\nvoid output(bool result) {\n  cout << boolalpha;\n  cout << result << \"\\n\";\n}\n\nvoid commonSetupAndCleanInit() {}\n\n} // namespace Algorithm\n\nsigned main() {\n#ifdef LOCAL\n  EasyBench eb{};\n#endif\n\n  Algorithm::start();\n\n#ifdef LOCAL\n  eb.showresult();\n#endif\n  return 0;\n}\n\n```",536879805]],["^15",[269,"^O","^16",536876573]],["^15",[269,"^@",false,536876573]],["^15",[269,"^F",266,536876573]],["^15",[269,"^X",262,536876573]],["^15",[269,"^V",262,536876573]],["^15",[269,"^U",262,536876602]],["^15",[269,"^U",270,536876602]],["^15",[269,"^?",["^ "],536879805]],["^15",[269,"^H",270,536879805]],["^15",[269,"^;","~u64cc917f-a5ed-4983-bfba-49eb1d00b459",536876573]],["^15",[270,"^K",1691128245990,536876601]],["^15",[270,"^[",357,536879607]],["^15",[270,"^O","^16",536879602]],["^15",[270,"^@",false,536876601]],["^15",[270,"^Y","cses",536876601]],["^15",[270,"^11","CSES",536876601]],["^15",[270,"^B",1698847129036,536879917]],["^15",[270,"^;","~u64cc91b5-69f9-4f85-b756-02807dd3f951",536876601]],["^15",[271,"^Q","Template for Leetcode\n```cpp\n// https://leetcode.com/problems/two-sum/description/\n\n#define LOCAL\n\n#pragma region Headers\n\n#ifdef LOCAL\n#include \"../Helpers/Easybench/Easybench.h\"\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdio.h>\n#include <string_view>\n#include <tuple>\n#include <unordered_set>\n#include <vector>\n#else\n#include <bits/stdc++.h>\n#endif // LOCAL\n#pragma endregion\n\n#pragma region Defines\n//#define int long long\n//#define double long double\n#define LOG(x) static_cast<int>(std::floor(std::log2(x)))\n#define IOS                                                                    \\\n  std::ios_base::sync_with_stdio(false);                                       \\\n  std::cin.tie(0);                                                             \\\n  std::cout.tie(0);\ntemplate <typename... T> void INPUT(T &...args) { ((std::cin >> args), ...); }\ntemplate <typename... T> void OUTPUT(T &...args) {\n  ((std::cout << args << \" \"), ...);\n  std::cout << \"\\n\";\n}\n#define ARR_INPUT(arr, x)                                                      \\\n  for (int i{0}; i < x; ++i) {                                                 \\\n    int y;                                                                     \\\n    std::cin >> y;                                                             \\\n    arr.push_back(y);                                                          \\\n  }\n#define cast(i) static_cast<int>(i)\n#define intmax std::numeric_limits<int>::max()\n#define intmin std::numeric_limits<int>::min()\n#define revit std::reverse_iterator\n#define pb push_back\n#define sk std::stack\n#define R real()\n#define I imag()\n#define tiii std::tuple<int, int, int>\n#define mmi std::make_move_iterator\n#pragma endregion\n\n#pragma region Constants\nconstexpr int mod10{10000007};\nconstexpr int cN{200005}; // const N\nconstexpr int INF{std::numeric_limits<int>::max()};\nconstexpr int mINF{std::numeric_limits<int>::min()};\n#pragma endregion\n\n#pragma region Usings\nusing usi = std::unordered_set<int>;\nusing umi = std::unordered_map<int, int>;\nusing vi = std::vector<int>;\nusing si = std::set<int>;\nusing sd = std::set<double>;\nusing vvi = std::vector<vi>;\nusing pivi = std::pair<int, vi>; // first is node's value and second is node's\n                                 // adjacent elements\nusing pii = std::pair<int, int>;\nusing vpii = std::vector<pii>; // edge list\nusing vtiii = std::vector<tiii>;\nusing vvtiii = std::vector<vtiii>; // adjacency list with adjacent node id, edge\n                                   // weight and an extra value.\nusing vpivi = std::vector<pivi>;\nusing vvpii =\n    std::vector<vpii>; // adjacency list with edge weights, the pii has first as\n                       // node id and second as the edge weight\nusing mii = std::map<int, int>;\nusing vmii = std::vector<mii>;\nusing vb = std::vector<bool>; // vector<bool> is a special explicit definition\n                              // of vector and behaves more like a bitset than a\n                              // vector, also it is faster than array<bool>\n                              // https://stackoverflow.com/a/55762317/13036358\nusing vvb = std::vector<vb>;\nusing ri = revit<vi::iterator>;\nusing ski = sk<int>;\nusing CD = std::complex<double>;\nusing CI = std::complex<int>; // DEPRECATED\nusing pqd = std::priority_queue<double>;\nusing pqi = std::priority_queue<int>;\nusing pqpii = std::priority_queue<pii>;\nusing vcd = std::vector<CD>;\nusing vci = std::vector<CI>;\nusing pcd = std::pair<CD, CD>;\nusing pci = std::pair<CI, CI>;\nusing vpcd = std::vector<pcd>;\nusing vpci = std::vector<pci>;\nusing vs = std::vector<std::string_view>;\n#pragma endregion\n\nnamespace Algorithm {\nusing namespace std;\n\n#pragma region Variables\nvi result{};\nvi nums{};\nint target{};\nint n{};\numi ht{}; // hash table\n#pragma endregion\n\nvoid start();\nvoid output();\nvoid localSetup();\nvoid commonSetupAndCleanInit(); // needs to be cleaned up and setup, cleanup\n                                // here because it resets results so must be\n                                // done before other logic\n\nvoid nonLocalSetup();\n\nvoid localSetup() {\n  IOS;\n#ifdef freopen_s // windows\n  FILE *inpStream;\n  FILE *outStream;\n\n  freopen_s(&inpStream, \"input.txt\", \"r\", stdin);\n  freopen_s(&outStream, \"output.txt\", \"w\", stdout);\n#else // linux\n  freopen64(\"input.txt\", \"r\", stdin);\n  freopen64(\"output.txt\", \"w\", stdout);\n#endif\n  INPUT(n);\n  INPUT(target);\n  ARR_INPUT(nums, n);\n}\n\nvoid commonSetupAndCleanInit() {\n  ht = umi();\n  result = vi();\n}\n\nvoid nonLocalSetup() { n = cast(nums.size()); }\n\nvoid start() {\n  for (int i{}, elem{}; i < (n * 2); ++i) {\n    elem = nums[i % n];\n\n    umi::iterator it{ht.find(target - elem)};\n    if (it != ht.end()) {\n      result.pb(i);\n      result.pb(it->second);\n      return;\n    } else {\n      ht.insert({elem, i});\n    }\n  }\n}\n\nvoid output() {\n\n  for (int elem : result) {\n    std::cout << elem << \" \";\n  }\n\n  std::cout << std::endl;\n}\n\nvoid cleanup() {\n\n  result.clear();\n  ht.clear();\n  n = 0;\n  nums.clear();\n  target = 0;\n}\n\n} // namespace Algorithm\n\n#define START                                                                  \\\n  Algorithm::nums = nums;                                                      \\\n  Algorithm::target = target;                                                  \\\n  Algorithm::commonSetupAndCleanInit();                                        \\\n  Algorithm::nonLocalSetup();                                                  \\\n  Algorithm::start();                                                          \\\n  Algorithm::output();                                                         \\\n  return Algorithm::result;\n\nnamespace {\nusing namespace std;\nclass Solution {\npublic:\n  /// Local Test Method\n  void entrypoint() {\n    Algorithm::localSetup();\n    Algorithm::commonSetupAndCleanInit();\n    Algorithm::start();\n    Algorithm::output();\n  }\n\n  /// LC calls this method\n  vector<int> twoSum(vector<int> &nums, int target) { START; }\n};\n} // namespace\n\n#ifdef LOCAL\nsigned main() {\n\n  EasyBench eb{};\n\n  Solution().entrypoint();\n\n  eb.showresult();\n\n  return 0;\n}\n#endif\n\n```",536876615]],["^15",[271,"^O","^16",536876605]],["^15",[271,"^@",false,536876605]],["^15",[271,"^F",269,536876605]],["^15",[271,"^X",262,536876605]],["^15",[271,"^V",262,536876605]],["^15",[271,"^U",262,536876606]],["^15",[271,"^?",["^ "],536876615]],["^15",[271,"^;","~u64cc91bc-3751-471c-a274-b9ee5bb7d93f",536876605]],["^15",[272,"^K",1691128446669,536876636]],["^15",[272,"^[",276,536876646]],["^15",[272,"^O","^16",536876640]],["^15",[272,"^@",false,536876636]],["^15",[272,"^Y","default code explanation format",536876636]],["^15",[272,"^11","Default Code Explanation Format",536876636]],["^15",[272,"^?",["^ "],536876709]],["^15",[272,"^B",1691128560657,536876709]],["^15",[272,"^;","~u64cc927e-7338-43a0-89b0-dff8224f3329",536876636]],["^15",[273,"^Q","",536876709]],["^15",[273,"^O","^16",536876641]],["^15",[273,"^@",false,536876641]],["^15",[273,"^F",272,536876641]],["^15",[273,"^X",272,536876641]],["^15",[273,"^V",272,536876641]],["^15",[273,"^U",272,536876710]],["^15",[273,"^?",["^ "],536876709]],["^15",[273,"^;","~u64cc927f-e941-4173-8b29-97de16797cfd",536876641]],["^15",[275,"^Q","",536876706]],["^15",[275,"^O","^16",536876644]],["^15",[275,"^@",false,536876644]],["^15",[275,"^F",273,536876644]],["^15",[275,"^X",272,536876644]],["^15",[275,"^V",272,536876644]],["^15",[275,"^U",272,536876645]],["^15",[275,"^?",["^ "],536876706]],["^15",[275,"^;","~u64cc9284-8d36-4200-8c1c-5bc41d0c9983",536876644]],["^15",[276,"^3","-\n-",536876712]],["^15",[276,"^19","~m1691128561220",536876711]],["^15",[276,"^Z","pages/Default Code Explanation Format.md",536876646]],["^15",[277,"^K",1691128643823,536876807]],["^15",[277,"^@",false,536876807]],["^15",[277,"^Y","c++ string",536876807]],["^15",[277,"^11","C++ String",536876807]],["^15",[277,"^B",1691128643823,536876807]],["^15",[277,"^;","~u64cc9343-9a3d-4b30-937e-ab190b7c0827",536876807]],["^15",[279,"^U",67,536877337]],["^15",[280,"^U",67,536877337]],["^15",[281,"^U",67,536877337]],["^15",[282,"^U",67,536877337]],["^15",[283,"^U",67,536877337]],["^15",[284,"^U",67,536877337]],["^15",[285,"^U",67,536877337]],["^15",[286,"^U",67,536877337]],["^15",[287,"^U",67,536877337]],["^15",[288,"^U",67,536877337]],["^15",[289,"^U",67,536877337]],["^15",[290,"^U",67,536877337]],["^15",[291,"^U",67,536877337]],["^15",[292,"^U",67,536877337]],["^15",[293,"^U",67,536877337]],["^15",[294,"^U",67,536877337]],["^15",[295,"^U",67,536877337]],["^15",[296,"^U",67,536877337]],["^15",[297,"^U",67,536877337]],["^15",[298,"^U",67,536877337]],["^15",[299,"^U",67,536877337]],["^15",[300,"^U",67,536877337]],["^15",[301,"^U",67,536877337]],["^15",[302,"^U",67,536877337]],["^15",[303,"^U",67,536877337]],["^15",[304,"^U",67,536877337]],["^15",[305,"^U",67,536877337]],["^15",[306,"^U",67,536877337]],["^15",[307,"^U",67,536877337]],["^15",[308,"^U",67,536877337]],["^15",[314,"^U",67,536877389]],["^15",[315,"^U",67,536877394]],["^15",[316,"^K",1691133485581,536877698]],["^15",[316,"^@",false,536877698]],["^15",[316,"^Y","tc",536877698]],["^15",[316,"^11","TC",536877698]],["^15",[316,"^B",1691133485581,536877698]],["^15",[316,"^;","~u64cca62d-2e3e-46cc-9a46-52b70064c2a1",536877698]],["^15",[317,"^K",1691133618324,536877783]],["^15",[317,"^@",false,536877783]],["^15",[317,"^Y","sc",536877783]],["^15",[317,"^11","SC",536877783]],["^15",[317,"^B",1691133618324,536877783]],["^15",[317,"^;","~u64cca6b2-c37b-45d4-9122-04a7804511e2",536877783]],["^15",[318,"^12",2,536877812]],["^15",[319,"^K",1691985811594,536877813]],["^15",[319,"^O","^16",536877813]],["^15",[319,"^N",20230814,536877813]],["^15",[319,"^@",true,536877813]],["^15",[319,"^Y","14-08-2023",536877813]],["^15",[319,"^11","14-08-2023",536877813]],["^15",[319,"^B",1691985811594,536877813]],["^15",[319,"^;","~u64d9a793-51f2-46e2-b493-327467a1b7cb",536877813]],["^15",[320,"^Q","",536877814]],["^15",[320,"^O","^16",536877814]],["^15",[320,"^N",20230814,536877814]],["^15",[320,"^@",true,536877814]],["^15",[320,"^F",319,536877814]],["^15",[320,"^X",319,536877814]],["^15",[320,"^V",319,536877814]],["^15",[320,"^U",319,536877815]],["^15",[320,"^?",["^ "],536877814]],["^15",[320,"^;","~u64d9a793-6464-4b18-98df-3c4f66bce77a",536877814]],["^15",[321,"^Q","[[Longest Common Subsequence]]",536877823]],["^15",[321,"^O","^16",536877819]],["^15",[321,"^F",53,536877819]],["^15",[321,"^X",24,536877819]],["^15",[321,"^V",24,536877819]],["^15",[321,"^U",24,536877824]],["^15",[321,"^U",322,536877824]],["^15",[321,"^?",["^ "],536877823]],["^15",[321,"^H",322,536877823]],["^15",[321,"^;","~u64d9a8e2-ae02-4391-8a72-9eb3c1390414",536877819]],["^15",[322,"^K",1691986159542,536877823]],["^15",[322,"^[",332,536877926]],["^15",[322,"^O","^16",536877921]],["^15",[322,"^@",false,536877823]],["^15",[322,"^Y","longest common subsequence",536877823]],["^15",[322,"^11","Longest Common Subsequence",536877823]],["^15",[322,"^B",1691991857502,536879575]],["^15",[322,"^;","~u64d9a8ef-6e81-4d08-9b85-e8ec65641494",536877823]],["^15",[323,"^K",1691986164736,536877827]],["^15",[323,"^[",326,536877853]],["^15",[323,"^O","^16",536877842]],["^15",[323,"^@",false,536877827]],["^15",[323,"^Y","subsequence",536877827]],["^15",[323,"^11","Subsequence",536877848]],["^15",[323,"^B",1691986304482,536877918]],["^15",[323,"^;","~u64d9a8f4-b37f-48c4-8c8b-1d8539c2fceb",536877827]],["^15",[324,"^K",1691986179649,536877837]],["^15",[324,"^[",328,536877877]],["^15",[324,"^O","^16",536877872]],["^15",[324,"^@",false,536877837]],["^15",[324,"^Y","substring",536877837]],["^15",[324,"^11","Substring",536877837]],["^15",[324,"^B",1691986245860,536877889]],["^15",[324,"^;","~u64d9a903-8aa1-4df6-8fd4-4337014e9702",536877837]],["^15",[325,"^Q","It's a [[String]]/[[Sequence]] formed from consecutive characters in a string (consecutive indices).\nEvery [[Substring]] is a subsequence, but the converse is false as a subsequence may not be formed from a continuous range of characters in the string but a substring must always cover a continuous index range. \nFor ex.:\n![image.png](../assets/image_1684390601372_0.png)",536877918]],["^15",[325,"^O","^16",536877843]],["^15",[325,"^@",false,536877843]],["^15",[325,"^F",323,536877843]],["^15",[325,"^X",323,536877843]],["^15",[325,"^V",323,536877843]],["^15",[325,"^U",24,536877906]],["^15",[325,"^U",323,536877906]],["^15",[325,"^U",324,536877909]],["^15",[325,"^U",329,536877906]],["^15",[325,"^?",["^ "],536877918]],["^15",[325,"^H",24,536877918]],["^15",[325,"^H",324,536877918]],["^15",[325,"^H",329,536877918]],["^15",[325,"^;","~u64d9a911-21a6-4c8f-a92e-43d89417ba88",536877843]],["^15",[326,"^3","- It's a [[String]]/[[Sequence]] formed from consecutive characters in a string (consecutive indices).\n  Every [[Substring]] is a subsequence, but the converse is false as a subsequence may not be formed from a continuous range of characters in the string but a substring must always cover a continuous index range. \n  For ex.:\n  ![image.png](../assets/image_1684390601372_0.png)",536877920]],["^15",[326,"^19","~m1691986304990",536877919]],["^15",[326,"^Z","pages/Subsequence.md",536877853]],["^15",[327,"^Q","A ``substring`` s[a...b] is a [[String]] formed from the characters from int index a to b in s. This covers a continuous index range in the string.",536877889]],["^15",[327,"^O","^16",536877873]],["^15",[327,"^@",false,536877873]],["^15",[327,"^F",324,536877873]],["^15",[327,"^X",324,536877873]],["^15",[327,"^V",324,536877873]],["^15",[327,"^U",24,536877890]],["^15",[327,"^U",324,536877890]],["^15",[327,"^?",["^ "],536877889]],["^15",[327,"^H",24,536877889]],["^15",[327,"^;","~u64d9a936-0e07-4f1b-b23d-7ad7d516dc5a",536877873]],["^15",[328,"^3","- A ``substring`` s[a...b] is a [[String]] formed from the characters from int index a to b in s. This covers a continuous index range in the string.",536877892]],["^15",[328,"^19","~m1691986246560",536877891]],["^15",[328,"^Z","pages/Substring.md",536877877]],["^15",[329,"^K",1691986281050,536877898]],["^15",[329,"^@",false,536877898]],["^15",[329,"^Y","sequence",536877898]],["^15",[329,"^11","Sequence",536877898]],["^15",[329,"^B",1691986281050,536877898]],["^15",[329,"^;","~u64d9a969-e3bf-4bf1-9832-fb193cdff5cb",536877898]],["^15",[331,"^Q","The ``LCS`` of any 2 [[String]]s is the longest [[Subsequence]] present in both strings.\nFor ex.:\nIn 2 strings, ``TOUR`` and ``OPERA``, the LCS is ``OR``.",536877992]],["^15",[331,"^O","^16",536877922]],["^15",[331,"^@",false,536877922]],["^15",[331,"^F",322,536877922]],["^15",[331,"^X",322,536877922]],["^15",[331,"^V",322,536877922]],["^15",[331,"^U",24,536877946]],["^15",[331,"^U",322,536877946]],["^15",[331,"^U",323,536877946]],["^15",[331,"^?",["^ "],536877992]],["^15",[331,"^H",24,536877992]],["^15",[331,"^H",323,536877992]],["^15",[331,"^;","~u64d9a996-b0c3-4165-bd93-a56b1c045ca5",536877922]],["^15",[332,"^3","- The ``LCS`` of any 2 [[String]]s is the longest [[Subsequence]] present in both strings.\n  For ex.:\n  In 2 strings, ``TOUR`` and ``OPERA``, the LCS is ``OR``.\n- 3 [[Algorithm]]s in decreasing order of growth are\n  * Normal Recursive Approach\n  * Memoized [[Recurse]]ive Approach\n  * [[Dynamic Programming]] + [[Iterative]] + [[Memoize]]d Approach\n- Normal [[Recurse]]ion\n  \n  In this approach we recursively ask if taking an element from a string or not taking it would yield a bigger common subsequence. We take an element if it matches with the currently tracked element of the other string, in this case the overall common subsequence size increases by 1.\n  \n  ![image.png](../assets/image_1691988397797_0.png) \n  As we can see, we start from the first character of both strings and compare them. If they are equal, they increase the LCS and we get LCS increased by 1.\n  Effectively, if 2 elements are equal, the problem then becomes finding the LCS of the remaining 2 strings and we can forget the elements that were equal.\n  ![image.png](../assets/image_1691988538490_0.png)\n  \n  But if the elements are not equal, then they can either contribute to the LCS, or not. \n  For example:\n  it is possible that an element from string 1 can be the same as an element at the end of string 2.\n  ![image.png](../assets/image_1691988714170_0.png)\n  Here, the ``C`` from string 1 is at the end of string 2. So it does contribute to the LCS.\n  \n  Hence we need to recursively find all possible combinations of subsequences of both strings and compare their culminated LCS'.\n  \n  In C++,\n  ```cpp\n  // Bottom up, (size1,size2), Normal Recursion based approach, TLE\n  int lcs(int i, int j) {\n    if (i < 0 || j < 0) {\n      return 0;\n    }\n  \n    if (s1[i] == s2[j]) {\n      return 1 + lcs(i - 1, j - 1);\n    } else {\n      return max(lcs(i, j - 1), lcs(i - 1, j));\n    }\n  }\n  \n  //called with lcs(s1.size()-1,s2.size()-1)\n  ```\n  \n  [[TC]] is $$\\text{0(}2^{n+m}\\text{)}$$\n  where ``n`` is size of string 1, and ``m`` is size of string 2.\n  [[SC]] is O(1) since our [[Algorithm]] takes no extra space.\n- [[Memoize]]d [[Recurse]]ive Approach\n  \n  In the normal approach, we can see that most of the branches are effectively repeating already traversed branches.\n  We can simply store the results and drop the [[TC]] at the cost of some [[SC]].\n  \n  In C++,\n  ```cpp\n  // Bottom up, Recursion+Memoized, (size1,size2), a bit slower growth in TC\n  int lcsMemoized(int i, int j) {\n    if (i < 0 || j < 0) {\n      return 0;\n    }\n  \n    if (memoTable[i][j] != -1) {\n      return memoTable[i][j];\n    }\n  \n    if (s1[i] == s2[j]) {\n      memoTable[i][j] = 1 + lcsMemoized(i - 1, j - 1);\n    } else {\n      memoTable[i][j] = max(lcsMemoized(i, j - 1), lcsMemoized(i - 1, j));\n    }\n    return memoTable[i][j];\n  }\n  //called with lcsmemoized(s1.size()-1,s2.size()-1)\n  ```\n  TC is same as normal approach in worst case, but in average and best case it is a lot better.\n  SC is $$O(n*m)$$\n- [[Dynamic Programming]] + [[Iterative]] + [[Memoize]]d Approach\n  \n  From the previous approaches, it can be observed that we depend on the solution to the previous subproblems (smaller strings to be compared). \n  So if we go from smaller strings to bigger strings, we can effectively forgo the recursion and linearly find the LCS from smaller strings to bigger ones.\n  To do so, we can visualize the 2 strings in a [[2D]] [[Matrix]].\n  \n  For ex.:\n  For ``TOUR`` and ``OPERA``\n  ![image.png](../assets/image_1691990912736_0.png) \n  \n  Now, we can find the LCS by going from top left to right bottom and looking at previous values and building upon them. \n  Each row's/column's character represents the max. subsequence size from empty string to that character.\n  For ex.:\n  If we take ``\"\"TO`` in row and ``\"\"OP`` in column, then the cell corresponding to them will hold the max. subsequence size, which is 1 in this case.\n  \n  Now, the [[Algorithm]] .\n  First we initialize all ``\"\"`` vs ``\"\"`` comparison values, these are always 0, because empty strings have no common subsequence with each other.\n  ![image.png](../assets/image_1691991058571_0.png)\n  \n  Now we compare subsequent cells for each row, for each cell, if the 2 current characters are inequal then we take max of the previous row same column, or previous column same row. In other words, we take the max of either the subsequence till the current string 1 character and the previous string 2 character, or the other way around.\n  \n  For ex.:\n  ![image.png](../assets/image_1691991382972_0.png)\n  Since ``T`` and ``O`` are inequal, we take max of ``\"\"`` and ``\"\"O`` vs. ``\"\"T`` and``\"\"`` .\n  This is exactly the same as the original algorithm, either we take the LCS size till current element of either string 1 or string 2, whichever is bigger.\n  \n  Now, if 2 characters that are equal, we do the same but add 1 to the max. This is because the current characters are increasing the LCS by 1.\n  \n  Finally, we get this matrix.\n  ![image.png](../assets/image_1691991789152_0.png)\n  \n  And the result is the last element.\n  \n  In C++,\n  ```cpp\n  // Top to Bottom, 1 indexed, DP + Iterative + Memoized, O(nm)\n  int lcsDP() {\n    for (int i{1}; i <= cast(s1.size()); ++i) {\n      for (int j{1}; j <= cast(s2.size()); ++j) {\n        dpTable[i][j] = s1[i - 1] == s2[j - 1]\n                            ? 1 + dpTable[i - 1][j - 1]\n                            : max(dpTable[i][j - 1], dpTable[i - 1][j]);\n      }\n    }\n    return dpTable[s1.size()][s2.size()];\n  }\n  //called with lcsDP()\n  ```\n  \n  [[TC]] is $$O(n*m)$$\n  [[SC]] is also $$O(n*m)$$\n- Reference: {{video https://www.youtube.com/watch?v=ASoaQq66foQ}}",536879577]],["^15",[332,"^19","~m1691991858014",536879576]],["^15",[332,"^Z","pages/Longest Common Subsequence.md",536877926]],["^15",[333,"^Q","3 [[Algorithm]]s in decreasing order of growth are\n* Normal Recursive Approach\n* Memoized [[Recurse]]ive Approach\n* [[Dynamic Programming]] + [[Iterative]] + [[Memoize]]d Approach",536878683]],["^15",[333,"^O","^16",536877988]],["^15",[333,"^@",false,536877988]],["^15",[333,"^F",331,536877988]],["^15",[333,"^X",322,536877988]],["^15",[333,"^V",322,536877988]],["^15",[333,"^U",111,536878684]],["^15",[333,"^U",322,536878684]],["^15",[333,"^U",336,536878684]],["^15",[333,"^U",338,536878684]],["^15",[333,"^U",339,536878684]],["^15",[333,"^U",340,536878684]],["^15",[333,"^?",["^ "],536878683]],["^15",[333,"^H",111,536878683]],["^15",[333,"^H",336,536878683]],["^15",[333,"^H",338,536878683]],["^15",[333,"^H",339,536878683]],["^15",[333,"^H",340,536878683]],["^15",[333,"^;","~u64d9aaad-7372-4cc5-919d-55c24e6183fb",536877988]],["^15",[334,"^Q","Normal [[Recurse]]ion\n\nIn this approach we recursively ask if taking an element from a string or not taking it would yield a bigger common subsequence. We take an element if it matches with the currently tracked element of the other string, in this case the overall common subsequence size increases by 1.\n\n![image.png](../assets/image_1691988397797_0.png) \nAs we can see, we start from the first character of both strings and compare them. If they are equal, they increase the LCS and we get LCS increased by 1.\nEffectively, if 2 elements are equal, the problem then becomes finding the LCS of the remaining 2 strings and we can forget the elements that were equal.\n![image.png](../assets/image_1691988538490_0.png)\n\nBut if the elements are not equal, then they can either contribute to the LCS, or not. \nFor example:\nit is possible that an element from string 1 can be the same as an element at the end of string 2.\n![image.png](../assets/image_1691988714170_0.png)\nHere, the ``C`` from string 1 is at the end of string 2. So it does contribute to the LCS.\n\nHence we need to recursively find all possible combinations of subsequences of both strings and compare their culminated LCS'.\n\nIn C++,\n```cpp\n// Bottom up, (size1,size2), Normal Recursion based approach, TLE\nint lcs(int i, int j) {\n  if (i < 0 || j < 0) {\n    return 0;\n  }\n\n  if (s1[i] == s2[j]) {\n    return 1 + lcs(i - 1, j - 1);\n  } else {\n    return max(lcs(i, j - 1), lcs(i - 1, j));\n  }\n}\n\n//called with lcs(s1.size()-1,s2.size()-1)\n```\n\n[[TC]] is $$\\text{0(}2^{n+m}\\text{)}$$\nwhere ``n`` is size of string 1, and ``m`` is size of string 2.\n[[SC]] is O(1) since our [[Algorithm]] takes no extra space.",536878680]],["^15",[334,"^O","^16",536878055]],["^15",[334,"^@",false,536878055]],["^15",[334,"^F",333,536878055]],["^15",[334,"^X",322,536878055]],["^15",[334,"^V",322,536878055]],["^15",[334,"^U",111,536878674]],["^15",[334,"^U",316,536878674]],["^15",[334,"^U",317,536878674]],["^15",[334,"^U",322,536878674]],["^15",[334,"^U",338,536878674]],["^15",[334,"^?",["^ "],536878680]],["^15",[334,"^H",111,536878680]],["^15",[334,"^H",316,536878680]],["^15",[334,"^H",317,536878680]],["^15",[334,"^H",338,536878680]],["^15",[334,"^;","~u64d9ab73-ecb8-473a-9d00-5c725c40e25e",536878055]],["^15",[335,"^Q","[[Memoize]]d [[Recurse]]ive Approach\n\nIn the normal approach, we can see that most of the branches are effectively repeating already traversed branches.\nWe can simply store the results and drop the [[TC]] at the cost of some [[SC]].\n\nIn C++,\n```cpp\n// Bottom up, Recursion+Memoized, (size1,size2), a bit slower growth in TC\nint lcsMemoized(int i, int j) {\n  if (i < 0 || j < 0) {\n    return 0;\n  }\n\n  if (memoTable[i][j] != -1) {\n    return memoTable[i][j];\n  }\n\n  if (s1[i] == s2[j]) {\n    memoTable[i][j] = 1 + lcsMemoized(i - 1, j - 1);\n  } else {\n    memoTable[i][j] = max(lcsMemoized(i, j - 1), lcsMemoized(i - 1, j));\n  }\n  return memoTable[i][j];\n}\n//called with lcsmemoized(s1.size()-1,s2.size()-1)\n```\nTC is same as normal approach in worst case, but in average and best case it is a lot better.\nSC is $$O(n*m)$$",536878830]],["^15",[335,"^O","^16",536878521]],["^15",[335,"^@",false,536878521]],["^15",[335,"^F",334,536878521]],["^15",[335,"^X",322,536878521]],["^15",[335,"^V",322,536878521]],["^15",[335,"^U",316,536878636]],["^15",[335,"^U",317,536878636]],["^15",[335,"^U",322,536878636]],["^15",[335,"^U",336,536878636]],["^15",[335,"^U",338,536878636]],["^15",[335,"^?",["^ "],536878830]],["^15",[335,"^H",316,536878830]],["^15",[335,"^H",317,536878830]],["^15",[335,"^H",336,536878830]],["^15",[335,"^H",338,536878830]],["^15",[335,"^;","~u64d9b5da-3152-44f1-a7fb-bda3f720694b",536878521]],["^15",[336,"^K",1691989484171,536878528]],["^15",[336,"^@",false,536878528]],["^15",[336,"^Y","memoize",536878528]],["^15",[336,"^11","Memoize",536878528]],["^15",[336,"^B",1691989484171,536878528]],["^15",[336,"^;","~u64d9b5ec-3d6c-4bc7-b089-6f47987bc198",536878528]],["^15",[338,"^K",1691989502482,536878545]],["^15",[338,"^@",false,536878545]],["^15",[338,"^Y","recurse",536878545]],["^15",[338,"^11","Recurse",536878545]],["^15",[338,"^B",1691989502482,536878545]],["^15",[338,"^;","~u64d9b5fe-ed3b-4c8a-b54d-40a24656a082",536878545]],["^15",[339,"^K",1691989536976,536878562]],["^15",[339,"^@",false,536878562]],["^15",[339,"^Y","iterative",536878562]],["^15",[339,"^11","Iterative",536878562]],["^15",[339,"^B",1691989536976,536878562]],["^15",[339,"^;","~u64d9b620-35fa-49f7-ae5f-4b22333fe64b",536878562]],["^15",[340,"^K",1691989536977,536878562]],["^15",[340,"^@",false,536878562]],["^15",[340,"^Y","dynamic programming",536878562]],["^15",[340,"^11","Dynamic Programming",536878562]],["^15",[340,"^B",1691989536977,536878562]],["^15",[340,"^;","~u64d9b620-cdb8-4c65-b72f-11d1877054fc",536878562]],["^15",[341,"^Q","[[Dynamic Programming]] + [[Iterative]] + [[Memoize]]d Approach\n\nFrom the previous approaches, it can be observed that we depend on the solution to the previous subproblems (smaller strings to be compared). \nSo if we go from smaller strings to bigger strings, we can effectively forgo the recursion and linearly find the LCS from smaller strings to bigger ones.\nTo do so, we can visualize the 2 strings in a [[2D]] [[Matrix]].\n\nFor ex.:\nFor ``TOUR`` and ``OPERA``\n![image.png](../assets/image_1691990912736_0.png) \n\nNow, we can find the LCS by going from top left to right bottom and looking at previous values and building upon them. \nEach row's/column's character represents the max. subsequence size from empty string to that character.\nFor ex.:\nIf we take ``\"\"TO`` in row and ``\"\"OP`` in column, then the cell corresponding to them will hold the max. subsequence size, which is 1 in this case.\n\nNow, the [[Algorithm]] .\nFirst we initialize all ``\"\"`` vs ``\"\"`` comparison values, these are always 0, because empty strings have no common subsequence with each other.\n![image.png](../assets/image_1691991058571_0.png)\n\nNow we compare subsequent cells for each row, for each cell, if the 2 current characters are inequal then we take max of the previous row same column, or previous column same row. In other words, we take the max of either the subsequence till the current string 1 character and the previous string 2 character, or the other way around.\n\nFor ex.:\n![image.png](../assets/image_1691991382972_0.png)\nSince ``T`` and ``O`` are inequal, we take max of ``\"\"`` and ``\"\"O`` vs. ``\"\"T`` and``\"\"`` .\nThis is exactly the same as the original algorithm, either we take the LCS size till current element of either string 1 or string 2, whichever is bigger.\n\nNow, if 2 characters that are equal, we do the same but add 1 to the max. This is because the current characters are increasing the LCS by 1.\n\nFinally, we get this matrix.\n![image.png](../assets/image_1691991789152_0.png)\n\nAnd the result is the last element.\n\nIn C++,\n```cpp\n// Top to Bottom, 1 indexed, DP + Iterative + Memoized, O(nm)\nint lcsDP() {\n  for (int i{1}; i <= cast(s1.size()); ++i) {\n    for (int j{1}; j <= cast(s2.size()); ++j) {\n      dpTable[i][j] = s1[i - 1] == s2[j - 1]\n                          ? 1 + dpTable[i - 1][j - 1]\n                          : max(dpTable[i][j - 1], dpTable[i - 1][j]);\n    }\n  }\n  return dpTable[s1.size()][s2.size()];\n}\n//called with lcsDP()\n```\n\n[[TC]] is $$O(n*m)$$\n[[SC]] is also $$O(n*m)$$",536879575]],["^15",[341,"^O","^16",536878687]],["^15",[341,"^@",false,536878687]],["^15",[341,"^F",335,536878687]],["^15",[341,"^X",322,536878687]],["^15",[341,"^V",322,536878687]],["^15",[341,"^U",111,536879242]],["^15",[341,"^U",316,536879242]],["^15",[341,"^U",317,536879242]],["^15",[341,"^U",322,536879242]],["^15",[341,"^U",336,536879242]],["^15",[341,"^U",339,536879242]],["^15",[341,"^U",340,536879242]],["^15",[341,"^U",345,536879242]],["^15",[341,"^U",346,536879242]],["^15",[341,"^?",["^ "],536879575]],["^15",[341,"^H",111,536879575]],["^15",[341,"^H",316,536879575]],["^15",[341,"^H",317,536879575]],["^15",[341,"^H",336,536879575]],["^15",[341,"^H",339,536879575]],["^15",[341,"^H",340,536879575]],["^15",[341,"^H",345,536879575]],["^15",[341,"^H",346,536879575]],["^15",[341,"^;","~u64d9b6e6-4abd-4ed8-9720-8eed354180a1",536878687]],["^15",[342,"^Q","Reference: {{video https://www.youtube.com/watch?v=ASoaQq66foQ}}",536878876]],["^15",[342,"^O","^16",536878691]],["^15",[342,"^@",false,536878691]],["^15",[342,"^F",341,536878691]],["^15",[342,"^S",343,536878876]],["^15",[342,"^X",322,536878691]],["^15",[342,"^V",322,536878691]],["^15",[342,"^U",322,536878692]],["^15",[342,"^?",["^ "],536878876]],["^15",[342,"^;","~u64d9b6ed-47cf-408b-90de-1a3e3420cde8",536878691]],["^15",[343,"^?",["^ ","~:logseq.macro-name","video","~:logseq.macro-arguments",["https://www.youtube.com/watch?v=ASoaQq66foQ"]],536878872]],["^15",[343,"^W","macro",536878872]],["^15",[343,"^T","video https://www.youtube.com/watch?v=ASoaQq66foQ",536878872]],["^15",[345,"^K",1691990642371,536879012]],["^15",[345,"^@",false,536879012]],["^15",[345,"^Y","matrix",536879012]],["^15",[345,"^11","Matrix",536879012]],["^15",[345,"^B",1691990642371,536879012]],["^15",[345,"^;","~u64d9ba72-290d-45c9-a79f-7f5c17ee65aa",536879012]],["^15",[346,"^K",1691990642372,536879012]],["^15",[346,"^@",false,536879012]],["^15",[346,"^Y","2d",536879012]],["^15",[346,"^11","2D",536879012]],["^15",[346,"^B",1691990642372,536879012]],["^15",[346,"^;","~u64d9ba72-c7ba-4082-a0ff-5c8ff33f6d37",536879012]],["^15",[347,"^12",2,536879579]],["^15",[348,"^K",1692104522865,536879580]],["^15",[348,"^O","^16",536879580]],["^15",[348,"^N",20230815,536879580]],["^15",[348,"^@",true,536879580]],["^15",[348,"^Y","15-08-2023",536879580]],["^15",[348,"^11","15-08-2023",536879580]],["^15",[348,"^B",1692104522865,536879580]],["^15",[348,"^;","~u64db774a-1554-452d-88d5-79b9813a57df",536879580]],["^15",[349,"^Q","",536879581]],["^15",[349,"^O","^16",536879581]],["^15",[349,"^N",20230815,536879581]],["^15",[349,"^@",true,536879581]],["^15",[349,"^F",348,536879581]],["^15",[349,"^X",348,536879581]],["^15",[349,"^V",348,536879581]],["^15",[349,"^U",348,536879582]],["^15",[349,"^?",["^ "],536879581]],["^15",[349,"^;","~u64db774a-059b-4096-9112-d1d434d8629f",536879581]],["^15",[350,"^12",2,536879584]],["^15",[351,"^K",1692428854021,536879585]],["^15",[351,"^O","^16",536879585]],["^15",[351,"^N",20230819,536879585]],["^15",[351,"^@",true,536879585]],["^15",[351,"^Y","19-08-2023",536879585]],["^15",[351,"^11","19-08-2023",536879585]],["^15",[351,"^B",1692428854021,536879585]],["^15",[351,"^;","~u64e06a36-e3f2-4bf4-ac3c-f18eb18c6568",536879585]],["^15",[352,"^Q","",536879586]],["^15",[352,"^O","^16",536879586]],["^15",[352,"^N",20230819,536879586]],["^15",[352,"^@",true,536879586]],["^15",[352,"^F",351,536879586]],["^15",[352,"^X",351,536879586]],["^15",[352,"^V",351,536879586]],["^15",[352,"^U",351,536879587]],["^15",[352,"^?",["^ "],536879586]],["^15",[352,"^;","~u64e06a36-8642-49ae-837a-8cc623627845",536879586]],["^15",[353,"^Q","",536879589]],["^15",[353,"^O","^16",536879589]],["^15",[353,"^@",false,536879589]],["^15",[353,"^F",122,536879589]],["^15",[353,"^X",122,536879589]],["^15",[353,"^V",122,536879589]],["^15",[353,"^U",122,536879590]],["^15",[353,"^?",["^ "],536879589]],["^15",[353,"^;","~u64e06a51-9142-42bf-a845-d2dee6fdf3e7",536879589]],["^15",[354,"^Q","[[CSES]]",536879597]],["^15",[354,"^O","^16",536879594]],["^15",[354,"^@",false,536879594]],["^15",[354,"^F",111,536879594]],["^15",[354,"^X",111,536879594]],["^15",[354,"^V",111,536879594]],["^15",[354,"^U",111,536879598]],["^15",[354,"^U",270,536879598]],["^15",[354,"^?",["^ "],536879597]],["^15",[354,"^H",270,536879597]],["^15",[354,"^;","~u64e06a5e-1ddd-404e-b289-723585bd066a",536879594]],["^15",[355,"^3","- [[CSES]]\n- [[Hackerrank]]",536879953]],["^15",[355,"^19","~m1702917271686",536879952]],["^15",[355,"^Z","pages/Algorithm.md",536879599]],["^15",[357,"^3","- [[CSES_1068]]\n- [[CSES_1731]]\n-",536879920]],["^15",[357,"^19","~m1698847129081",536879919]],["^15",[357,"^Z","pages/CSES.md",536879607]],["^15",[359,"^Q","[[CSES_1731]]",536879881]],["^15",[359,"^O","^16",536879810]],["^15",[359,"^@",false,536879810]],["^15",[359,"^F",376,536879910]],["^15",[359,"^X",270,536879810]],["^15",[359,"^V",270,536879810]],["^15",[359,"^U",270,536879882]],["^15",[359,"^U",371,536879882]],["^15",[359,"^?",["^ "],536879910]],["^15",[359,"^H",371,536879910]],["^15",[359,"^;","~u64e09bbb-5beb-4cd2-a407-81e7850c6f81",536879810]],["^15",[360,"^12",2,536879857]],["^15",[361,"^K",1698059849938,536879858]],["^15",[361,"^O","^16",536879858]],["^15",[361,"^N",20231023,536879858]],["^15",[361,"^@",true,536879858]],["^15",[361,"^Y","23-10-2023",536879858]],["^15",[361,"^11","23-10-2023",536879858]],["^15",[361,"^B",1698059849938,536879858]],["^15",[361,"^;","~u65365649-d320-4799-80f7-355a278bd599",536879858]],["^15",[362,"^Q","",536879859]],["^15",[362,"^O","^16",536879859]],["^15",[362,"^N",20231023,536879859]],["^15",[362,"^@",true,536879859]],["^15",[362,"^F",361,536879859]],["^15",[362,"^X",361,536879859]],["^15",[362,"^V",361,536879859]],["^15",[362,"^U",361,536879860]],["^15",[362,"^?",["^ "],536879859]],["^15",[362,"^;","~u65365649-83c9-40c2-a807-298f56f2f68b",536879859]],["^15",[363,"^K",1698085812684,536879861]],["^15",[363,"^O","^16",536879861]],["^15",[363,"^N",20231024,536879861]],["^15",[363,"^@",true,536879861]],["^15",[363,"^Y","24-10-2023",536879861]],["^15",[363,"^11","24-10-2023",536879861]],["^15",[363,"^B",1698085812684,536879861]],["^15",[363,"^;","~u6536bbb4-02f9-4333-b7be-2881292f538d",536879861]],["^15",[364,"^Q","",536879862]],["^15",[364,"^O","^16",536879862]],["^15",[364,"^N",20231024,536879862]],["^15",[364,"^@",true,536879862]],["^15",[364,"^F",363,536879862]],["^15",[364,"^X",363,536879862]],["^15",[364,"^V",363,536879862]],["^15",[364,"^U",363,536879863]],["^15",[364,"^?",["^ "],536879862]],["^15",[364,"^;","~u6536bbb4-bda2-47bf-b8bf-a1e070e6acd3",536879862]],["^15",[365,"^12",2,536879865]],["^15",[366,"^12",2,536879868]],["^15",[367,"^K",1698836661156,536879869]],["^15",[367,"^O","^16",536879869]],["^15",[367,"^N",20231101,536879869]],["^15",[367,"^@",true,536879869]],["^15",[367,"^Y","01-11-2023",536879869]],["^15",[367,"^11","01-11-2023",536879869]],["^15",[367,"^B",1698836661156,536879869]],["^15",[367,"^;","~u654230b5-9fe7-48f4-a71d-1338253ef12f",536879869]],["^15",[368,"^Q","",536879870]],["^15",[368,"^O","^16",536879870]],["^15",[368,"^N",20231101,536879870]],["^15",[368,"^@",true,536879870]],["^15",[368,"^F",367,536879870]],["^15",[368,"^X",367,536879870]],["^15",[368,"^V",367,536879870]],["^15",[368,"^U",367,536879871]],["^15",[368,"^?",["^ "],536879870]],["^15",[368,"^;","~u654230b5-7ff8-4191-abf7-148027c2dc05",536879870]],["^15",[370,"^Q","",536879875]],["^15",[370,"^O","^16",536879875]],["^15",[370,"^@",false,536879875]],["^15",[370,"^?",["^ "],536879875]],["^15",[370,"^;","~u654256f5-3b50-4788-9281-f4ea9037f73e",536879875]],["^15",[371,"^K",1698846472074,536879881]],["^15",[371,"^[",375,536879891]],["^15",[371,"^O","^16",536879885]],["^15",[371,"^@",false,536879881]],["^15",[371,"^Y","cses_1731",536879881]],["^15",[371,"^11","CSES_1731",536879881]],["^15",[371,"^B",1698846472074,536879881]],["^15",[371,"^;","~u65425708-560f-42f3-b71b-c1f1f6d52978",536879881]],["^15",[372,"^Q","",536879881]],["^15",[372,"^O","^16",536879881]],["^15",[372,"^@",false,536879881]],["^15",[372,"^F",359,536879881]],["^15",[372,"^X",270,536879881]],["^15",[372,"^V",270,536879881]],["^15",[372,"^U",270,536879882]],["^15",[372,"^?",["^ "],536879881]],["^15",[372,"^;","~u65425708-4c2d-4879-81ce-5e64a7050165",536879881]],["^15",[373,"^Q","1731:\nUses [[Trie]] and ideas from [[Longest Common Subsequence]] Algorithm.\n\nTo solve this problem, we can first build a trie from the given strings. Then for the main string ``s``, we use [[Dynamic Programming]] to look for all possible pairs. To do so, we start from the end of the main string ``L``, and pass the index ``x``, for each value of ``x``, we go from ``x`` to ``L`` in ``i``, and look if the given string ``s[i..L]`` exists in the Trie. [[TODO]]\n\nIn C++,\n```cpp\n\nint testCases{1};\nstring s{};\nint sz{};\nint n{};\nint A{};    // alphabet set/lexicon size\nvvi trie{}; // we can use std::array too but the call-stack size is limited,\n            // rather use heap\nvb eos{};   // end-of-string\nint counter{};\nvi dpTable{};\n\nvoid setup() {\n  getline(cin, s);\n  INPUT(n);\n  A = 26;\n  sz = cast(s.size());\n  trie = vvi(cBN, vi(A, 0));\n  eos = vb(cBN, false);\n  counter = 0;\n  dpTable = vi(sz + 1, 0);\n  string arg{};\n  cin.ignore(cN,'\\n');\n  while (n-- > 0) {\n    getline(cin, arg);\n    trie_insert(arg);\n  }\n}\n \nvoid compute() {\n  dpTable[sz] = 1;\n  for (int i{sz - 1}; i >= 0; --i) {\n    dpTable[i] = search(i);\n  }\n}\nvoid trie_insert(string_view s) {\n  int size_s{cast(s.size())};\n  int next{};\n  for (int i{}; i < size_s; ++i) {\n    int &elem{trie[next][cast(s[i]%A)]};\n    if (!elem)\n      elem = ++counter;\n \n    next = elem;\n  }\n  eos[next] = true;\n}\nint search(int x) {\n  int next{};\n  int ans{};\n  for (int i{x}; i < sz; ++i) {\n    int &elem{trie[next][cast(s[i]%A)]};\n    if (!elem)\n      return ans;\n    next = elem;\n    if (eos[next]) {\n      ans += dpTable[i + 1];\n      ans %= mod10_e9_7;\n    }\n  }\n  return ans;\n}\n \nvoid output() { cout << dpTable[0] << \"\\n\"; }\n\n```\n\nUsing [[Default C++ Template]]",536879889]],["^15",[373,"^O","^16",536879886]],["^15",[373,"^@",false,536879886]],["^15",[373,"^F",371,536879886]],["^15",[373,"^X",371,536879886]],["^15",[373,"^V",371,536879886]],["^15",[373,"^U",4,536879890]],["^15",[373,"^U",67,536879890]],["^15",[373,"^U",262,536879890]],["^15",[373,"^U",322,536879890]],["^15",[373,"^U",340,536879890]],["^15",[373,"^U",371,536879890]],["^15",[373,"^?",["^ "],536879886]],["^15",[373,"^H",4,536879889]],["^15",[373,"^H",67,536879889]],["^15",[373,"^H",262,536879889]],["^15",[373,"^H",322,536879889]],["^15",[373,"^H",340,536879889]],["^15",[373,"^;","~u64e06a68-da81-49c9-9660-8244a6a8e161",536879889]],["^15",[374,"^Q","",536879889]],["^15",[374,"^O","^16",536879889]],["^15",[374,"^@",false,536879889]],["^15",[374,"^F",373,536879889]],["^15",[374,"^X",371,536879889]],["^15",[374,"^V",371,536879889]],["^15",[374,"^U",371,536879890]],["^15",[374,"^?",["^ "],536879889]],["^15",[374,"^;","~u64e09bbb-036c-461c-be57-42df9f3da20d",536879889]],["^15",[375,"^3","- 1731:\n  Uses [[Trie]] and ideas from [[Longest Common Subsequence]] Algorithm.\n  \n  To solve this problem, we can first build a trie from the given strings. Then for the main string ``s``, we use [[Dynamic Programming]] to look for all possible pairs. To do so, we start from the end of the main string ``L``, and pass the index ``x``, for each value of ``x``, we go from ``x`` to ``L`` in ``i``, and look if the given string ``s[i..L]`` exists in the Trie. [[TODO]]\n  \n  In C++,\n  ```cpp\n  \n  int testCases{1};\n  string s{};\n  int sz{};\n  int n{};\n  int A{};    // alphabet set/lexicon size\n  vvi trie{}; // we can use std::array too but the call-stack size is limited,\n              // rather use heap\n  vb eos{};   // end-of-string\n  int counter{};\n  vi dpTable{};\n  \n  void setup() {\n    getline(cin, s);\n    INPUT(n);\n    A = 26;\n    sz = cast(s.size());\n    trie = vvi(cBN, vi(A, 0));\n    eos = vb(cBN, false);\n    counter = 0;\n    dpTable = vi(sz + 1, 0);\n    string arg{};\n    cin.ignore(cN,'\\n');\n    while (n-- > 0) {\n      getline(cin, arg);\n      trie_insert(arg);\n    }\n  }\n   \n  void compute() {\n    dpTable[sz] = 1;\n    for (int i{sz - 1}; i >= 0; --i) {\n      dpTable[i] = search(i);\n    }\n  }\n  void trie_insert(string_view s) {\n    int size_s{cast(s.size())};\n    int next{};\n    for (int i{}; i < size_s; ++i) {\n      int &elem{trie[next][cast(s[i]%A)]};\n      if (!elem)\n        elem = ++counter;\n   \n      next = elem;\n    }\n    eos[next] = true;\n  }\n  int search(int x) {\n    int next{};\n    int ans{};\n    for (int i{x}; i < sz; ++i) {\n      int &elem{trie[next][cast(s[i]%A)]};\n      if (!elem)\n        return ans;\n      next = elem;\n      if (eos[next]) {\n        ans += dpTable[i + 1];\n        ans %= mod10_e9_7;\n      }\n    }\n    return ans;\n  }\n   \n  void output() { cout << dpTable[0] << \"\\n\"; }\n  \n  ```\n  \n  Using [[Default C++ Template]]\n-",536879893]],["^15",[375,"^19","~m1698846476299",536879892]],["^15",[375,"^Z","pages/CSES_1731.md",536879891]],["^15",[376,"^Q","[[CSES_1068]]",536879917]],["^15",[376,"^O","^16",536879894]],["^15",[376,"^@",false,536879894]],["^15",[376,"^F",270,536879894]],["^15",[376,"^X",270,536879894]],["^15",[376,"^V",270,536879894]],["^15",[376,"^U",270,536879918]],["^15",[376,"^U",380,536879918]],["^15",[376,"^?",["^ "],536879917]],["^15",[376,"^H",380,536879917]],["^15",[376,"^;","~u65425711-ad30-407c-bdd3-729ecf800355",536879894]],["^15",[380,"^K",1698847129035,536879917]],["^15",[380,"^O","^16",536879921]],["^15",[380,"^@",false,536879917]],["^15",[380,"^Y","cses_1068",536879917]],["^15",[380,"^11","CSES_1068",536879917]],["^15",[380,"^B",1698847129035,536879917]],["^15",[380,"^;","~u65425999-2c0e-4374-b158-5eac2d05a8f2",536879917]],["^15",[381,"^Q","",536879922]],["^15",[381,"^O","^16",536879922]],["^15",[381,"^@",false,536879922]],["^15",[381,"^F",380,536879922]],["^15",[381,"^X",380,536879922]],["^15",[381,"^V",380,536879922]],["^15",[381,"^U",380,536879923]],["^15",[381,"^?",["^ "],536879922]],["^15",[381,"^;","~u65425999-b45f-4a97-902e-1663e10ddd1e",536879922]],["^15",[382,"^12",2,536879926]],["^15",[383,"^K",1698922121101,536879927]],["^15",[383,"^O","^16",536879927]],["^15",[383,"^N",20231102,536879927]],["^15",[383,"^@",true,536879927]],["^15",[383,"^Y","02-11-2023",536879927]],["^15",[383,"^11","02-11-2023",536879927]],["^15",[383,"^B",1698922121101,536879927]],["^15",[383,"^;","~u65437e89-e707-452d-b3f1-bec438e3fbfa",536879927]],["^15",[384,"^Q","",536879928]],["^15",[384,"^O","^16",536879928]],["^15",[384,"^N",20231102,536879928]],["^15",[384,"^@",true,536879928]],["^15",[384,"^F",383,536879928]],["^15",[384,"^X",383,536879928]],["^15",[384,"^V",383,536879928]],["^15",[384,"^U",383,536879929]],["^15",[384,"^?",["^ "],536879928]],["^15",[384,"^;","~u65437e89-03a7-42bd-be6a-4ac56cfbbf01",536879928]],["^15",[385,"^K",1698949801421,536879930]],["^15",[385,"^O","^16",536879930]],["^15",[385,"^N",20231103,536879930]],["^15",[385,"^@",true,536879930]],["^15",[385,"^Y","03-11-2023",536879930]],["^15",[385,"^11","03-11-2023",536879930]],["^15",[385,"^B",1698949801421,536879930]],["^15",[385,"^;","~u6543eaa9-c8ad-4214-a0fd-42c9761c99c0",536879930]],["^15",[386,"^Q","",536879931]],["^15",[386,"^O","^16",536879931]],["^15",[386,"^N",20231103,536879931]],["^15",[386,"^@",true,536879931]],["^15",[386,"^F",385,536879931]],["^15",[386,"^X",385,536879931]],["^15",[386,"^V",385,536879931]],["^15",[386,"^U",385,536879932]],["^15",[386,"^?",["^ "],536879931]],["^15",[386,"^;","~u6543eaa9-69cc-4f05-9c77-c88800c54393",536879931]],["^15",[387,"^K",1699036219094,536879933]],["^15",[387,"^O","^16",536879933]],["^15",[387,"^N",20231104,536879933]],["^15",[387,"^@",true,536879933]],["^15",[387,"^Y","04-11-2023",536879933]],["^15",[387,"^11","04-11-2023",536879933]],["^15",[387,"^B",1699036219094,536879933]],["^15",[387,"^;","~u65453c3b-aace-4b18-aaef-44cf171b6783",536879933]],["^15",[388,"^Q","",536879934]],["^15",[388,"^O","^16",536879934]],["^15",[388,"^N",20231104,536879934]],["^15",[388,"^@",true,536879934]],["^15",[388,"^F",387,536879934]],["^15",[388,"^X",387,536879934]],["^15",[388,"^V",387,536879934]],["^15",[388,"^U",387,536879935]],["^15",[388,"^?",["^ "],536879934]],["^15",[388,"^;","~u65453c3b-2792-4596-97f7-696a6da7aada",536879934]],["^15",[389,"^12",2,536879937]],["^15",[390,"^K",1699275556810,536879938]],["^15",[390,"^O","^16",536879938]],["^15",[390,"^N",20231106,536879938]],["^15",[390,"^@",true,536879938]],["^15",[390,"^Y","06-11-2023",536879938]],["^15",[390,"^11","06-11-2023",536879938]],["^15",[390,"^B",1699275556810,536879938]],["^15",[390,"^;","~u6548e324-f6d7-446c-ac58-9821dc8f70e7",536879938]],["^15",[391,"^Q","",536879939]],["^15",[391,"^O","^16",536879939]],["^15",[391,"^N",20231106,536879939]],["^15",[391,"^@",true,536879939]],["^15",[391,"^F",390,536879939]],["^15",[391,"^X",390,536879939]],["^15",[391,"^V",390,536879939]],["^15",[391,"^U",390,536879940]],["^15",[391,"^?",["^ "],536879939]],["^15",[391,"^;","~u6548e324-c9a3-4e71-8a36-85828114af7d",536879939]],["^15",[392,"^12",2,536879942]],["^15",[393,"^K",1702917217928,536879943]],["^15",[393,"^O","^16",536879943]],["^15",[393,"^N",20231218,536879943]],["^15",[393,"^@",true,536879943]],["^15",[393,"^Y","18-12-2023",536879943]],["^15",[393,"^11","18-12-2023",536879943]],["^15",[393,"^B",1702917217928,536879943]],["^15",[393,"^;","~u65807461-cc80-4414-8023-8e85b166c226",536879943]],["^15",[394,"^Q","",536879944]],["^15",[394,"^O","^16",536879944]],["^15",[394,"^N",20231218,536879944]],["^15",[394,"^@",true,536879944]],["^15",[394,"^F",393,536879944]],["^15",[394,"^X",393,536879944]],["^15",[394,"^V",393,536879944]],["^15",[394,"^U",393,536879945]],["^15",[394,"^?",["^ "],536879944]],["^15",[394,"^;","~u65807461-fb19-4633-8454-9751d7263a63",536879944]],["^15",[395,"^Q","[[Hackerrank]]",536879950]],["^15",[395,"^O","^16",536879946]],["^15",[395,"^@",false,536879946]],["^15",[395,"^F",354,536879946]],["^15",[395,"^X",111,536879946]],["^15",[395,"^V",111,536879946]],["^15",[395,"^U",111,536879951]],["^15",[395,"^U",396,536879951]],["^15",[395,"^?",["^ "],536879950]],["^15",[395,"^H",396,536879950]],["^15",[395,"^;","~u65807492-7340-4272-98dd-85c9792ad97d",536879946]],["^15",[396,"^K",1702917271179,536879950]],["^15",[396,"^[",398,536879959]],["^15",[396,"^O","^16",536879954]],["^15",[396,"^@",false,536879950]],["^15",[396,"^Y","hackerrank",536879950]],["^15",[396,"^11","Hackerrank",536879950]],["^15",[396,"^B",1710791850826,536881163]],["^15",[396,"^;","~u65ba3e74-2e12-44f0-bdc0-61c8289f446c",536880157]],["^15",[397,"^Q","[Simple Array Sum](https://www.hackerrank.com/challenges/simple-array-sum/problem?isFullScreen=true)\nSimple Solution, use std::accumulate to solve it.",536879987]],["^15",[397,"^O","^16",536879955]],["^15",[397,"^@",false,536879955]],["^15",[397,"^F",396,536879955]],["^15",[397,"^X",396,536879955]],["^15",[397,"^V",396,536879955]],["^15",[397,"^U",396,536879956]],["^15",[397,"^;","~u65807497-314d-456d-8d79-62a24c3224cb",536879955]],["^15",[398,"^3","- [Simple Array Sum](https://www.hackerrank.com/challenges/simple-array-sum/problem?isFullScreen=true)\n  Simple Solution, use std::accumulate to solve it.\n- [A very big sum](https://www.hackerrank.com/challenges/a-very-big-sum/problem)\n  Same as Simple Array Sum, but just use a normal loop and long long.\n- [Compare the triplets](https://www.hackerrank.com/challenges/compare-the-triplets/problem?isFullScreen=true)\n  Just simple comparison.\n- [Plus Minus](https://www.hackerrank.com/challenges/plus-minus/problem?isFullScreen=true)\n  Simple loop, count and ratio.\n- [Staricase](https://www.hackerrank.com/challenges/staircase/problem?isFullScreen=true)\n  ```cpp\n  void compute()\n  {\n      for (int i{}, spaces{n - 1}, hashes{1}; i < n; ++i, hashes = i + 1, spaces = n - hashes)\n      {\n        while (spaces-- > 0)\n        {\n          cout << \" \";\n        }\n        while (hashes-- > 0)\n        {\n          cout << \"#\";\n        }\n        cout << \"\\n\";\n      }\n    }\n  ```\n- [Mini max Sum](https://www.hackerrank.com/challenges/mini-max-sum/problem?isFullScreen=true)\n  ```cpp\n    void compute()\n    {\n      int total{0};\n      int min_val{arr[0]};\n      int max_val{arr[0]};\n      for (int i{}; i < n; ++i)\n      {\n        total += arr[i];\n        min_val = min(arr[i], min_val);\n        max_val = max(arr[i], max_val);\n      }\n      min_sum = total - max_val;\n      max_sum = total - min_val;\n    }\n  ```\n- [Birthday Cake](https://www.hackerrank.com/challenges/birthday-cake-candles/problem?isFullScreen=true)\n  ```cpp\n    void compute()\n    {\n      int max_elem{arr[0]};\n      for(int i{};i<n;++i){\n        if(arr[i] ==  max_elem){\n          ++result; \n        }\n        else if(arr[i] > max_elem){\n          max_elem=arr[i];\n          result=1;\n        }\n  \n      }\n  \n    }\n  ```\n- [Time Conversion](https://www.hackerrank.com/challenges/time-conversion/problem?isFullScreen=true)\n  ```cpp\n    void compute()\n    {\n      int hour{stoi(inp_time.substr(0, 2))};\n      if (inp_time[8] == 'A')\n      {\n        hour %= 12;\n        result = (hour / 10 < 1 ? \"0\" : \"\") + to_string(hour);\n      }\n      else\n      {\n  \n        hour += 12;\n        hour %= 24;\n        result = hour == 0 ? \"12\" : to_string(hour);\n      }\n      result += inp_time.substr(2, 6);\n    }\n  ```\n- [Grading](https://www.hackerrank.com/challenges/grading/problem?isFullScreen=true)\n  ```cpp\n    void compute()\n    {\n      if (grade < 38)\n      {\n        result = grade;\n      }\n      else\n      {\n        int nm5 = grade + (5 - (grade + 5) % 5);\n        result = (nm5 - grade < 3) ? nm5 : grade;\n      }\n    }\n  ```\n- [Apples and Oranges](https://www.hackerrank.com/challenges/apple-and-orange/problem?isFullScreen=true)\n  ```cpp\n    void compute()\n    {\n      for (int i{}, sum_a{}; i < m; ++i)\n      {\n        sum_a = a + apples[i];\n        if (sum_a >= s && sum_a <= t)\n        {\n          ++count_apples;\n        }\n      }\n  \n      for (int i{}, sum_o{}; i < n; ++i)\n      {\n        sum_o = b + oranges[i];\n        if (sum_o >= s && sum_o <= t)\n        {\n          ++count_oranges;\n        }\n      }\n    }\n  ```\n- $$x1 + y* v1 = x2+ y*v2 $$ Because y needs to be the same, it has to be the same number of hops.\n  $$y* v1 - y*v2= x2-x1  $$\n  $$y \\lparen v1 - v2 \\rparen = x2-x1  $$\n  $$y = \\frac{x2-x1}{v1 - v2}  $$\n- [Between 2 sets](https://www.hackerrank.com/challenges/between-two-sets/problem)\n  ```cpp\n      int gcd(int a, int b)\n      {\n          if (b == 0)\n              return a;\n          return gcd(b, a % b);\n      }\n  \n      int lcm(int a, int b)\n      {\n          return abs(a * b) / gcd(a, b);\n      }\n  \n      void compute()\n      {\n          int a_lcm{a[0]};\n          int b_gcd{b[0]};\n  \n          for (int i{}; i < n; ++i)\n          {\n              a_lcm = lcm(a_lcm, a[i]);\n          }\n          for (int i{}; i < m; ++i)\n          {\n              b_gcd = gcd(b_gcd, b[i]);\n          }        \n          if(b_gcd%a_lcm != 0) {\n              result=0;\n              return;\n          }\n  \n          for (int i{a_lcm}; i <= b_gcd; i += a_lcm){\n              if(b_gcd%i == 0){\n                  ++result;\n              }\n          }\n  \n      }\n  ```\n  We need to find the count of distinct integers, such that for each integer x, all elements of array a must be a factor (divisor) of x. And all elements of array b must be divisible by x, or x should be a factor to all of them. For array a, we can find a number that shares its factors with all elements of a, that would be its [[LCM]], call it p, for array b we can find a number that divides all the numbers, that would be the [[GCD]], call it q. So we have an LCM, this is the smallest number divisible by all elements of a, and GCD, the greatest number that divides all of b. If ``p%q == 0`` (p divides q) then that means, p can be used to divide all the numbers of b, because q is a multiple of p, so we find the numbers between p and q that also divide q, so we check all multiples of p between p and q. \n  For ex.:\n  For the array ``a= [2,4]``\n  For the array ``b= [16,32, 96]``\n  LCM of a = p = 4\n  GCD of b = q = 16\n  16%4=0, so there does exist atleast 2 integers that are factors of all elements of b, and have all elements of a as their factors.\n  16/4 = 4, so there's 4 elements between 4 and 16 that can also be part of our result\n  We loop at all multiples of p, i.e., 4, so 4, 8, 12 and 16 and find out 4, 8, 16 satisfy that condition. \n  Answer: 3\n- [Breaking Best and Worst Record](https://www.hackerrank.com/challenges/breaking-best-and-worst-records/problem)\n  ```cpp\n      void compute()\n      {\n          int max_elem{scores[0]};\n          int min_elem{scores[0]};\n  \n          for (int i{1}, score{scores[1]}; i < n; ++i, score = scores[i])\n          {\n              if (score > max_elem)\n              {\n                  max_elem = score;\n                  ++max_breaks;\n              }\n              if (score < min_elem)\n              {\n                  min_elem = score;\n                  ++min_breaks;\n              }\n          }\n      }\n  ```\n  We simply track the min and max element and compare the current element with both, and increase their counts.\n-",536881165]],["^15",[398,"^19","~m1710791851107",536881164]],["^15",[398,"^Z","pages/Hackerrank.md",536879959]],["^15",[399,"^Q","[A very big sum](https://www.hackerrank.com/challenges/a-very-big-sum/problem)\nSame as Simple Array Sum, but just use a normal loop and long long.",536880029]],["^15",[399,"^O","^16",536879972]],["^15",[399,"^@",false,536879972]],["^15",[399,"^F",397,536879972]],["^15",[399,"^X",396,536879972]],["^15",[399,"^V",396,536879972]],["^15",[399,"^U",396,536879973]],["^15",[399,"^;","~u658074c5-f9af-493c-97ee-8ee4087f7ffb",536879972]],["^15",[400,"^Q","[Compare the triplets](https://www.hackerrank.com/challenges/compare-the-triplets/problem?isFullScreen=true)\nJust simple comparison.",536880064]],["^15",[400,"^O","^16",536880030]],["^15",[400,"^@",false,536880030]],["^15",[400,"^F",399,536880030]],["^15",[400,"^X",396,536880030]],["^15",[400,"^V",396,536880030]],["^15",[400,"^U",396,536880031]],["^15",[400,"^;","~u658074fe-e9cd-4669-bd6f-fb57290682ad",536880030]],["^15",[401,"^Q","[Birthday Cake](https://www.hackerrank.com/challenges/birthday-cake-candles/problem?isFullScreen=true)\n```cpp\n  void compute()\n  {\n    int max_elem{arr[0]};\n    for(int i{};i<n;++i){\n      if(arr[i] ==  max_elem){\n        ++result; \n      }\n      else if(arr[i] > max_elem){\n        max_elem=arr[i];\n        result=1;\n      }\n\n    }\n\n  }\n```",536880108]],["^15",[401,"^O","^16",536880064]],["^15",[401,"^@",false,536880064]],["^15",[401,"^F",418,536880091]],["^15",[401,"^X",396,536880064]],["^15",[401,"^V",396,536880064]],["^15",[401,"^U",396,536880065]],["^15",[401,"^;","~u65807520-42ba-4168-b010-0e00b3fd1579",536880064]],["^15",[402,"^K",1702924214450,536880068]],["^15",[402,"^O","^16",536880068]],["^15",[402,"^N",20231219,536880068]],["^15",[402,"^@",true,536880068]],["^15",[402,"^Y","19-12-2023",536880068]],["^15",[402,"^11","19-12-2023",536880068]],["^15",[402,"^B",1702924214450,536880068]],["^15",[402,"^;","~u65808fb6-d625-4b7d-bfa3-afd5756f7425",536880068]],["^15",[403,"^Q","",536880069]],["^15",[403,"^O","^16",536880069]],["^15",[403,"^N",20231219,536880069]],["^15",[403,"^@",true,536880069]],["^15",[403,"^F",402,536880069]],["^15",[403,"^X",402,536880069]],["^15",[403,"^V",402,536880069]],["^15",[403,"^U",402,536880070]],["^15",[403,"^?",["^ "],536880069]],["^15",[403,"^;","~u65808fb6-c6ac-4e4b-a49f-0b171cdc4c41",536880069]],["^15",[404,"^K",1703010607920,536880071]],["^15",[404,"^O","^16",536880071]],["^15",[404,"^N",20231220,536880071]],["^15",[404,"^@",true,536880071]],["^15",[404,"^Y","20-12-2023",536880071]],["^15",[404,"^11","20-12-2023",536880071]],["^15",[404,"^B",1703010607920,536880071]],["^15",[404,"^;","~u6581e12f-29e4-4486-aba9-32b71b3c6b90",536880071]],["^15",[405,"^Q","",536880072]],["^15",[405,"^O","^16",536880072]],["^15",[405,"^N",20231220,536880072]],["^15",[405,"^@",true,536880072]],["^15",[405,"^F",404,536880072]],["^15",[405,"^X",404,536880072]],["^15",[405,"^V",404,536880072]],["^15",[405,"^U",404,536880073]],["^15",[405,"^?",["^ "],536880072]],["^15",[405,"^;","~u6581e12f-f4e6-4a92-b175-1a9ab2d98697",536880072]],["^15",[406,"^K",1703097059418,536880074]],["^15",[406,"^O","^16",536880074]],["^15",[406,"^N",20231221,536880074]],["^15",[406,"^@",true,536880074]],["^15",[406,"^Y","21-12-2023",536880074]],["^15",[406,"^11","21-12-2023",536880074]],["^15",[406,"^B",1703097059418,536880074]],["^15",[406,"^;","~u658332e3-b5fe-43c3-b750-c12db57deb76",536880074]],["^15",[407,"^Q","",536880075]],["^15",[407,"^O","^16",536880075]],["^15",[407,"^N",20231221,536880075]],["^15",[407,"^@",true,536880075]],["^15",[407,"^F",406,536880075]],["^15",[407,"^X",406,536880075]],["^15",[407,"^V",406,536880075]],["^15",[407,"^U",406,536880076]],["^15",[407,"^?",["^ "],536880075]],["^15",[407,"^;","~u658332e3-10b2-436f-9f48-25d17bac0e20",536880075]],["^15",[408,"^K",1703183450135,536880077]],["^15",[408,"^O","^16",536880077]],["^15",[408,"^N",20231222,536880077]],["^15",[408,"^@",true,536880077]],["^15",[408,"^Y","22-12-2023",536880077]],["^15",[408,"^11","22-12-2023",536880077]],["^15",[408,"^B",1703183450135,536880077]],["^15",[408,"^;","~u6584845a-e2c0-4d56-9897-8740bcad519e",536880077]],["^15",[409,"^Q","",536880078]],["^15",[409,"^O","^16",536880078]],["^15",[409,"^N",20231222,536880078]],["^15",[409,"^@",true,536880078]],["^15",[409,"^F",408,536880078]],["^15",[409,"^X",408,536880078]],["^15",[409,"^V",408,536880078]],["^15",[409,"^U",408,536880079]],["^15",[409,"^?",["^ "],536880078]],["^15",[409,"^;","~u6584845a-1014-46f0-931d-4fe9cdc3787a",536880078]],["^15",[410,"^12",2,536880081]],["^15",[411,"^K",1703504828642,536880082]],["^15",[411,"^O","^16",536880082]],["^15",[411,"^N",20231225,536880082]],["^15",[411,"^@",true,536880082]],["^15",[411,"^Y","25-12-2023",536880082]],["^15",[411,"^11","25-12-2023",536880082]],["^15",[411,"^B",1703504828642,536880082]],["^15",[411,"^;","~u65896bbc-cbd9-4c9a-8fb6-fa5d61e03f92",536880082]],["^15",[412,"^Q","",536880083]],["^15",[412,"^O","^16",536880083]],["^15",[412,"^N",20231225,536880083]],["^15",[412,"^@",true,536880083]],["^15",[412,"^F",411,536880083]],["^15",[412,"^X",411,536880083]],["^15",[412,"^V",411,536880083]],["^15",[412,"^U",411,536880084]],["^15",[412,"^?",["^ "],536880083]],["^15",[412,"^;","~u65896bbc-2d7f-45fd-94a5-3643bd03d7b1",536880083]],["^15",[413,"^12",2,536880086]],["^15",[414,"^K",1704804205683,536880087]],["^15",[414,"^O","^16",536880087]],["^15",[414,"^N",20240109,536880087]],["^15",[414,"^@",true,536880087]],["^15",[414,"^Y","09-01-2024",536880087]],["^15",[414,"^11","09-01-2024",536880087]],["^15",[414,"^B",1704804205683,536880087]],["^15",[414,"^;","~u659d3f6d-ca0d-43c8-a06b-8de8a55c5c8a",536880087]],["^15",[415,"^Q","",536880088]],["^15",[415,"^O","^16",536880088]],["^15",[415,"^N",20240109,536880088]],["^15",[415,"^@",true,536880088]],["^15",[415,"^F",414,536880088]],["^15",[415,"^X",414,536880088]],["^15",[415,"^V",414,536880088]],["^15",[415,"^U",414,536880089]],["^15",[415,"^?",["^ "],536880088]],["^15",[415,"^;","~u659d3f6d-4f79-432d-a125-e486915167da",536880088]],["^15",[416,"^Q","[Plus Minus](https://www.hackerrank.com/challenges/plus-minus/problem?isFullScreen=true)\nSimple loop, count and ratio.",536880091]],["^15",[416,"^O","^16",536880091]],["^15",[416,"^F",400,536880091]],["^15",[416,"^X",396,536880091]],["^15",[416,"^V",396,536880091]],["^15",[416,"^U",396,536880091]],["^15",[416,"^;","~u659d3f6e-d4d1-47c0-ac49-8c614e3d903f",536880091]],["^15",[417,"^Q","[Staricase](https://www.hackerrank.com/challenges/staircase/problem?isFullScreen=true)\n```cpp\nvoid compute()\n{\n    for (int i{}, spaces{n - 1}, hashes{1}; i < n; ++i, hashes = i + 1, spaces = n - hashes)\n    {\n      while (spaces-- > 0)\n      {\n        cout << \" \";\n      }\n      while (hashes-- > 0)\n      {\n        cout << \"#\";\n      }\n      cout << \"\\n\";\n    }\n  }\n```",536880091]],["^15",[417,"^O","^16",536880091]],["^15",[417,"^F",416,536880091]],["^15",[417,"^X",396,536880091]],["^15",[417,"^V",396,536880091]],["^15",[417,"^U",396,536880091]],["^15",[417,"^;","~u659d3f6e-1079-4080-b68b-0248068ad44c",536880091]],["^15",[418,"^Q","[Mini max Sum](https://www.hackerrank.com/challenges/mini-max-sum/problem?isFullScreen=true)\n```cpp\n  void compute()\n  {\n    int total{0};\n    int min_val{arr[0]};\n    int max_val{arr[0]};\n    for (int i{}; i < n; ++i)\n    {\n      total += arr[i];\n      min_val = min(arr[i], min_val);\n      max_val = max(arr[i], max_val);\n    }\n    min_sum = total - max_val;\n    max_sum = total - min_val;\n  }\n```",536880091]],["^15",[418,"^O","^16",536880091]],["^15",[418,"^F",417,536880091]],["^15",[418,"^X",396,536880091]],["^15",[418,"^V",396,536880091]],["^15",[418,"^U",396,536880091]],["^15",[418,"^;","~u659d3f6e-ea64-4135-8686-b57a3f2e85d0",536880091]],["^15",[419,"^Q","[Time Conversion](https://www.hackerrank.com/challenges/time-conversion/problem?isFullScreen=true)\n```cpp\n  void compute()\n  {\n    int hour{stoi(inp_time.substr(0, 2))};\n    if (inp_time[8] == 'A')\n    {\n      hour %= 12;\n      result = (hour / 10 < 1 ? \"0\" : \"\") + to_string(hour);\n    }\n    else\n    {\n\n      hour += 12;\n      hour %= 24;\n      result = hour == 0 ? \"12\" : to_string(hour);\n    }\n    result += inp_time.substr(2, 6);\n  }\n```",536880126]],["^15",[419,"^O","^16",536880111]],["^15",[419,"^@",false,536880111]],["^15",[419,"^F",401,536880111]],["^15",[419,"^X",396,536880111]],["^15",[419,"^V",396,536880111]],["^15",[419,"^U",396,536880112]],["^15",[419,"^;","~u659d3f93-8520-4778-b59a-5e644a69c86c",536880111]],["^15",[420,"^12",2,536880116]],["^15",[421,"^Q","[Between 2 sets](https://www.hackerrank.com/challenges/between-two-sets/problem)\n```cpp\n    int gcd(int a, int b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    int lcm(int a, int b)\n    {\n        return abs(a * b) / gcd(a, b);\n    }\n\n    void compute()\n    {\n        int a_lcm{a[0]};\n        int b_gcd{b[0]};\n\n        for (int i{}; i < n; ++i)\n        {\n            a_lcm = lcm(a_lcm, a[i]);\n        }\n        for (int i{}; i < m; ++i)\n        {\n            b_gcd = gcd(b_gcd, b[i]);\n        }        \n        if(b_gcd%a_lcm != 0) {\n            result=0;\n            return;\n        }\n\n        for (int i{a_lcm}; i <= b_gcd; i += a_lcm){\n            if(b_gcd%i == 0){\n                ++result;\n            }\n        }\n\n    }\n```\nWe need to find the count of distinct integers, such that for each integer x, all elements of array a must be a factor (divisor) of x. And all elements of array b must be divisible by x, or x should be a factor to all of them. For array a, we can find a number that shares its factors with all elements of a, that would be its [[LCM]], call it p, for array b we can find a number that divides all the numbers, that would be the [[GCD]], call it q. So we have an LCM, this is the smallest number divisible by all elements of a, and GCD, the greatest number that divides all of b. If ``p%q == 0`` (p divides q) then that means, p can be used to divide all the numbers of b, because q is a multiple of p, so we find the numbers between p and q that also divide q, so we check all multiples of p between p and q. \nFor ex.:\nFor the array ``a= [2,4]``\nFor the array ``b= [16,32, 96]``\nLCM of a = p = 4\nGCD of b = q = 16\n16%4=0, so there does exist atleast 2 integers that are factors of all elements of b, and have all elements of a as their factors.\n16/4 = 4, so there's 4 elements between 4 and 16 that can also be part of our result\nWe loop at all multiples of p, i.e., 4, so 4, 8, 12 and 16 and find out 4, 8, 16 satisfy that condition. \nAnswer: 3",536881163]],["^15",[421,"^O","^16",536880129]],["^15",[421,"^@",false,536880129]],["^15",[421,"^F",434,536880157]],["^15",[421,"^X",396,536880129]],["^15",[421,"^V",396,536880129]],["^15",[421,"^U",396,536880706]],["^15",[421,"^U",447,536880706]],["^15",[421,"^U",448,536880706]],["^15",[421,"^?",["^ "],536881163]],["^15",[421,"^H",447,536881163]],["^15",[421,"^H",448,536881163]],["^15",[421,"^;","~u659d6caf-9e11-492b-a29c-026a6b61a42a",536880129]],["^15",[422,"^12",2,536880134]],["^15",[423,"^K",1705298907059,536880135]],["^15",[423,"^O","^16",536880135]],["^15",[423,"^N",20240115,536880135]],["^15",[423,"^@",true,536880135]],["^15",[423,"^Y","15-01-2024",536880135]],["^15",[423,"^11","15-01-2024",536880135]],["^15",[423,"^B",1705298907059,536880135]],["^15",[423,"^;","~u65a4cbdb-160e-4feb-91c8-4f1a04a41db0",536880135]],["^15",[424,"^Q","",536880136]],["^15",[424,"^O","^16",536880136]],["^15",[424,"^N",20240115,536880136]],["^15",[424,"^@",true,536880136]],["^15",[424,"^F",423,536880136]],["^15",[424,"^X",423,536880136]],["^15",[424,"^V",423,536880136]],["^15",[424,"^U",423,536880137]],["^15",[424,"^?",["^ "],536880136]],["^15",[424,"^;","~u65a4cbdb-5f97-45a0-98b9-2ae74e13fded",536880136]],["^15",[425,"^Q","[Grading](https://www.hackerrank.com/challenges/grading/problem?isFullScreen=true)\n```cpp\n  void compute()\n  {\n    if (grade < 38)\n    {\n      result = grade;\n    }\n    else\n    {\n      int nm5 = grade + (5 - (grade + 5) % 5);\n      result = (nm5 - grade < 3) ? nm5 : grade;\n    }\n  }\n```",536880139]],["^15",[425,"^O","^16",536880139]],["^15",[425,"^F",419,536880139]],["^15",[425,"^X",396,536880139]],["^15",[425,"^V",396,536880139]],["^15",[425,"^U",396,536880139]],["^15",[425,"^;","~u65a4cbdc-71af-48e4-831d-da0f0b207315",536880139]],["^15",[426,"^12",2,536880142]],["^15",[427,"^K",1705945703002,536880143]],["^15",[427,"^O","^16",536880143]],["^15",[427,"^N",20240122,536880143]],["^15",[427,"^@",true,536880143]],["^15",[427,"^Y","22-01-2024",536880143]],["^15",[427,"^11","22-01-2024",536880143]],["^15",[427,"^B",1705945703002,536880143]],["^15",[427,"^;","~u65aeaa67-be71-4be4-bf58-cf926e3bd2bc",536880143]],["^15",[428,"^Q","",536880144]],["^15",[428,"^O","^16",536880144]],["^15",[428,"^N",20240122,536880144]],["^15",[428,"^@",true,536880144]],["^15",[428,"^F",427,536880144]],["^15",[428,"^X",427,536880144]],["^15",[428,"^V",427,536880144]],["^15",[428,"^U",427,536880145]],["^15",[428,"^?",["^ "],536880144]],["^15",[428,"^;","~u65aeaa67-f123-40a4-bfa4-078d01291013",536880144]],["^15",[429,"^Q","[Apples and Oranges](https://www.hackerrank.com/challenges/apple-and-orange/problem?isFullScreen=true)\n```cpp\n  void compute()\n  {\n    for (int i{}, sum_a{}; i < m; ++i)\n    {\n      sum_a = a + apples[i];\n      if (sum_a >= s && sum_a <= t)\n      {\n        ++count_apples;\n      }\n    }\n\n    for (int i{}, sum_o{}; i < n; ++i)\n    {\n      sum_o = b + oranges[i];\n      if (sum_o >= s && sum_o <= t)\n      {\n        ++count_oranges;\n      }\n    }\n  }\n```",536880147]],["^15",[429,"^O","^16",536880147]],["^15",[429,"^F",425,536880147]],["^15",[429,"^X",396,536880147]],["^15",[429,"^V",396,536880147]],["^15",[429,"^U",396,536880147]],["^15",[429,"^;","~u65aeaa68-c594-41ae-83aa-d6a167f463dc",536880147]],["^15",[430,"^12",2,536880150]],["^15",[431,"^12",2,536880152]],["^15",[432,"^K",1706704499241,536880153]],["^15",[432,"^[",435,536880160]],["^15",[432,"^O","^16",536880153]],["^15",[432,"^N",20240131,536880153]],["^15",[432,"^@",true,536880153]],["^15",[432,"^Y","31-01-2024",536880153]],["^15",[432,"^11","31-01-2024",536880153]],["^15",[432,"^B",1706707177070,536880466]],["^15",[432,"^;","~u65ba3e73-5a7e-428b-9d02-405fdb479509",536880153]],["^15",[433,"^Q","",536880466]],["^15",[433,"^O","^16",536880154]],["^15",[433,"^N",20240131,536880154]],["^15",[433,"^@",true,536880154]],["^15",[433,"^F",432,536880154]],["^15",[433,"^X",432,536880154]],["^15",[433,"^V",432,536880154]],["^15",[433,"^U",432,536880155]],["^15",[433,"^?",["^ "],536880466]],["^15",[433,"^;","~u65ba3e73-f426-46cf-b571-61e560f9407d",536880164]],["^15",[434,"^Q","$$x1 + y* v1 = x2+ y*v2 $$ Because y needs to be the same, it has to be the same number of hops.\n$$y* v1 - y*v2= x2-x1  $$\n$$y \\lparen v1 - v2 \\rparen = x2-x1  $$\n$$y = \\frac{x2-x1}{v1 - v2}  $$",536880157]],["^15",[434,"^O","^16",536880157]],["^15",[434,"^F",429,536880157]],["^15",[434,"^X",396,536880157]],["^15",[434,"^V",396,536880157]],["^15",[434,"^U",396,536880157]],["^15",[434,"^;","~u65ba3e74-5c50-45f0-a304-f72ba1e9ce25",536880157]],["^15",[435,"^3","-",536880468]],["^15",[435,"^19","~m1706707177193",536880467]],["^15",[435,"^Z","journals/2024_01_31.md",536880160]],["^15",[436,"^U",432,536880165]],["^15",[437,"^U",432,536880165]],["^15",[438,"^U",432,536880165]],["^15",[439,"^U",432,536880165]],["^15",[440,"^12",2,536880470]],["^15",[441,"^K",1707318959412,536880471]],["^15",[441,"^O","^16",536880471]],["^15",[441,"^N",20240207,536880471]],["^15",[441,"^@",true,536880471]],["^15",[441,"^Y","07-02-2024",536880471]],["^15",[441,"^11","07-02-2024",536880471]],["^15",[441,"^B",1707318959412,536880471]],["^15",[441,"^;","~u65c39eaf-0a3a-4ce9-b0b6-2489db8d79a1",536880471]],["^15",[442,"^Q","",536880472]],["^15",[442,"^O","^16",536880472]],["^15",[442,"^N",20240207,536880472]],["^15",[442,"^@",true,536880472]],["^15",[442,"^F",441,536880472]],["^15",[442,"^X",441,536880472]],["^15",[442,"^V",441,536880472]],["^15",[442,"^U",441,536880473]],["^15",[442,"^?",["^ "],536880472]],["^15",[442,"^;","~u65c39eaf-9d24-4d9d-960d-87354ae3aad0",536880472]],["^15",[443,"^12",2,536880475]],["^15",[444,"^K",1710783724507,536880476]],["^15",[444,"^O","^16",536880476]],["^15",[444,"^N",20240318,536880476]],["^15",[444,"^@",true,536880476]],["^15",[444,"^Y","18-03-2024",536880476]],["^15",[444,"^11","18-03-2024",536880476]],["^15",[444,"^B",1710783724507,536880476]],["^15",[444,"^;","~u65f87cec-969a-4b38-bb9f-45f62b371f5a",536880476]],["^15",[445,"^Q","",536880477]],["^15",[445,"^O","^16",536880477]],["^15",[445,"^N",20240318,536880477]],["^15",[445,"^@",true,536880477]],["^15",[445,"^F",444,536880477]],["^15",[445,"^X",444,536880477]],["^15",[445,"^V",444,536880477]],["^15",[445,"^U",444,536880478]],["^15",[445,"^?",["^ "],536880477]],["^15",[445,"^;","~u65f87cec-1adc-48a6-9793-11196a1bb1a1",536880477]],["^15",[447,"^K",1710784511307,536880683]],["^15",[447,"^@",false,536880683]],["^15",[447,"^Y","lcm",536880683]],["^15",[447,"^11","LCM",536880683]],["^15",[447,"^B",1710784511307,536880683]],["^15",[447,"^;","~u65f87fff-0e9f-4908-b77a-9588695eed56",536880683]],["^15",[448,"^K",1710784534925,536880705]],["^15",[448,"^@",false,536880705]],["^15",[448,"^Y","gcd",536880705]],["^15",[448,"^11","GCD",536880705]],["^15",[448,"^B",1710784534925,536880705]],["^15",[448,"^;","~u65f88016-e642-4966-a880-654f362706aa",536880705]],["^15",[449,"^Q","[Breaking Best and Worst Record](https://www.hackerrank.com/challenges/breaking-best-and-worst-records/problem)\n```cpp\n    void compute()\n    {\n        int max_elem{scores[0]};\n        int min_elem{scores[0]};\n\n        for (int i{1}, score{scores[1]}; i < n; ++i, score = scores[i])\n        {\n            if (score > max_elem)\n            {\n                max_elem = score;\n                ++max_breaks;\n            }\n            if (score < min_elem)\n            {\n                min_elem = score;\n                ++min_breaks;\n            }\n        }\n    }\n```\nWe simply track the min and max element and compare the current element with both, and increase their counts.",536881153]],["^15",[449,"^O","^16",536881097]],["^15",[449,"^@",false,536881097]],["^15",[449,"^F",421,536881097]],["^15",[449,"^X",396,536881097]],["^15",[449,"^V",396,536881097]],["^15",[449,"^U",396,536881098]],["^15",[449,"^?",["^ "],536881153]],["^15",[449,"^;","~u65f882e6-07a5-4c3f-853d-395c5c0f4052",536881097]],["^15",[450,"^K",1710786608734,536881103]],["^15",[450,"^O","^16",536881103]],["^15",[450,"^N",20240319,536881103]],["^15",[450,"^@",true,536881103]],["^15",[450,"^Y","19-03-2024",536881103]],["^15",[450,"^11","19-03-2024",536881103]],["^15",[450,"^B",1710786608734,536881103]],["^15",[450,"^;","~u65f88830-78bf-49dd-bf5c-67dbde838169",536881103]],["^15",[451,"^Q","",536881104]],["^15",[451,"^O","^16",536881104]],["^15",[451,"^N",20240319,536881104]],["^15",[451,"^@",true,536881104]],["^15",[451,"^F",450,536881104]],["^15",[451,"^X",450,536881104]],["^15",[451,"^V",450,536881104]],["^15",[451,"^U",450,536881105]],["^15",[451,"^?",["^ "],536881104]],["^15",[451,"^;","~u65f88830-684e-4644-9332-0527aa49abc0",536881104]],["^15",[452,"^Q","",536881117]],["^15",[452,"^O","^16",536881117]],["^15",[452,"^@",false,536881117]],["^15",[452,"^F",449,536881160]],["^15",[452,"^X",396,536881117]],["^15",[452,"^V",396,536881117]],["^15",[452,"^U",396,536881118]],["^15",[452,"^?",["^ "],536881160]],["^15",[452,"^;","~u65f89c60-72b0-498b-bfcf-2b1f3efea4ed",536881117]],["^15",[453,"^12",2,536881167]],["^15",[454,"^K",1711055850022,536881168]],["^15",[454,"^O","^16",536881168]],["^15",[454,"^N",20240322,536881168]],["^15",[454,"^@",true,536881168]],["^15",[454,"^Y","22-03-2024",536881168]],["^15",[454,"^11","22-03-2024",536881168]],["^15",[454,"^B",1711055850022,536881168]],["^15",[454,"^;","~u65fca3ea-ffd0-4a01-bebf-68d3dcefb7dc",536881168]],["^15",[455,"^Q","",536881169]],["^15",[455,"^O","^16",536881169]],["^15",[455,"^N",20240322,536881169]],["^15",[455,"^@",true,536881169]],["^15",[455,"^F",454,536881169]],["^15",[455,"^X",454,536881169]],["^15",[455,"^V",454,536881169]],["^15",[455,"^U",454,536881170]],["^15",[455,"^?",["^ "],536881169]],["^15",[455,"^;","~u65fca3ea-537f-4b84-b488-a12b140e5479",536881169]]]]]]