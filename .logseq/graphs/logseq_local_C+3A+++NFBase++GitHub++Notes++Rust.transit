["~#datascript/DB",["^ ","~:schema",["^ ","~:ast/version",["^ "],"~:file/content",["^ "],"~:block/properties-text-values",["^ "],"~:block/alias",["^ ","~:db/valueType","~:db.type/ref","~:db/cardinality","~:db.cardinality/many"],"~:block/pre-block?",["^ "],"~:block/uuid",["^ ","~:db/unique","~:db.unique/identity"],"~:block/priority",["^ "],"~:block/properties",["^ "],"~:block/journal?",["^ "],"~:block/namespace",["^ ","^6","^7"],"~:block/updated-at",["^ "],"~:block/repeated?",["^ "],"~:db/type",["^ "],"~:file/handle",["^ "],"~:block/left",["^ ","^6","^7","~:db/index",true],"~:block/refs",["^ ","^6","^7","^8","^9"],"~:block/scheduled",["^ "],"~:block/properties-order",["^ "],"~:block/created-at",["^ "],"~:block/deadline",["^ "],"~:block/collapsed?",["^ ","^G",true],"~:block/journal-day",["^ "],"~:block/format",["^ "],"~:block/tags",["^ ","^6","^7","^8","^9"],"~:block/content",["^ "],"~:recent/pages",["^ "],"~:block/macros",["^ ","^6","^7","^8","^9"],"~:db/ident",["^ ","^<","^="],"~:block/path-refs",["^ ","^6","^7","^8","^9"],"~:block/parent",["^ ","^6","^7","^G",true],"~:block/type",["^ "],"~:block/page",["^ ","^6","^7","^G",true],"~:block/name",["^ ","^<","^="],"~:file/path",["^ ","^<","^="],"~:block/file",["^ ","^6","^7"],"~:block/marker",["^ "],"~:block/original-name",["^ ","^<","^="],"~:schema/version",["^ "]],"~:datoms",["~#list",[["~#datascript/Datom",[1,"^12",2,536870913]],["^15",[2,"^@",false,536870914]],["^15",[2,"^Y","card",536870913]],["^15",[2,"^11","card",536870913]],["^15",[2,"^;","~u221cef02-e7c9-48be-9973-bc9a02f58144",536926324]],["^15",[3,"^@",false,536870914]],["^15",[3,"^Y","canceled",536870914]],["^15",[3,"^11","CANCELED",536870914]],["^15",[3,"^;","~u4e243da6-6ec3-49d6-aa7b-b3f828ff77c0",536926324]],["^15",[4,"^@",false,536870914]],["^15",[4,"^Y","todo",536870914]],["^15",[4,"^11","TODO",536870914]],["^15",[4,"^;","~ud8c13c7c-ad61-46d7-a5cd-2767e3aa8e16",536926324]],["^15",[5,"^O","~:markdown",536870975]],["^15",[5,"^@",false,536870914]],["^15",[5,"^Y","now",536870914]],["^15",[5,"^11","NOW",536870914]],["^15",[5,"^;","~u242feca3-0944-49b5-b045-b3674a74e7dd",536926324]],["^15",[6,"^@",false,536870914]],["^15",[6,"^Y","later",536870914]],["^15",[6,"^11","LATER",536870914]],["^15",[6,"^;","~ude504c46-6466-45c2-bba2-0d3ab359cc91",536926324]],["^15",[7,"^@",false,536870914]],["^15",[7,"^Y","done",536870914]],["^15",[7,"^11","DONE",536870914]],["^15",[7,"^;","~ua8890d68-dd0f-4bdf-b4be-7cb86f1220d9",536926324]],["^15",[8,"^@",false,536870914]],["^15",[8,"^Y","doing",536870914]],["^15",[8,"^11","DOING",536870914]],["^15",[8,"^;","~u4b7ec523-9739-4e5a-88fe-e0f41f0a76f6",536926324]],["^15",[9,"^@",false,536870914]],["^15",[9,"^Y","in-progress",536870914]],["^15",[9,"^11","IN-PROGRESS",536870914]],["^15",[9,"^;","~ubec85211-f545-4a24-82fb-c63cf436678b",536926324]],["^15",[10,"^@",false,536870914]],["^15",[10,"^Y","c",536870914]],["^15",[10,"^11","C",536870914]],["^15",[10,"^;","~uea2c9041-d6c8-4740-bb19-5d76b412eb35",536926324]],["^15",[11,"^@",false,536870914]],["^15",[11,"^Y","b",536870914]],["^15",[11,"^11","B",536870914]],["^15",[11,"^;","~u2630ed22-e395-4c45-bd04-ac0e3fde562e",536926324]],["^15",[12,"^K",1688829099074,536870940]],["^15",[12,"^[",22,536870924]],["^15",[12,"^@",false,536870914]],["^15",[12,"^Y","contents",536870914]],["^15",[12,"^11","Contents",536870914]],["^15",[12,"^B",1690895722329,536921542]],["^15",[12,"^;","~u8622a146-3aba-480c-b709-d9e6445a1535",536926324]],["^15",[13,"^@",false,536870914]],["^15",[13,"^Y","waiting",536870914]],["^15",[13,"^11","WAITING",536870914]],["^15",[13,"^;","~u0dcc0acc-5041-4875-8180-9b3ed384ccd4",536926324]],["^15",[14,"^@",false,536870914]],["^15",[14,"^Y","favorites",536870914]],["^15",[14,"^11","Favorites",536870914]],["^15",[14,"^;","~u98c58adb-0ad2-4cbe-b5cf-389d19bfdc72",536926324]],["^15",[15,"^@",false,536870914]],["^15",[15,"^Y","a",536870914]],["^15",[15,"^11","A",536870914]],["^15",[15,"^;","~uf0898978-95f8-455f-ae3c-135edded1729",536926324]],["^15",[16,"^@",false,536870914]],["^15",[16,"^Y","cancelled",536870914]],["^15",[16,"^11","CANCELLED",536870914]],["^15",[16,"^;","~u26524e2b-c7f6-47b6-85cf-db7300d74045",536926324]],["^15",[17,"^@",false,536870914]],["^15",[17,"^Y","wait",536870914]],["^15",[17,"^11","WAIT",536870914]],["^15",[17,"^;","~u30c8041d-8f5e-46bd-adf6-dbb36e6db08d",536926324]],["^15",[18,"^2",1,536870915]],["^15",[18,"^T","^2",536870915]],["^15",[20,"^Q","",536870936]],["^15",[20,"^O","^16",536870917]],["^15",[20,"^N",20230708,536870917]],["^15",[20,"^@",true,536870917]],["^15",[20,"^?",["^ "],536870936]],["^15",[20,"~:block/unordered",true,536870917]],["^15",[20,"^;","~u64a97c8a-0701-43a9-9433-bbef98eeea84",536870917]],["^15",[21,"^3","{:meta/version 1\n\n ;; Set the preferred format.\n ;; Available options:\n ;; - Markdown (default)\n ;; - Org\n ;; :preferred-format \"Markdown\"\n\n ;; Set the preferred workflow style.\n ;; Available options:\n ;; - :now for NOW/LATER style (default)\n ;; - :todo for TODO/DOING style\n :preferred-workflow :now\n\n ;; Exclude directories/files.\n ;; Example usage:\n ;; :hidden [\"/archived\" \"/test.md\" \"../assets/archived\"]\n :hidden []\n\n ;; Define the default journal page template.\n ;; Enter the template name between the quotes.\n :default-templates\n {:journals \"\"}\n\n ;; Set a custom date format for the journal page title.\n ;; Default value: \"MMM do, yyyy\"\n ;; e.g., \"Jan 19th, 2038\"\n ;; Example usage e.g., \"Tue 19th, Jan 2038\"\n ;; :journal/page-title-format \"EEE do, MMM yyyy\"\n\n ;; Specify the journal filename format using a valid date format string.\n ;; !Warning:\n ;;   This configuration is not retroactive and affects only new journals.\n ;;   To show old journal files in the app, manually rename the files in the\n ;;   journal directory to match the new format.\n ;; Default value: \"yyyy_MM_dd\"\n ;; :journal/file-name-format \"yyyy_MM_dd\"\n\n ;; Enable tooltip preview on hover.\n ;; Default value: true\n :ui/enable-tooltip? true\n\n ;; Display brackets [[]] around page references.\n ;; Default value: true\n ;; :ui/show-brackets? true\n\n ;; Display all lines of a block when referencing ((block)).\n ;; Default value: false\n :ui/show-full-blocks? false\n\n ;; Automatically expand block references when zooming in.\n ;; Default value: true\n :ui/auto-expand-block-refs? true\n\n ;; Enable Block timestamps.\n ;; Default value: false\n :feature/enable-block-timestamps? false\n\n ;; Disable accent marks when searching.\n ;; After changing this setting, rebuild the search index by pressing (^C ^S).\n ;; Default value: true\n :feature/enable-search-remove-accents? true\n\n ;; Enable journals.\n ;; Default value: true\n ;; :feature/enable-journals? true\n\n ;; Enable flashcards.\n ;; Default value: true\n ;; :feature/enable-flashcards? true\n\n ;; Enable whiteboards.\n ;; Default value: true\n ;; :feature/enable-whiteboards? true\n\n ;; Disable the journal's built-in 'Scheduled tasks and deadlines' query.\n ;; Default value: false\n ;; :feature/disable-scheduled-and-deadline-query? false\n\n ;; Specify the number of days displayed in the future for\n ;; the 'scheduled tasks and deadlines' query.\n ;; Example usage:\n ;; Display all scheduled and deadline blocks for the next 14 days:\n ;; :scheduled/future-days 14\n ;; Default value: 7\n ;; :scheduled/future-days 7\n\n ;; Specify the first day of the week.\n ;; Available options:\n ;;  - integer from 0 to 6 (Monday to Sunday)\n ;; Default value: 6 (Sunday)\n :start-of-week 6\n\n ;; Specify a custom CSS import.\n ;; This option takes precedence over the local `logseq/custom.css` file.\n ;; Example usage:\n ;; :custom-css-url \"@import url('https://cdn.jsdelivr.net/gh/dracula/logseq@master/custom.css');\"\n\n ;; Specify a custom JS import.\n ;; This option takes precedence over the local `logseq/custom.js` file.\n ;; Example usage:\n ;; :custom-js-url \"https://cdn.logseq.com/custom.js\"\n\n ;; Set a custom Arweave gateway\n ;; Default gateway: https://arweave.net\n ;; :arweave/gateway \"https://arweave.net\"\n\n ;; Set bullet indentation when exporting\n ;; Available options:\n ;;  - `:eight-spaces` as eight spaces\n ;;  - `:four-spaces` as four spaces\n ;;  - `:two-spaces` as two spaces\n ;;  - `:tab` as a tab character (default)\n ;; :export/bullet-indentation :tab\n\n ;; Publish all pages within the Graph\n ;; Regardless of whether individual pages have been marked as public.\n ;; Default value: false\n ;; :publishing/all-pages-public? false\n\n ;; Define the default home page and sidebar status.\n ;; If unspecified, the journal page will be loaded on startup and the right sidebar will stay hidden.\n ;; The `:page` value represents the name of the page displayed at startup.\n ;; Available options for `:sidebar` are:\n ;; - \"Contents\" to display the Contents page in the right sidebar.\n ;; - A specific page name to display in the right sidebar.\n ;; - An array of multiple pages, e.g., [\"Contents\" \"Page A\" \"Page B\"].\n ;; If `:sidebar` remains unset, the right sidebar will stay hidden.\n ;; Examples:\n ;; 1. Set \"Changelog\" as the home page and display \"Contents\" in the right sidebar:\n ;; :default-home {:page \"Changelog\", :sidebar \"Contents\"}\n ;; 2. Set \"Jun 3rd, 2021\" as the home page without the right sidebar:\n ;; :default-home {:page \"Jun 3rd, 2021\"}\n ;; 3. Set \"home\" as the home page and display multiple pages in the right sidebar:\n ;; :default-home {:page \"home\", :sidebar [\"Page A\" \"Page B\"]}\n\n ;; Set the default location for storing notes.\n ;; Default value: \"pages\"\n ;; :pages-directory \"pages\"\n\n ;; Set the default location for storing journals.\n ;; Default value: \"journals\"\n ;; :journals-directory \"journals\"\n\n ;; Set the default location for storing whiteboards.\n ;; Default value: \"whiteboards\"\n ;; :whiteboards-directory \"whiteboards\"\n\n ;; Enabling this option converts\n ;; [[Grant Ideas]] to [[file:./grant_ideas.org][Grant Ideas]] for org-mode.\n ;; For more information, visit https://github.com/logseq/logseq/issues/672\n ;; :org-mode/insert-file-link? false\n\n ;; Configure custom shortcuts.\n ;; Syntax:\n ;; 1. + indicates simultaneous key presses, e.g., `Ctrl+Shift+a`.\n ;; 2. A space between keys represents key chords, e.g., `t s` means\n ;;    pressing `t` followed by `s`.\n ;; 3. mod refers to `Ctrl` for Windows/Linux and `Command` for Mac.\n ;; 4. Use false to disable a specific shortcut.\n ;; 5. You can define multiple bindings for a single action, e.g., [\"ctrl+j\" \"down\"].\n ;; The full list of configurable shortcuts is available at:\n ;; https://github.com/logseq/logseq/blob/master/src/main/frontend/modules/shortcut/config.cljs\n ;; Example:\n ;; :shortcuts\n ;; {:editor/new-block       \"enter\"\n ;;  :editor/new-line        \"shift+enter\"\n ;;  :editor/insert-link     \"mod+shift+k\"\n ;;  :editor/highlight       false\n ;;  :ui/toggle-settings     \"t s\"\n ;;  :editor/up              [\"ctrl+k\" \"up\"]\n ;;  :editor/down            [\"ctrl+j\" \"down\"]\n ;;  :editor/left            [\"ctrl+h\" \"left\"]\n ;;  :editor/right           [\"ctrl+l\" \"right\"]}\n :shortcuts {}\n\n ;; Configure the behavior of pressing Enter in document mode.\n ;; if set to true, pressing Enter will create a new block.\n ;; Default value: false\n :shortcut/doc-mode-enter-for-new-block? false\n\n ;; Block content larger than `block/content-max-length` will not be searchable\n ;; or editable for performance.\n ;; Default value: 10000\n :block/content-max-length 10000\n\n ;; Display command documentation on hover.\n ;; Default value: true\n :ui/show-command-doc? true\n\n ;; Display empty bullet points.\n ;; Default value: false\n :ui/show-empty-bullets? false\n\n ;; Pre-defined :view function to use with advanced queries.\n :query/views\n {:pprint\n  (fn [r] [:pre.code (pprint r)])}\n\n ;; Advanced queries `:result-transform` function.\n ;; Transform the query result before displaying it.\n :query/result-transforms\n {:sort-by-priority\n  (fn [result] (sort-by (fn [h] (get h :block/priority \"Z\")) result))}\n\n ;; The following queries will be displayed at the bottom of today's journal page.\n ;; The \"NOW\" query returns tasks with \"NOW\" or \"DOING\" status.\n ;; The \"NEXT\" query returns tasks with \"NOW\", \"LATER\", or \"TODO\" status.\n :default-queries\n {:journals\n  [{:title \"🔨 NOW\"\n    :query [:find (pull ?h [*])\n            :in $ ?start ?today\n            :where\n            [?h :block/marker ?marker]\n            [(contains? #{\"NOW\" \"DOING\"} ?marker)]\n            [?h :block/page ?p]\n            [?p :block/journal? true]\n            [?p :block/journal-day ?d]\n            [(>= ?d ?start)]\n            [(<= ?d ?today)]]\n    :inputs [:14d :today]\n    :result-transform (fn [result]\n                        (sort-by (fn [h]\n                                   (get h :block/priority \"Z\")) result))\n    :group-by-page? false\n    :collapsed? false}\n   {:title \"📅 NEXT\"\n    :query [:find (pull ?h [*])\n            :in $ ?start ?next\n            :where\n            [?h :block/marker ?marker]\n            [(contains? #{\"NOW\" \"LATER\" \"TODO\"} ?marker)]\n            [?h :block/page ?p]\n            [?p :block/journal? true]\n            [?p :block/journal-day ?d]\n            [(> ?d ?start)]\n            [(< ?d ?next)]]\n    :inputs [:today :7d-after]\n    :group-by-page? false\n    :collapsed? false}]}\n\n ;; Add custom commands to the command palette\n ;; Example usage:\n ;; :commands\n ;; [\n ;;  [\"js\" \"Javascript\"]\n ;;  [\"md\" \"Markdown\"]\n ;;  ]\n :commands []\n\n ;; Enable collapsing blocks with titles but no children.\n ;; By default, only blocks with children can be collapsed.\n ;; Setting `:outliner/block-title-collapse-enabled?` to true allows collapsing\n ;; blocks with titles (multiple lines) and content. For example:\n ;; - block title\n ;;   block content\n ;; Default value: false\n :outliner/block-title-collapse-enabled? false\n\n ;; Macros replace texts and will make you more productive.\n ;; Example usage:\n ;; Change the :macros value below to:\n ;; {\"poem\" \"Rose is $1, violet's $2. Life's ordered: Org assists you.\"}\n ;; input \"{{poem red,blue}}\"\n ;; becomes\n ;; Rose is red, violet's blue. Life's ordered: Org assists you.\n :macros {}\n\n ;; Configure the default expansion level for linked references.\n ;; For example, consider the following block hierarchy:\n ;; - a [[page]] (level 1)\n ;;   - b        (level 2)\n ;;     - c      (level 3)\n ;;       - d    (level 4)\n ;;\n ;; With the default value of level 2, block b will be collapsed.\n ;; If the level's value is set to 3, block c will be collapsed.\n ;; Default value: 2\n :ref/default-open-blocks-level 2\n\n ;; Configure the threshold for linked references before collapsing.\n ;; Default value: 100\n :ref/linked-references-collapsed-threshold 50\n\n ;; Graph view configuration.\n ;; Example usage:\n ;; :graph/settings\n ;; {:orphan-pages?   true   ; Default value: true\n ;;  :builtin-pages?  false  ; Default value: false\n ;;  :excluded-pages? false  ; Default value: false\n ;;  :journal?        false} ; Default value: false\n\n ;; Favorites to list on the left sidebar\n :favorites [\"Rust\" \"Contents\"]\n\n ;; Set flashcards interval.\n ;; Expected value:\n ;; - Float between 0 and 1\n ;; higher values result in faster changes to the next review interval.\n ;; Default value: 0.5\n ;; :srs/learning-fraction 0.5\n\n ;; Set the initial interval after the first successful review of a card.\n ;; Default value: 4\n ;; :srs/initial-interval 4\n\n ;; Hide specific block properties.\n ;; Example usage:\n ;; :block-hidden-properties #{:public :icon}\n\n ;; Create a page for all properties.\n ;; Default value: true\n :property-pages/enabled? true\n\n ;; Properties to exclude from having property pages\n ;; Example usage:\n ;; :property-pages/excludelist #{:duration :author}\n\n ;; By default, property value separated by commas will not be treated as\n ;; page references. You can add properties to enable it.\n ;; Example usage:\n ;; :property/separated-by-commas #{:alias :tags}\n\n ;; Properties that are ignored when parsing property values for references\n ;; Example usage:\n ;; :ignored-page-references-keywords #{:author :website}\n\n ;; logbook configuration.\n ;; :logbook/settings\n ;; {:with-second-support? false ;limit logbook to minutes, seconds will be eliminated\n ;;  :enabled-in-all-blocks true ;display logbook in all blocks after timetracking\n ;;  :enabled-in-timestamped-blocks false ;don't display logbook at all\n ;; }\n\n ;; Mobile photo upload configuration.\n ;; :mobile/photo\n ;; {:allow-editing? true\n ;;  :quality        80}\n\n ;; Mobile features options\n ;; Gestures\n ;; Example usage:\n ;; :mobile\n ;; {:gestures/disabled-in-block-with-tags [\"kanban\"]}\n\n ;; Extra CodeMirror options\n ;; See https://codemirror.net/5/doc/manual.html#config for possible options\n ;; Example usage:\n ;; :editor/extra-codemirror-options\n ;; {:lineWrapping  false  ; Default value: false\n ;;  :lineNumbers   true   ; Default value: true\n ;;  :readOnly      false} ; Default value: false\n\n ;; Enable logical outdenting\n ;; Default value: false\n ;; :editor/logical-outdenting? false\n\n ;; Prefer pasting the file when text and a file are in the clipboard.\n ;; Default value: false\n ;; :editor/preferred-pasting-file? false\n\n ;; Quick capture templates for receiving content from other apps.\n ;; Each template contains three elements {time}, {text} and {url}, which can be auto-expanded\n ;; by receiving content from other apps. Note: the {} cannot be omitted.\n ;; - {time}: capture time\n ;; - {date}: capture date using current date format, use `[[{date}]]` to get a page reference\n ;; - {text}: text that users selected before sharing.\n ;; - {url}: URL or assets path for media files stored in Logseq.\n ;; You can also reorder them or use only one or two of them in the template.\n ;; You can also insert or format any text in the template, as shown in the following examples.\n ;; :quick-capture-templates\n ;; {:text \"[[quick capture]] **{time}**: {text} from {url}\"\n ;;  :media \"[[quick capture]] **{time}**: {url}\"}\n\n ;; Quick capture options.\n ;; - insert-today?   Insert the capture at the end of today's journal page (boolean).\n ;; - redirect-page?  Redirect to the quick capture page after capturing (boolean).\n ;; - default-page    The default page to capture to if insert-today? is false (string).\n ;; :quick-capture-options\n ;; {:insert-today? false           ;; Default value: true\n ;;  :redirect-page? false          ;; Default value: false\n ;;  :default-page \"quick capture\"} ;; Default page: \"quick capture\"\n\n ;; File sync options\n ;; Ignore these files when syncing, regexp is supported.\n ;; :file-sync/ignore-files []\n\n ;; Configure the Enter key behavior for\n ;; context-aware editing with DWIM (Do What I Mean).\n ;; context-aware Enter key behavior implies that pressing Enter will\n ;; have different outcomes based on the context.\n ;; For instance, pressing Enter within a list generates a new list item,\n ;; whereas pressing Enter in a block reference opens the referenced block.\n ;; :dwim/settings\n ;; {:admonition&src?  true        ;; Default value: true\n ;;  :markup?          false       ;; Default value: false\n ;;  :block-ref?       true        ;; Default value: true\n ;;  :page-ref?        true        ;; Default value: true\n ;;  :properties?      true        ;; Default value: true\n ;;  :list?            false}      ;; Default value: false\n\n ;; Configure the escaping method for special characters in page titles.\n ;; Warning:\n ;;   This is a dangerous operation. To modify the setting,\n ;;   access the 'Filename format' setting and follow the instructions.\n ;;   Otherwise, You may need to manually rename all affected files and\n ;;   re-index them on all clients after synchronization.\n ;;   Incorrect handling may result in messy page titles.\n ;; Available options:\n ;;   - :triple-lowbar (default)\n ;;      ;use triple underscore `___` for slash `/` in page title\n ;;      ;use Percent-encoding for other invalid characters\n :file/name-format :triple-lowbar\n}\n",536892279]],["^15",[21,"~:file/last-modified-at","~m1689508940418",536892280]],["^15",[21,"^Z","logseq/config.edn",536870919]],["^15",[22,"^3","- [[Rust]]\n  ![image.png](../assets/image_1688829102595_0.png){:height 352, :width 433}\n  \n  Last Major Update: [[Jul 8th, 2023]] \n  Major Version: v1.70\n- Useful Links:\n  * Primary Book: [Rust Docs Book](https://doc.rust-lang.org/book/)\n  * Secondary Book: [Rust Docs Reference](https://doc.rust-lang.org/reference/index.html)\n  * Unsafe Rust Handbook: [Rust Nomicon](https://doc.rust-lang.org/nomicon/index.html)\n  * Async Book: [Rust Github Async Book](https://rust-lang.github.io/async-book/)",536921544]],["^15",[22,"^18","~m1690895722424",536921545]],["^15",[22,"^Z","pages/contents.md",536870922]],["^15",[23,"^Q","[[Rust]]\n![image.png](../assets/image_1688829102595_0.png){:height 352, :width 433}\n\nLast Major Update: [[Jul 8th, 2023]] \nMajor Version: v1.70",536908114]],["^15",[23,"^O","^16",536870924]],["^15",[23,"^F",12,536870924]],["^15",[23,"^X",12,536870924]],["^15",[23,"^V",12,536870924]],["^15",[23,"^U",12,536871063]],["^15",[23,"^U",28,536871063]],["^15",[23,"^U",35,536871063]],["^15",[23,"^H",28,536908114]],["^15",[23,"^H",35,536908114]],["^15",[23,"^17",true,536870924]],["^15",[23,"^;","~u64a97c8a-5a63-4aac-87e6-60e6f66f6755",536870924]],["^15",[24,"^3",":theme\n{:custom-css\n\".block-content { margin-bottom: 20px; }\"}\n",536892282]],["^15",[24,"^18","~m1689508958685",536892283]],["^15",[24,"^Z","logseq/custom.css",536870925]],["^15",[25,"^12",2,536870931]],["^15",[26,"^3","-",536870938]],["^15",[26,"^18","~m1688829091418",536870937]],["^15",[26,"^Z","journals/2023_07_08.md",536870933]],["^15",[27,"^T","^R",536870939]],["^15",[27,"^R",["^14",["string","unwrap","Option Type","error","dynamically sized type","String","rust","loop","contents","variable","cargo","module system","module","crate","testing framework"]],536926318]],["^15",[28,"^K",1688829099074,536870940]],["^15",[28,"^[",33,536871000]],["^15",[28,"^O","^16",536870995]],["^15",[28,"^@",false,536870940]],["^15",[28,"^Y","rust",536870940]],["^15",[28,"^11","Rust",536870940]],["^15",[28,"^B",1698414511318,536926188]],["^15",[28,"^;","~u64c20233-79e2-4a19-8691-683a1ed22fb8",536916343]],["^15",[29,"^Q","",536870976]],["^15",[29,"^O","^16",536870976]],["^15",[29,"^@",false,536870976]],["^15",[29,"^F",5,536870976]],["^15",[29,"^X",5,536870976]],["^15",[29,"^V",5,536870976]],["^15",[29,"^U",5,536870977]],["^15",[29,"^?",["^ "],536870976]],["^15",[29,"^17",true,536870976]],["^15",[29,"^;","~u64a97cd0-0fdc-4793-aa81-551e9002179c",536870976]],["^15",[31,"^Q","",536870992]],["^15",[31,"^O","^16",536870992]],["^15",[31,"^N",20220708,536870992]],["^15",[31,"^@",true,536870992]],["^15",[31,"^?",["^ "],536870992]],["^15",[31,"^17",true,536870992]],["^15",[31,"^;","~u64a97ce6-4e30-47be-8df9-5878ba5424d3",536870992]],["^15",[32,"^Q","Fast, multi-threaded, type-safe & memory efficient language that eliminates most bugs at compile-time. It also bridges the gap between a low-level language and a high-level language with its compiler. Uses [[rustup]] to maintain versions on platforms and [[cargo]] which is its package manager. \n\nIts mascot is called *Ferris*, a red crusty crab and its users, *Rustaceans*.",536926188]],["^15",[32,"^O","^16",536870996]],["^15",[32,"^@",false,536870996]],["^15",[32,"^F",28,536870996]],["^15",[32,"^X",28,536870996]],["^15",[32,"^V",28,536870996]],["^15",[32,"^U",28,536880191]],["^15",[32,"^U",45,536880191]],["^15",[32,"^U",432,536880191]],["^15",[32,"^?",["^ "],536926188]],["^15",[32,"^H",45,536926188]],["^15",[32,"^H",432,536926188]],["^15",[32,"^17",true,536870996]],["^15",[32,"^;","~u64a97cfa-5bcf-4dd9-887e-2911d20007c1",536870996]],["^15",[33,"^3","- Fast, multi-threaded, type-safe & memory efficient language that eliminates most bugs at compile-time. It also bridges the gap between a low-level language and a high-level language with its compiler. Uses [[rustup]] to maintain versions on platforms and [[cargo]] which is its package manager. \n  \n  Its mascot is called *Ferris*, a red crusty crab and its users, *Rustaceans*.\n- [[Default Linter Rule]]\n- Lines need to be ended with ;\n- Rust files end in the extension ``.rs``\n- Install rust by installing [[rustup]], here's a quick reference [docs book](https://doc.rust-lang.org/book/ch01-01-installation.html).\n- [[rustup]] also introduces [[Cargo]]: Rust's Package manager, [[rustc]]: Rust's compiler and [[rustup]] itself which manages the updating of both. These are all available to the CLI, but if not, add them to the PATH as they are executables. \n  \n  The ``rls`` (Rust Language Server) and ``rust-analyzer`` (Provides implementation of the rls) are generally automatically installed with rustup, but if they are not (resulting in failed code-completion etc.) we can manually install them with \n  ``rustup component add rls`` and ``rustup component add rust-analyzer``\n- A rust project needs a [[cargo.toml]] file at the bare minimum.\n- Main Entrypoint to any Rust executable\n  ``fn main() {…}``\n- [[Variable]]\n- [[Expression]]\n- Statements vs Expressions\n  Statements are instructions that perform some actions and don’t return a value. Expressions are the same but return a value. [[Function]]s definitions in Rust are statements. But calling a function is an \n   expression. This distinction is not as visible in other languages but in rust,\n  ```rust\n  let x = (let y = 6); \n  ```\n  is an error as ‘let’ is a statement and hence doesn’t return anything. \n  However, a custom [[Scope]] block is an expression. Every scope block in Rust returns something.\n  \n  For ex.:\n  ```rust\n  let y = {\n   let x= 1;\n   x+1 //Here x+1 is an expression, as it is evaluated then the value is being returned\n  }; //Note the semicolon, it is required for custom scope blocks which need to return a value\n  println!(“{}”,y); //prints 2\n  ```\n- [[Comment]]\n- [[Control Flow]]\n- [[Struct]]\n- [[Module System]]\n- [[Testing Framework]]\n- Reading environment args and environment variables\n  To do so,\n  ```rust\n  use std::env;\n  \n  fn main() {\n  let values: Vec<String>= env::args().collect();\n  //puts env args as String objects into values.\n  let val= env::var(\"MYENV_VAR\");\n  let isOk= val.is_ok(); \n  //reads the given env var and returns Result in val. .is_ok() returns true if the Result is Ok().\n  \n  }\n  ```\n  To pass env args,\n  \n  ``cargo run arg1 arg2``to [[Cargo]]. \n  \n  Sometimes env args can fail due to Unicode issues. To solve that we can use ``.args_os()`` instead, this returns values of ``OsString`` [[Data Type]].\n- [[File]]\n- *Functional Programming*\n  Rust borrows some concepts from FP languages. An FP language generally\n  sees [[Function]]s as values.\n  These concepts in Rust are similar to what FP languages have.\n  * [[Closure]]\n  * [[Iterator]]\n- [[Concurrency or Parallelism]]\n- *Object Oriented Programming*\n  Rust isn't strictly OOP in the sense languages like *C++* are. Instead, it focuses on bringing all important aspects from OOP languages. By definition, OOP languages should provide *objects* that are packages of data and methods, and the methods operate on said data in their own packages. Rust does this using ``impl`` blocks and [[Struct]]/ [[Enum]]s. Encapsulation is handled through [[Access Modifier]]s.\n  Inheritance isn't wholly used, but it's most important aspects, abstract classes, which is done using [[Trait]]s and their implementers, and Polymorphism where an abstract type is used and at runtime replaced with a more concrete type, which is handled through [[Trait Object]]s, are covered.\n- *Raw Identifier*s\n  Rust allows naming items such as [[Function]]s, [[Variable]]s etc. with the same name as keywords, but requires a special prefix to be used, ``r#``. This is applied to both the definition and the call-site.\n  \n  For ex.:\n  ```rust\n  fn r#match(){}\n  \n  fn yo() {}\n  \n  fn main() {\n   r#match(); //works\n   r#yo(); //also works\n  }\n  ```\n  \n  The benefit is that even if the definition isn't using ``r#``, the call-site would still work. It would call the ``r#`` version and if it doesn't exist, it'd call the normal version. Both can't be defined together in the same [[Scope]] so there's no ambiguity to which one will be called.\n-",536926190]],["^15",[33,"^18","~m1698414511783",536926189]],["^15",[33,"^Z","pages/Rust.md",536871000]],["^15",[34,"^Q","Useful Links:\n* Primary Book: [Rust Docs Book](https://doc.rust-lang.org/book/)\n* Secondary Book: [Rust Docs Reference](https://doc.rust-lang.org/reference/index.html)\n* Unsafe Rust Handbook: [Rust Nomicon](https://doc.rust-lang.org/nomicon/index.html)\n* Async Book: [Rust Github Async Book](https://rust-lang.github.io/async-book/)",536921542]],["^15",[34,"^O","^16",536871013]],["^15",[34,"^F",23,536871013]],["^15",[34,"^X",12,536871013]],["^15",[34,"^V",12,536871013]],["^15",[34,"^U",12,536871014]],["^15",[34,"^?",["^ "],536921542]],["^15",[34,"^17",true,536871013]],["^15",[34,"^;","~u64a97d2c-80dd-414a-82b2-8978557eaa52",536871013]],["^15",[35,"^K",1688829274120,536871062]],["^15",[35,"^N",20230708,536871062]],["^15",[35,"^@",true,536871062]],["^15",[35,"^Y","jul 8th, 2023",536871062]],["^15",[35,"^11","Jul 8th, 2023",536871062]],["^15",[35,"^B",1688829274120,536871062]],["^15",[35,"^;","~u64bbdc0c-0b65-41d9-8fc4-e490379ac477",536908114]],["^15",[36,"^Q","[[Default Linter Rule]]",536916343]],["^15",[36,"^O","^16",536871067]],["^15",[36,"^@",false,536871067]],["^15",[36,"^F",32,536871067]],["^15",[36,"^X",28,536871067]],["^15",[36,"^V",28,536871067]],["^15",[36,"^U",28,536871072]],["^15",[36,"^U",37,536871072]],["^15",[36,"^U",1029,536916343]],["^15",[36,"^H",1029,536916343]],["^15",[36,"^17",true,536871067]],["^15",[36,"^;","~u64a97d69-8f1f-4887-89b8-78b3c6de9439",536871067]],["^15",[37,"^K",1688829297728,536871071]],["^15",[37,"^O","^16",536871075]],["^15",[37,"^@",false,536871071]],["^15",[37,"^Y","default linter rules",536871071]],["^15",[37,"^11","Default Linter Rules",536871071]],["^15",[37,"^B",1689513712697,536894130]],["^15",[37,"^;","~u64bbdc0d-347c-4390-88ab-745374197e94",536908132]],["^15",[38,"^Q","Lines need to be ended with ;",536871169]],["^15",[38,"^O","^16",536871071]],["^15",[38,"^@",false,536871071]],["^15",[38,"^F",36,536871071]],["^15",[38,"^X",28,536871071]],["^15",[38,"^V",28,536871071]],["^15",[38,"^U",28,536871072]],["^15",[38,"^17",true,536871071]],["^15",[38,"^;","~u64a97d71-f3ab-441c-a01f-6f8a5248b3cd",536871071]],["^15",[41,"^Q","A rust project needs a [[cargo.toml]] file at the bare minimum.",536871417]],["^15",[41,"^O","^16",536871096]],["^15",[41,"^@",false,536871096]],["^15",[41,"^F",54,536875200]],["^15",[41,"^X",28,536871096]],["^15",[41,"^V",28,536871096]],["^15",[41,"^U",28,536871117]],["^15",[41,"^U",43,536871117]],["^15",[41,"^H",43,536916343]],["^15",[41,"^17",true,536871096]],["^15",[41,"^;","~u64a97da1-b88c-40c2-afca-e35528a4b0c5",536871096]],["^15",[43,"^K",1688829385075,536871112]],["^15",[43,"^[",58,536871505]],["^15",[43,"^O","^16",536871500]],["^15",[43,"^@",false,536871112]],["^15",[43,"^Y","cargo.toml",536871112]],["^15",[43,"^11","cargo.toml",536871112]],["^15",[43,"^B",1688831683921,536871819]],["^15",[43,"^;","~u64c20233-3ae8-446b-b684-1a91101fd5af",536916343]],["^15",[45,"^K",1688829397324,536871124]],["^15",[45,"^[",47,536871133]],["^15",[45,"^O","^16",536871128]],["^15",[45,"^@",false,536871124]],["^15",[45,"^Y","cargo",536871124]],["^15",[45,"^11","Cargo",536877912]],["^15",[45,"^B",1692199921039,536926172]],["^15",[45,"^;","~u64c20233-f76e-4c2c-ae9f-69de21aafdf4",536916343]],["^15",[46,"^Q","~``cargo``\nRust's package manager and build system. Whilst the Rust files are compiled with [[rustc]], cargo builds the rest of the project.",536877938]],["^15",[46,"^O","^16",536871129]],["^15",[46,"^@",false,536871129]],["^15",[46,"^F",45,536871129]],["^15",[46,"^X",45,536871129]],["^15",[46,"^V",45,536871129]],["^15",[46,"^U",45,536877932]],["^15",[46,"^U",50,536877935]],["^15",[46,"^H",50,536908111]],["^15",[46,"^17",true,536871129]],["^15",[46,"^;","~u64a97dd6-352a-43ec-b0ae-0465a1d22307",536871129]],["^15",[47,"^3","- ``cargo``\n  Rust's package manager and build system. Whilst the Rust files are compiled with [[rustc]], cargo builds the rest of the project.\n- ``cargo new``\n  We can create a new project with ``cargo new <folder/projectname>``.\n  We can then build the project with ``cargo build``. And then run it with ``cargo run``.\n  \n  * Library [[Crate]] can be created with ``cargo new <name> --lib``.\n- ``cargo build``\n  Builds the project and creates an executable in ``src/debug/`` . Use ``--release`` flag to build in release mode. A general difference between debug build and release build is that debug build is compiled faster but runs slower whereas release compiles slower but runs faster.\n- ``cargo run``\n  Builds the project or skips it if there already exists a latest build and then runs the executable.\n- ``cargo check``\n  Checks the project by building it but not creating an executable, faster than cargo build.\n- [crates.io](https://crates.io) is the Rust community’s central crate repository. [[Cargo]] searches for dependencies here by default.\n- To add a crate to our project,\n  * Find the crate version and name on crates.io \n  * Add ``<packge-name>=”<version>”`` to the [[cargo.toml]]\n  * Then open the items of the package in the [[Scope]] with [[use]]\n  \n  The [[Standard Library]] crates are already present in most Rust installations, we don’t need to specify its crates in the cargo.toml but we do need to open the items in the scope (using [[use]]) for easy access.\n- Cargo projects, by default, needs their ``.rs`` files inside an ``src`` folder, this folder must be at the same level as the [[cargo.toml]] file.\n- Release Profile\n  Cargo has 2 main profiles, ``dev`` and ``release`` profile. These profile define the configs applied to the compilation of the project. The ``dev`` profile is used when using ``cargo build`` by default and the ``release`` profile is used when we use ``cargo build --release``. \n  The primary difference between the 2 is the level of optimization applied to the executable (using ``opt-level = <number>`` in [[cargo.toml]]), the higher the level the greater the runtime performance but greater compile time too. This is why ``release`` is intended for release mode.\n  \n  To further configure them, in [[cargo.toml]]\n  ```toml\n  [profile.dev]\n  opt-level = 0\n  \n  [profile.release]\n  opt-level = 3\n  ```\n  This is their default optimization level.\n- Publishing a [[Crate]]\n  Check [here](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html)\n- Workspace\n  By using workspace, which is a cargo feature, we can have multiple [[Package]]s in a single project. They share the same [[cargo.lock]] and ``target/`` folder, which is from common parent which is a ``workspace``.\n  \n  For ex.:\n  ```sh\n  mkdir x\n  touch cargo.toml\n  # creates a new folder x and a cargo.toml in it\n  ```\n  \n  Then we make ``x``  a Workspace by modifying its [[cargo.toml]]\n  ```toml\n  [workspace]\n  \n  members = [\n    y,\n    z,\n  ]\n  ```\n  By replacing the ``[package]`` block with ``[workspace]`` we make a ``cargo.toml``'s folder a workspace. Here ``y`` and ``z`` are its child [[Package]]s.\n  \n  To create them,\n  ```sh\n  cd x\n  cargo new y\n  # creates crate y inside x with x being its workspace and hence a cargo.lock and target/ isn't created inside y/\n  cargo new z --lib\n  ```\n  \n  Finally, we get this structure\n  ```\n  x\n  ├── Cargo.lock\n  ├── Cargo.toml\n  ├── y\n  │   ├── Cargo.toml\n  │   └── src\n  │       └── main.rs\n  ├── z\n  │   ├── Cargo.toml\n  │   └── src\n  │       └── lib.rs\n  └── target\n  ```\n  The reason they share the ``target`` directory is because the packages in a workspace are  meant to depend on each other, by sharing the ``target`` folder they keep track of which package has been already built and hence avoid rebuilding each dependent package each time for each package.\n  \n  * To use a package like ``z`` in ``y`` we would do something like so\n  In ``lib.rs`` in ``z``,\n  ```rust\n  pub fn yo() {}\n  ```\n  Now to use ``yo`` in ``y``,\n  modify ``y``'s [[cargo.toml]],\n  ```toml\n  [dependencies]\n  z = { path = \"../z\" }\n  ```\n  \n  Now we can use ``z``'s items in ``y``, like so\n  ```rust\n  use z;\n  \n  fn main() {\n   yo(); //works\n  }\n  ```\n  \n  * ``cargo test -p <package name>``\n  By default cargo runs test on all crates inside a workspace, we can select a specific package with this arg.\n- ``cargo install``\n  Installs a binary to be used directly. By default ``cargo install`` installs a binary to ``$Home/.cargo/bin`` so we have to add that path to ``$PATH``. Only packages on crates.io that are a binary crate can be installed like this. \n  For ex.:\n  ```sh\n  cargo install ripgrep\n  #installs rigrep, a rust package for searching files.\n  ```\n-\n-",536926174]],["^15",[47,"^18","~m1692199921462",536926173]],["^15",[47,"^Z","pages/Cargo.md",536877913]],["^15",[49,"^Q","Rust files end in the extension ``.rs``",536871191]],["^15",[49,"^O","^16",536871172]],["^15",[49,"^@",false,536871172]],["^15",[49,"^F",38,536871172]],["^15",[49,"^X",28,536871172]],["^15",[49,"^V",28,536871172]],["^15",[49,"^U",28,536871173]],["^15",[49,"^17",true,536871172]],["^15",[49,"^;","~u64a97e33-252d-4db3-a0af-3566a8aa93a6",536871172]],["^15",[50,"^K",1688829519812,536871195]],["^15",[50,"^[",95,536872151]],["^15",[50,"^O","^16",536872146]],["^15",[50,"^@",false,536871195]],["^15",[50,"^Y","rustc",536871195]],["^15",[50,"^11","rustc",536871195]],["^15",[50,"^B",1688832155367,536872206]],["^15",[50,"^;","~u64c20233-6a55-4525-8aa0-a1dc729e79f2",536916343]],["^15",[51,"^Q","~``cargo new``\nWe can create a new project with ``cargo new <folder/projectname>``.\nWe can then build the project with ``cargo build``. And then run it with ``cargo run``.\n\n* Library [[Crate]] can be created with ``cargo new <name> --lib``.",536926172]],["^15",[51,"^O","^16",536871218]],["^15",[51,"^@",false,536871218]],["^15",[51,"^F",46,536877935]],["^15",[51,"^X",45,536871218]],["^15",[51,"^V",45,536871218]],["^15",[51,"^U",45,536926160]],["^15",[51,"^U",577,536926160]],["^15",[51,"^?",["^ "],536926172]],["^15",[51,"^H",577,536926172]],["^15",[51,"^17",true,536871218]],["^15",[51,"^;","~u64a97e5d-1e04-4697-a3ac-b315da0d202b",536871218]],["^15",[52,"^Q","Install rust by installing [[rustup]], here's a quick reference [docs book](https://doc.rust-lang.org/book/ch01-01-installation.html).",536880202]],["^15",[52,"^O","^16",536871238]],["^15",[52,"^@",false,536871238]],["^15",[52,"^F",49,536871238]],["^15",[52,"^X",28,536871238]],["^15",[52,"^V",28,536871238]],["^15",[52,"^U",28,536880203]],["^15",[52,"^U",432,536880203]],["^15",[52,"^H",432,536916343]],["^15",[52,"^17",true,536871238]],["^15",[52,"^;","~u64a97e6a-84ff-4858-a653-bcfb51927842",536871238]],["^15",[54,"^Q","[[rustup]] also introduces [[Cargo]]: Rust's Package manager, [[rustc]]: Rust's compiler and [[rustup]] itself which manages the updating of both. These are all available to the CLI, but if not, add them to the PATH as they are executables. \n\nThe ``rls`` (Rust Language Server) and ``rust-analyzer`` (Provides implementation of the rls) are generally automatically installed with rustup, but if they are not (resulting in failed code-completion etc.) we can manually install them with \n``rustup component add rls`` and ``rustup component add rust-analyzer``",536880198]],["^15",[54,"^O","^16",536871288]],["^15",[54,"^@",false,536871288]],["^15",[54,"^F",52,536871288]],["^15",[54,"^X",28,536871288]],["^15",[54,"^V",28,536871288]],["^15",[54,"^U",28,536880199]],["^15",[54,"^U",45,536880199]],["^15",[54,"^U",50,536880199]],["^15",[54,"^U",432,536880199]],["^15",[54,"^H",45,536916343]],["^15",[54,"^H",50,536916343]],["^15",[54,"^H",432,536916343]],["^15",[54,"^17",true,536871288]],["^15",[54,"^;","~u64a97f36-9344-43e2-8245-3e6e35a65bee",536871288]],["^15",[57,"^Q","A [[cargo.toml]] file is a [[Cargo]] configuration file for the project, so it defines the version of the language, it's dependencies etc., it looks like so\n```toml\n[package]\nname = \"citorust_alpha\"\nversion = \"0.1.0\"\nedition = \"2021\"\n \n[dependencies]\n```\nTom’s Obvious, Minimal Language.",536877914]],["^15",[57,"^O","^16",536871501]],["^15",[57,"^@",false,536871501]],["^15",[57,"^F",43,536871501]],["^15",[57,"^X",43,536871501]],["^15",[57,"^V",43,536871501]],["^15",[57,"^U",43,536871509]],["^15",[57,"^U",45,536871509]],["^15",[57,"^?",["^ "],536871819]],["^15",[57,"^H",43,536871819]],["^15",[57,"^H",45,536871819]],["^15",[57,"^17",true,536871501]],["^15",[57,"^;","~u64a97feb-0dec-4ec9-aace-c71f888ed352",536871501]],["^15",[58,"^3","- A [[cargo.toml]] file is a [[Cargo]] configuration file for the project, so it defines the version of the language, it's dependencies etc., it looks like so\n  ```toml\n  [package]\n  name = \"citorust_alpha\"\n  version = \"0.1.0\"\n  edition = \"2021\"\n   \n  [dependencies]\n  ```\n  Tom’s Obvious, Minimal Language.\n- More keys for the cargo.toml config can be found at [docs](https://doc.rust-lang.org/cargo/reference/manifest.html).\n- ``edition`` and ``rust-version``\n  These define what [Rust Edition](https://doc.rust-lang.org/edition-guide/index.html) and version the project is compiled with. \n  The latter is optional, a Rust Edition defines the compiler's version itself, it has breaking changes, whilst the version itself is just the language of the version to be compiled to.\n-\n-",536877921]],["^15",[58,"^18","~m1688913215140",536877920]],["^15",[58,"^Z","pages/cargo.toml.md",536871505]],["^15",[59,"^Q","More keys for the cargo.toml config can be found at [docs](https://doc.rust-lang.org/cargo/reference/manifest.html).",536871602]],["^15",[59,"^O","^16",536871560]],["^15",[59,"^@",false,536871560]],["^15",[59,"^F",57,536871560]],["^15",[59,"^X",43,536871560]],["^15",[59,"^V",43,536871560]],["^15",[59,"^U",43,536871561]],["^15",[59,"^?",["^ "],536871602]],["^15",[59,"^17",true,536871560]],["^15",[59,"^;","~u64a98025-2e16-454a-b0b2-8399533a3f68",536871560]],["^15",[60,"^U",43,536871569]],["^15",[61,"^U",43,536871577]],["^15",[62,"^Q","",536871593]],["^15",[62,"^O","^16",536871583]],["^15",[62,"^F",64,536871804]],["^15",[62,"^X",43,536871583]],["^15",[62,"^V",43,536871583]],["^15",[62,"^U",43,536871584]],["^15",[62,"^?",["^ "],536871593]],["^15",[62,"^17",true,536871587]],["^15",[62,"^;","~u64a98034-75b7-467c-9445-41e47cefd0ed",536871583]],["^15",[63,"^Q","~``edition`` and ``rust-version``\nThese define what [Rust Edition](https://doc.rust-lang.org/edition-guide/index.html) and version the project is compiled with. \nThe latter is optional, a Rust Edition defines the compiler's version itself, it has breaking changes, whilst the version itself is just the language of the version to be compiled to.",536871804]],["^15",[63,"^O","^16",536871603]],["^15",[63,"^@",false,536871603]],["^15",[63,"^F",59,536871603]],["^15",[63,"^X",43,536871603]],["^15",[63,"^V",43,536871603]],["^15",[63,"^U",43,536871604]],["^15",[63,"^?",["^ "],536871804]],["^15",[63,"^17",true,536871603]],["^15",[63,"^;","~u64a98048-9013-4f8f-91cb-63abed66e830",536871603]],["^15",[64,"^Q","",536871804]],["^15",[64,"^O","^16",536871804]],["^15",[64,"^@",false,536871804]],["^15",[64,"^F",63,536871804]],["^15",[64,"^X",43,536871804]],["^15",[64,"^V",43,536871804]],["^15",[64,"^U",43,536871805]],["^15",[64,"^?",["^ "],536871804]],["^15",[64,"^17",true,536871804]],["^15",[64,"^;","~u64a9869b-eb98-44fd-b381-cb5d9b3b6dab",536871804]],["^15",[65,"^Q","Main Entrypoint to any Rust executable\n``fn main() {…}``",536872143]],["^15",[65,"^O","^16",536871808]],["^15",[65,"^@",false,536871808]],["^15",[65,"^F",41,536871808]],["^15",[65,"^X",28,536871808]],["^15",[65,"^V",28,536871808]],["^15",[65,"^U",28,536871964]],["^15",[65,"^17",true,536871808]],["^15",[65,"^;","~u64a986b3-66d4-4456-a2dd-a574fc0be78c",536871808]],["^15",[66,"^Q","~``cargo build``\nBuilds the project and creates an executable in ``src/debug/`` . Use ``--release`` flag to build in release mode. A general difference between debug build and release build is that debug build is compiled faster but runs slower whereas release compiles slower but runs faster.",536908111]],["^15",[66,"^O","^16",536871822]],["^15",[66,"^@",false,536871822]],["^15",[66,"^F",51,536926153]],["^15",[66,"^X",45,536871822]],["^15",[66,"^V",45,536871822]],["^15",[66,"^U",45,536871823]],["^15",[66,"^17",true,536871822]],["^15",[66,"^;","~u64a986d6-ab1a-4f08-93b4-70853f996296",536871822]],["^15",[67,"^Q","~``cargo run``\nBuilds the project or skips it if there already exists a latest build and then runs the executable.",536871887]],["^15",[67,"^O","^16",536871865]],["^15",[67,"^@",false,536871865]],["^15",[67,"^F",66,536871865]],["^15",[67,"^X",45,536871865]],["^15",[67,"^V",45,536871865]],["^15",[67,"^U",45,536871866]],["^15",[67,"^17",true,536871865]],["^15",[67,"^;","~u64a986ff-3b51-4539-8c28-6f2600ab8c8f",536871865]],["^15",[68,"^Q","~``cargo check``\nChecks the project by building it but not creating an executable, faster than cargo build.",536871909]],["^15",[68,"^O","^16",536871888]],["^15",[68,"^@",false,536871888]],["^15",[68,"^F",67,536871888]],["^15",[68,"^X",45,536871888]],["^15",[68,"^V",45,536871888]],["^15",[68,"^U",45,536871889]],["^15",[68,"^17",true,536871888]],["^15",[68,"^;","~u64a98729-1ca3-4d7e-8099-377eec4c268e",536871888]],["^15",[69,"^Q","[[Variable]]",536872238]],["^15",[69,"^O","^16",536871934]],["^15",[69,"^@",false,536871934]],["^15",[69,"^F",65,536871934]],["^15",[69,"^X",28,536871934]],["^15",[69,"^V",28,536871934]],["^15",[69,"^U",28,536872239]],["^15",[69,"^U",99,536872239]],["^15",[69,"^H",99,536916343]],["^15",[69,"^17",true,536871934]],["^15",[69,"^;","~u64a9875f-2a59-47c1-a9a8-f3c80e3ed983",536871934]],["^15",[70,"^Q","[crates.io](https://crates.io) is the Rust community’s central crate repository. [[Cargo]] searches for dependencies here by default.",536877914]],["^15",[70,"^O","^16",536871968]],["^15",[70,"^@",false,536871968]],["^15",[70,"^F",68,536871968]],["^15",[70,"^X",45,536871968]],["^15",[70,"^V",45,536871968]],["^15",[70,"^U",45,536871969]],["^15",[70,"^H",45,536908111]],["^15",[70,"^17",true,536871968]],["^15",[70,"^;","~u64a98792-9843-4978-9019-7513eee3a8f6",536871968]],["^15",[71,"^Q","To add a crate to our project,\n* Find the crate version and name on crates.io \n* Add ``<packge-name>=”<version>”`` to the [[cargo.toml]]\n* Then open the items of the package in the [[Scope]] with [[use]]\n\nThe [[Standard Library]] crates are already present in most Rust installations, we don’t need to specify its crates in the cargo.toml but we do need to open the items in the scope (using [[use]]) for easy access.",536877539]],["^15",[71,"^O","^16",536871988]],["^15",[71,"^@",false,536871988]],["^15",[71,"^F",70,536871988]],["^15",[71,"^X",45,536871988]],["^15",[71,"^V",45,536871988]],["^15",[71,"^U",43,536872101]],["^15",[71,"^U",45,536872101]],["^15",[71,"^U",89,536872101]],["^15",[71,"^U",90,536872101]],["^15",[71,"^U",93,536872101]],["^15",[71,"^H",43,536908111]],["^15",[71,"^H",89,536908111]],["^15",[71,"^H",90,536908111]],["^15",[71,"^H",93,536908111]],["^15",[71,"^17",true,536871988]],["^15",[71,"^;","~u64a987a5-16e1-4d1f-80b4-f5d0d7c45163",536871988]],["^15",[72,"^U",45,536871995]],["^15",[73,"^U",45,536871995]],["^15",[74,"^U",45,536871995]],["^15",[75,"^U",45,536871995]],["^15",[76,"^U",45,536872002]],["^15",[77,"^U",45,536872002]],["^15",[78,"^U",45,536872002]],["^15",[79,"^U",45,536872002]],["^15",[80,"^U",45,536872010]],["^15",[81,"^U",45,536872010]],["^15",[82,"^U",45,536872010]],["^15",[83,"^U",45,536872010]],["^15",[84,"^U",45,536872010]],["^15",[89,"^K",1688831974155,536872060]],["^15",[89,"^[",283,536877133]],["^15",[89,"^O","^16",536877129]],["^15",[89,"^@",false,536872060]],["^15",[89,"^Y","scope",536872060]],["^15",[89,"^11","Scope",536877537]],["^15",[89,"^B",1690039143889,536910240]],["^15",[89,"^;","~u64c20233-64d6-408f-aece-477a6e9d48c9",536916352]],["^15",[90,"^K",1688831978011,536872064]],["^15",[90,"^[",92,536872079]],["^15",[90,"^O","^16",536872074]],["^15",[90,"^@",false,536872064]],["^15",[90,"^Y","use",536872064]],["^15",[90,"^11","use",536872064]],["^15",[90,"^B",1689511222061,536893546]],["^15",[90,"^;","~u64bbdc0c-d195-4cc7-9fbe-86298a00f197",536908111]],["^15",[91,"^Q","~``use``\nThis  keyword in Rust is much like the *using* keyword in C++. It is prepended to a [[Crate]]/ [[Module]]'s item name and then allows subsequent items in the same [[Scope]] to use the item as if they were in the same [[Scope]].\nSyntax: \n``\nuse <some-path>;\n``\n\nFor ex.:\n```rust\nmod x {\n    pub mod y {\n        pub mod z {\n            pub fn yo() {}\n        }\n    }\n}\n\nuse crate::x::y::z;\n\nfn main() {\n    z::yo();\n\n    use crate::x::y::z::yo;\n\n    yo(); //also works\n}\n```\nAs we can see, the last item in the path after ``use`` isn't opened, the keyword simply opens the namespace till that item and plops the item's name in the current namespace.",536892730]],["^15",[91,"^O","^16",536872075]],["^15",[91,"^@",false,536872075]],["^15",[91,"^F",90,536872075]],["^15",[91,"^X",90,536872075]],["^15",[91,"^V",90,536872075]],["^15",[91,"^U",89,536891680]],["^15",[91,"^U",90,536891680]],["^15",[91,"^U",530,536891680]],["^15",[91,"^U",577,536891680]],["^15",[91,"^?",["^ "],536892730]],["^15",[91,"^H",89,536892730]],["^15",[91,"^H",530,536892730]],["^15",[91,"^H",577,536892730]],["^15",[91,"^17",true,536872075]],["^15",[91,"^;","~u64a987fb-2124-4dcc-809f-da5945598e48",536872075]],["^15",[92,"^3","- ``use``\n  This  keyword in Rust is much like the *using* keyword in C++. It is prepended to a [[Crate]]/ [[Module]]'s item name and then allows subsequent items in the same [[Scope]] to use the item as if they were in the same [[Scope]].\n  Syntax: \n  ``\n  use <some-path>;\n  ``\n  \n  For ex.:\n  ```rust\n  mod x {\n      pub mod y {\n          pub mod z {\n              pub fn yo() {}\n          }\n      }\n  }\n  \n  use crate::x::y::z;\n  \n  fn main() {\n      z::yo();\n  \n      use crate::x::y::z::yo;\n  \n      yo(); //also works\n  }\n  ```\n  As we can see, the last item in the path after ``use`` isn't opened, the keyword simply opens the namespace till that item and plops the item's name in the current namespace.\n- It's idiomatic in Rust to use ``use`` to only open up till the [[Module]]s and not the specific items, as it allows identifying if the item is in the current module or is present in some external module for maintainers. \n  But items in the [[Standard Library]] library, it is idiomatic to specify the full path to an item.\n- ``use`` does not import anything. It simply opens a namespace. \n  The actual import is only made when a [[Module]] is defined at the top of a file.\n  \n  * When we define external packages to the [[cargo.toml]], and compile with [[Cargo]], the external crates are already imported in the [[Prelude]]. So we can directly use ``use`` without defining the [[Module]]s.\n  For ex.:\n  For a cargo.toml\n  ```toml\n  ...\n  [dependencies]\n  rand = \"0.9.0\"\n  ```\n  \n  We can use a ``main.rs`` like so\n  ```rust\n  use std::io;\n  use rand::Rng; //works\n  \n  fn main() {\n      println!(\"Guess the number!\");\n  \n      let secret_number = rand::thread_rng().gen_range(1..=100);\n  }\n  ```\n- ``as``\n  We can give an alias to the item brought to the current namespace by this keyword.\n  \n  For ex.:\n  ```rust\n  use x::y::z as K;\n  \n  //and use K wherever z would have been used.\n  ```\n- Re-exporting\n  The ``pub`` [[Access Modifier]] can also be applied to ``use``.\n  \n  By default, when ``use`` is used in a [[Scope]] it works as if it only opens the namespace to an item as *private*. But by using ``pub`` to ``use`` we make the item *public*.\n  This effectively allows external [[Crate]]s/ [[Module]]s to also have a direct path to an item as if the item was in this scope. \n  For ex.:\n  ```rust \n  mod x {\n    pub mod y {}\n  }\n  \n  use crate::x::y; \n  //makes y available here, it is like we defined y here \n  // mod y { }\n  \n  mod n {\n   pub mod k {\n  \n    }\n  }\n  \n  pub use crate::n::k;\n  // however this is like we defined pub k here and not just k\n  // pub mod k {}\n  ```\n  \n  A better example:\n  ```rust\n  pub mod modA {\n      pub fn fnA() {}\n  }\n  pub mod modB {\n      pub use crate::modA;\n   \n      pub fn fnB() {\n          modA::fnA();\n      }\n  }\n   \n  mod modC {\n      use crate::modB;\n      pub fn fnC() {\n          modB::modA::fnA(); //works, as if modA is defined inside modB. It won't work if we hadn't used pub in pub use crate::modA;\n      }\n  }\n  \n  ```\n- Nested Paths\n  Using ‘use’ for each item in an item can be tedious, so we can use a single ‘use’ to open multiple items. \n  For ex.:\n  ```rust\n  use crate::x::{y, z, m::n}; //opens y, z and n from m\n  \n  //We can also nest the base path if we wish to open it too,\n  //use crate::x::{self, m::n}; opens crate::x; and crate::m::n;\n  \n  ```\n- Glob [[Operator]]\n  Used to open all items in an item.\n  ```rust\n  use crate::x::*;\n  \n  //opens all the public items in x in scope. Generally used in testing as in production projects this pollutes the scope.\n  \n  ```",536893548]],["^15",[92,"^18","~m1689511222530",536893547]],["^15",[92,"^Z","pages/use.md",536872079]],["^15",[93,"^K",1688832022910,536872100]],["^15",[93,"^O","^16",536874702]],["^15",[93,"^@",false,536872100]],["^15",[93,"^Y","standard library",536872100]],["^15",[93,"^11","Standard Library",536874706]],["^15",[93,"^B",1688832022910,536872100]],["^15",[93,"^;","~u64c20233-f13d-4494-96af-05bdce94674f",536916346]],["^15",[94,"^Q","For individual files, we compile them with ``rustc <filename>.rs``. It generates an *.exe in windows and that can be directly run with ``./filename.exe``.",536872172]],["^15",[94,"^O","^16",536872147]],["^15",[94,"^@",false,536872147]],["^15",[94,"^F",50,536872147]],["^15",[94,"^X",50,536872147]],["^15",[94,"^V",50,536872147]],["^15",[94,"^U",50,536872148]],["^15",[94,"^?",["^ "],536872172]],["^15",[94,"^17",true,536872147]],["^15",[94,"^;","~u64a9885a-17c0-46a0-981a-c8ba7070178b",536872147]],["^15",[95,"^3","- For individual files, we compile them with ``rustc <filename>.rs``. It generates an *.exe in windows and that can be directly run with ``./filename.exe``.\n- Regardless of the approach used to generate an executable, it is always AOT (ahead-of-time) compiled, meaning, if we pass the executable to another system, it does not need to have Rust installed in order to run it. In contrast, ``*.py`` or ``*.js`` files need Python or JavaScript installed in\n  order to be run as they are interpreted languages.\n-",536872209]],["^15",[95,"^18","~m1688832156229",536872208]],["^15",[95,"^Z","pages/rustc.md",536872151]],["^15",[96,"^Q","Regardless of the approach used to generate an executable, it is always AOT (ahead-of-time) compiled, meaning, if we pass the executable to another system, it does not need to have Rust installed in order to run it. In contrast, ``*.py`` or ``*.js`` files need Python or JavaScript installed in\norder to be run as they are interpreted languages.",536872206]],["^15",[96,"^O","^16",536872172]],["^15",[96,"^@",false,536872172]],["^15",[96,"^F",94,536872172]],["^15",[96,"^X",50,536872172]],["^15",[96,"^V",50,536872172]],["^15",[96,"^U",50,536872173]],["^15",[96,"^?",["^ "],536872206]],["^15",[96,"^17",true,536872172]],["^15",[96,"^;","~u64a98873-f095-491d-a6d7-404ffd40d273",536872172]],["^15",[97,"^Q","",536872206]],["^15",[97,"^O","^16",536872206]],["^15",[97,"^@",false,536872206]],["^15",[97,"^F",96,536872206]],["^15",[97,"^X",50,536872206]],["^15",[97,"^V",50,536872206]],["^15",[97,"^U",50,536872207]],["^15",[97,"^?",["^ "],536872206]],["^15",[97,"^17",true,536872206]],["^15",[97,"^;","~u64a9889b-dc53-419c-8cad-66206f36ce1e",536872206]],["^15",[98,"^Q","Cargo projects, by default, needs their ``.rs`` files inside an ``src`` folder, this folder must be at the same level as the [[cargo.toml]] file.",536872233]],["^15",[98,"^O","^16",536872211]],["^15",[98,"^@",false,536872211]],["^15",[98,"^F",71,536872211]],["^15",[98,"^X",45,536872211]],["^15",[98,"^V",45,536872211]],["^15",[98,"^U",43,536872234]],["^15",[98,"^U",45,536872234]],["^15",[98,"^H",43,536908111]],["^15",[98,"^17",true,536872211]],["^15",[98,"^;","~u64a988b6-0cac-4d33-baff-b31b2539121c",536872211]],["^15",[99,"^K",1688832223609,536872238]],["^15",[99,"^[",101,536872247]],["^15",[99,"^O","^16",536872242]],["^15",[99,"^@",false,536872238]],["^15",[99,"^Y","variable",536872238]],["^15",[99,"^11","Variable",536872238]],["^15",[99,"^B",1688888536289,536873434]],["^15",[99,"^;","~u64c20233-e767-4a2f-b986-ebf51d80ab8c",536916352]],["^15",[100,"^Q","Variables in rust are immutable by default, meaning their value can’t be updated after initializing them once.\nFor ex.:\n```rust\nlet x: i32;\nx=6; //works\nx=7 //error.\n```\nDeclaration syntax is simply ``<let/const> <optional mut> <varname>: <var type> = <optional value>``.",536873431]],["^15",[100,"^O","^16",536872243]],["^15",[100,"^@",false,536872243]],["^15",[100,"^F",99,536872243]],["^15",[100,"^X",99,536872243]],["^15",[100,"^V",99,536872243]],["^15",[100,"^U",99,536872244]],["^15",[100,"^17",true,536872243]],["^15",[100,"^;","~u64a988e0-6241-4449-9485-d410961ffc43",536872243]],["^15",[101,"^3","- Variables in rust are immutable by default, meaning their value can’t be updated after initializing them once.\n  For ex.:\n  ```rust\n  let x: i32;\n  x=6; //works\n  x=7 //error.\n  ```\n  Declaration syntax is simply ``<let/const> <optional mut> <varname>: <var type> = <optional value>``.\n- NNBD\n  Rust is non-nullable by default, infact even the concept of ``null`` doesn’t exist in Rust. Every variable must either have a value or a type defined at-least and every variable must be assigned a value before being used. All of this is checked during compile time itself, and after compilation a variable must have a type. \n  For ex.:\n  ```rust\n  let y; // error as y doesn’t have a type\n  let z: i32; //ok\n  let x;\n  x=2; //ok and x’s type is inferred as i32.\n  let a:i32;\n  let b= a; //error as a doesn’t have a value.\n  let m=2; //ok and m’s type is inferred as i32.\n  ```\n- Mutable Variables\n  ``let mut <varname>:<var type>;``\n  \n  Whilst mutable variables allow reassignment of value, they forbade the reassignment of types so the variable can only get a value of the same type.\n- Constant\n  ``const <varname>:<type>= <value>;``\n  \n  Unlike variables created with ``let``, ``const`` vars are always immutable. Another feature of const is that it allows constant expressions like C++. So \n  ```rust\n  const ABC: u32 = 2*2*3+3; //works\n  ```\n- Shadowing\n  Allowed, even in the same [[Scope]].\n  We can create a new variable with the same name as a previous one. The new variable ‘overshadows’ the older one and will be accessed when called later in the scope instead of the variable being shadowed. The overshadowing variable won’t be accessed if not in present or parent [[Scope]]. This allows us to use some cool things like\n  ```rust\n  let spaces = \"   \";\n  let spaces = spaces.len();\n  ```\n  The first spaces is of type [[String]] while the latter is a [[Number]] [[Data Type]] .\n- Data types\n  Rust is a statically typed language, meaning the type of values must be resolved at compile time. Explicitly specifying a type isn’t required as the compiler can infer the type of a variable automatically. It is a bit more powerful than other languages as type can be inferred even after the declaration of variable. However, types must be specified when multiple types are possible from an expression. \n  For ex.\n  ```rust\n  #![allow(unused)]\n  fn main() {\n  let guess: u32 = \"42\".parse().expect(\"Not a number!\"); //works\n  }\n  ```\n  If we remove the type then it throws an [[Error]]. This is to say, the parse() [[Function]] picks up the \n   type given to the variable. The compiler passes the type given to the receiver to the function for its [[Generic Type]]s, so parse knows it has to work for [[Number]] [[Data Type]] ``u32``.\n- *Static Variable*s\n  Rust allows global variables, i.e., variables in the global [[Scope]]. They have be to declared with the ``static`` keyword. However, using them isn't a best practice as if we use them with [[Thread]]s, multiple threads accessing the same Global variables can cause *Data Race*.\n  Static variables can only have static [[Lifetime]]s and hence can only have values given at compile-time.\n  \n  \n  Syntax:\n  ``\n  static <optional mut> <varname>:<vartype>= <value>;\n  ``\n  For ex.\n  ```rust\n  static HELLO_WORLD: &str = \"Hello, world!\";\n  static mut YO: u32=0; \n  fn main() {\n      println!(\"name is: {}\", HELLO_WORLD);\n      unsafe {\n      YO= 2;\n       println!(\"yo: {}\", YO);\n    }\n  }\n  ```\n  It is in [[Default Linter Rule]]s to define static variables in *SCREAMING_SNAKE_CASE*.\n  Accessing/Mutating static variables is [[unsafe]] as it could lead to *Data Race*.\n  \n  * ``static`` variables are different from ``const`` variables as they have a fixed address throughout the runtime, however const variables depend on their [[Scope]] and can have any address as they are initialized/destroyed each time the scope starts/ends.\n-",536916352]],["^15",[101,"^18","~m1690335350420",536916353]],["^15",[101,"^Z","pages/Variable.md",536872247]],["^15",[102,"^Q","Constant\n``const <varname>:<type>= <value>;``\n\nUnlike variables created with ``let``, ``const`` vars are always immutable. Another feature of const is that it allows constant expressions like C++. So \n```rust\nconst ABC: u32 = 2*2*3+3; //works\n```",536872460]],["^15",[102,"^O","^16",536872260]],["^15",[102,"^@",false,536872260]],["^15",[102,"^F",103,536872322]],["^15",[102,"^X",99,536872260]],["^15",[102,"^V",99,536872260]],["^15",[102,"^U",99,536872261]],["^15",[102,"^17",true,536872260]],["^15",[102,"^;","~u64a988f3-e891-41c5-81c9-7196843a4d70",536872260]],["^15",[103,"^Q","Mutable Variables\n``let mut <varname>:<var type>;``\n\nWhilst mutable variables allow reassignment of value, they forbade the reassignment of types so the variable can only get a value of the same type.",536872375]],["^15",[103,"^O","^16",536872291]],["^15",[103,"^@",false,536872291]],["^15",[103,"^F",182,536873437]],["^15",[103,"^X",99,536872291]],["^15",[103,"^V",99,536872291]],["^15",[103,"^U",99,536872292]],["^15",[103,"^17",true,536872291]],["^15",[103,"^;","~u64a98911-97e2-4023-919e-6bc8b7abf32f",536872291]],["^15",[112,"^Q","Shadowing\nAllowed, even in the same [[Scope]].\nWe can create a new variable with the same name as a previous one. The new variable ‘overshadows’ the older one and will be accessed when called later in the scope instead of the variable being shadowed. The overshadowing variable won’t be accessed if not in present or parent [[Scope]]. This allows us to use some cool things like\n```rust\nlet spaces = \"   \";\nlet spaces = spaces.len();\n```\nThe first spaces is of type [[String]] while the latter is a [[Number]] [[Data Type]] .",536877539]],["^15",[112,"^O","^16",536872450]],["^15",[112,"^@",false,536872450]],["^15",[112,"^F",102,536872450]],["^15",[112,"^X",99,536872450]],["^15",[112,"^V",99,536872450]],["^15",[112,"^U",89,536872909]],["^15",[112,"^U",99,536872909]],["^15",[112,"^U",118,536872909]],["^15",[112,"^U",119,536872909]],["^15",[112,"^U",148,536872909]],["^15",[112,"^H",89,536916352]],["^15",[112,"^H",118,536916352]],["^15",[112,"^H",119,536916352]],["^15",[112,"^H",148,536916352]],["^15",[112,"^17",true,536872450]],["^15",[112,"^;","~u64a989b4-3d90-4fc7-91eb-c6f98697c4dc",536872450]],["^15",[118,"^5",268,536875975]],["^15",[118,"^K",1688832589148,536872564]],["^15",[118,"^[",266,536875888]],["^15",[118,"^O","^16",536873612]],["^15",[118,"^@",false,536872564]],["^15",[118,"^Y","string",536872564]],["^15",[118,"^11","String",536873616]],["^15",[118,"^?",["^ ","~:alias",["~#set",["str"]]],536875975]],["^15",[118,"^4",["^ ","^19","str"],536875975]],["^15",[118,"^B",1704064698075,536926309]],["^15",[118,"^;","~u64c20233-52c6-4e5c-82ac-5e2450fd75e0",536916352]],["^15",[119,"^K",1688832593341,536872568]],["^15",[119,"^[",165,536873023]],["^15",[119,"^O","^16",536873002]],["^15",[119,"^@",false,536872568]],["^15",[119,"^Y","number",536872568]],["^15",[119,"^11","Number",536873006]],["^15",[119,"^B",1688890520042,536874598]],["^15",[119,"^;","~u64c20233-f9fe-4ef8-a80d-e56115f9a1d0",536916352]],["^15",[120,"^Q","Data types\nRust is a statically typed language, meaning the type of values must be resolved at compile time. Explicitly specifying a type isn’t required as the compiler can infer the type of a variable automatically. It is a bit more powerful than other languages as type can be inferred even after the declaration of variable. However, types must be specified when multiple types are possible from an expression. \nFor ex.\n```rust\n#![allow(unused)]\nfn main() {\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\"); //works\n}\n```\nIf we remove the type then it throws an [[Error]]. This is to say, the parse() [[Function]] picks up the \n type given to the variable. The compiler passes the type given to the receiver to the function for its [[Generic Type]]s, so parse knows it has to work for [[Number]] [[Data Type]] ``u32``.",536898404]],["^15",[120,"^O","^16",536872575]],["^15",[120,"^@",false,536872575]],["^15",[120,"^F",112,536872575]],["^15",[120,"^X",99,536872575]],["^15",[120,"^V",99,536872575]],["^15",[120,"^U",99,536872905]],["^15",[120,"^U",119,536872905]],["^15",[120,"^U",129,536872905]],["^15",[120,"^U",130,536872905]],["^15",[120,"^U",131,536872905]],["^15",[120,"^U",148,536872905]],["^15",[120,"^H",119,536916352]],["^15",[120,"^H",129,536916352]],["^15",[120,"^H",130,536916352]],["^15",[120,"^H",131,536916352]],["^15",[120,"^H",148,536916352]],["^15",[120,"^17",true,536872575]],["^15",[120,"^;","~u64a98aa1-34cf-43ce-a81c-6e00d1a6c3e4",536872575]],["^15",[129,"^K",1688832754582,536872694]],["^15",[129,"^[",696,536896271]],["^15",[129,"^O","^16",536878281]],["^15",[129,"^@",false,536872694]],["^15",[129,"^Y","error",536872694]],["^15",[129,"^11","Error",536878285]],["^15",[129,"^B",1689878662472,536906335]],["^15",[129,"^;","~u64c20233-90af-4d8a-a427-21b309f5d914",536916352]],["^15",[130,"^K",1688832772624,536872698]],["^15",[130,"^[",293,536877200]],["^15",[130,"^O","^16",536875314]],["^15",[130,"^@",false,536872698]],["^15",[130,"^Y","function",536872698]],["^15",[130,"^11","Function",536875318]],["^15",[130,"^B",1690519324273,536919401]],["^15",[130,"^;","~u64c20233-d21a-4e34-ba31-dd4c73aa6368",536916352]],["^15",[131,"^K",1688832794821,536872705]],["^15",[131,"^[",732,536898428]],["^15",[131,"^O","^16",536874902]],["^15",[131,"^@",false,536872705]],["^15",[131,"^Y","generic type",536898403]],["^15",[131,"^11","Generic Type",536898403]],["^15",[131,"^B",1690967754761,536925759]],["^15",[131,"^;","~u64c20233-6d79-426e-9554-13506c4bc635",536916352]],["^15",[147,"^Q","",536872900]],["^15",[147,"^O","^16",536872900]],["^15",[147,"^@",false,536872900]],["^15",[147,"^F",1047,536916352]],["^15",[147,"^X",99,536872900]],["^15",[147,"^V",99,536872900]],["^15",[147,"^U",99,536872901]],["^15",[147,"^17",true,536872900]],["^15",[147,"^;","~u64a98bcb-6b8b-4251-99e0-512b1044bb0c",536872900]],["^15",[148,"^K",1688832994807,536872904]],["^15",[148,"^[",150,536872917]],["^15",[148,"^O","^16",536872912]],["^15",[148,"^@",false,536872904]],["^15",[148,"^Y","data type",536872904]],["^15",[148,"^11","Data Type",536872904]],["^15",[148,"^B",1690515276465,536918369]],["^15",[148,"^;","~u64c20233-69bf-4649-92d2-18a8f94d6445",536916352]],["^15",[149,"^Q","2 basic data types\nScalar and Compound",536872932]],["^15",[149,"^O","^16",536872913]],["^15",[149,"^@",false,536872913]],["^15",[149,"^F",148,536872913]],["^15",[149,"^X",148,536872913]],["^15",[149,"^V",148,536872913]],["^15",[149,"^U",148,536872914]],["^15",[149,"^17",true,536872913]],["^15",[149,"^;","~u64a98bed-e665-4540-8cc9-226a6c26a218",536872913]],["^15",[150,"^3","- 2 basic data types\n  Scalar and Compound\n- Scalar Types\n  Types that represents a single value. They are\n  * [[Number]]\n  * [[Bool]]\n  * [[Char]]\n- Compound Types\n  Types that group multiple types into a single type. They are\n  * [[Tuple]]\n  * [[Array]]\n  * [[Collection]]\n- [[Reference Type]]\n- [[Pointer]]s\n- [[Type Alias]]\n- [[Dynamically Sized Type]]\n- [[Never Type]]\n- Size of\n  We can know the size of any data type with ``core::mem::size_of::<T>();``.\n  Defined in the ``core`` [[Crate]] which is in the [[Standard Library]].",536918372]],["^15",[150,"^18","~m1690515276970",536918371]],["^15",[150,"^Z","pages/Data Type.md",536872917]],["^15",[151,"^Q","Scalar Types\nTypes that represents a single value. They are\n* [[Number]]\n* [[Bool]]\n* [[Char]]",536873565]],["^15",[151,"^O","^16",536872932]],["^15",[151,"^@",false,536872932]],["^15",[151,"^F",149,536872932]],["^15",[151,"^X",148,536872932]],["^15",[151,"^V",148,536872932]],["^15",[151,"^U",119,536873481]],["^15",[151,"^U",148,536873481]],["^15",[151,"^U",183,536873481]],["^15",[151,"^U",186,536873481]],["^15",[151,"^H",119,536908117]],["^15",[151,"^H",183,536908117]],["^15",[151,"^H",186,536908117]],["^15",[151,"^17",true,536872932]],["^15",[151,"^;","~u64a98bfe-27d1-4652-b0c7-d10c93a65193",536872932]],["^15",[163,"^Q","integers: Numbers without fractional components.\n![image.png](../assets/image_1688833118249_0.png)\n\nFor n bits,\n* Signed ints are the ints that care for the sign, + or -. These can store -ve as well as +ve values. Stored using 2’s complement representation. \nValue range: $$-2^{n-1}$$ < $$2^{n-1}$$\n\n* Unsigned ints can only be +ve. \nValue range: 0 < $$2^n-1$$\n\n* The ``isize`` and ``usize`` are used to denote size of collections and depend on the architecture of the program, i.e. 64 bits on x64 and 32 bit on x86.",536873197]],["^15",[163,"^O","^16",536873003]],["^15",[163,"^@",false,536873003]],["^15",[163,"^F",119,536873003]],["^15",[163,"^X",119,536873003]],["^15",[163,"^V",119,536873003]],["^15",[163,"^U",119,536873004]],["^15",[163,"^?",["^ "],536873197]],["^15",[163,"^17",true,536873003]],["^15",[163,"^;","~u64a98c9b-faf9-43fd-a52d-8db737850462",536873003]],["^15",[165,"^3","- integers: Numbers without fractional components.\n  ![image.png](../assets/image_1688833118249_0.png)\n  \n  For n bits,\n  * Signed ints are the ints that care for the sign, + or -. These can store -ve as well as +ve values. Stored using 2’s complement representation. \n  Value range: $$-2^{n-1}$$ < $$2^{n-1}$$\n  \n  * Unsigned ints can only be +ve. \n  Value range: 0 < $$2^n-1$$\n  \n  * The ``isize`` and ``usize`` are used to denote size of collections and depend on the architecture of the program, i.e. 64 bits on x64 and 32 bit on x86.\n- Numbers can use literals to allow inferring the right type automatically to the [[Variable]]\n  ![image.png](../assets/image_1688833517132_0.png)\n  Like ``57u8`` (57 of type u8).\n  \n  The ``_`` has 2 uses, for floating-point [[Data Type]]s, it means the decimal position and for ints it is just a visual separator.\n- Floating-Point\n  ``f32`` and ``f64``, 32 bits and single precision & 64 bits and double precision respectively. In modern CPUs, f64 is as fast as f32 but with greater precision, which is why if f32 isn’t explicitly specified, a floating number is inferred as f64 in rust.\n- Numeric Operations\n  Same as C++, here's reference: [Docs Book](https://doc.rust-lang.org/book/appendix-02-operators.html)\n- Overflow and prevention\n  In rust, if an integer overflows (value greater than the size allowed by type) then, if it’s in debug mode \n   then the program [[Panic]]s, and if it’s in release mode then the value wraps around (new value = overflowing value – size of type, if it’s still overflowing then repeat). To allow better checks against said  overflows, rust provides a few standard methods available in same named crates.\n  * Wrap in all modes with the ``wrapping_*`` methods, such as ``wrapping_add`` \n  * Return a [[Option Type]]::None value if there is overflow with the ``checked_*`` methods\n  * Return the value and a boolean indicating whether there was overflow with the ``overflowing_*`` methods\n  * Saturate (Clamp) at the value’s minimum or maximum values with ``saturating_*`` methods\n-",536874604]],["^15",[165,"^18","~m1688890521440",536874603]],["^15",[165,"^Z","pages/Number.md",536873023]],["^15",[166,"^Q","Overflow and prevention\nIn rust, if an integer overflows (value greater than the size allowed by type) then, if it’s in debug mode \n then the program [[Panic]]s, and if it’s in release mode then the value wraps around (new value = overflowing value – size of type, if it’s still overflowing then repeat). To allow better checks against said  overflows, rust provides a few standard methods available in same named crates.\n* Wrap in all modes with the ``wrapping_*`` methods, such as ``wrapping_add`` \n* Return a [[Option Type]]::None value if there is overflow with the ``checked_*`` methods\n* Return the value and a boolean indicating whether there was overflow with the ``overflowing_*`` methods\n* Saturate (Clamp) at the value’s minimum or maximum values with ``saturating_*`` methods",536874598]],["^15",[166,"^O","^16",536873152]],["^15",[166,"^@",false,536873152]],["^15",[166,"^F",177,536873334]],["^15",[166,"^X",119,536873152]],["^15",[166,"^V",119,536873152]],["^15",[166,"^U",119,536874580]],["^15",[166,"^U",219,536874580]],["^15",[166,"^U",228,536874580]],["^15",[166,"^?",["^ "],536874598]],["^15",[166,"^H",219,536874598]],["^15",[166,"^H",228,536874598]],["^15",[166,"^17",true,536873152]],["^15",[166,"^;","~u64a98da7-1132-436d-a584-32ce16f5a471",536873152]],["^15",[167,"^U",119,536873157]],["^15",[168,"^U",119,536873157]],["^15",[169,"^U",119,536873157]],["^15",[174,"^Q","Numbers can use literals to allow inferring the right type automatically to the [[Variable]]\n![image.png](../assets/image_1688833517132_0.png)\nLike ``57u8`` (57 of type u8).\n\nThe ``_`` has 2 uses, for floating-point [[Data Type]]s, it means the decimal position and for ints it is just a visual separator.",536873285]],["^15",[174,"^O","^16",536873197]],["^15",[174,"^@",false,536873197]],["^15",[174,"^F",163,536873197]],["^15",[174,"^X",119,536873197]],["^15",[174,"^V",119,536873197]],["^15",[174,"^U",99,536873261]],["^15",[174,"^U",119,536873261]],["^15",[174,"^U",148,536873261]],["^15",[174,"^?",["^ "],536873285]],["^15",[174,"^H",99,536873285]],["^15",[174,"^H",148,536873285]],["^15",[174,"^17",true,536873197]],["^15",[174,"^;","~u64a98dc0-c9a1-41f6-9a7d-176d26db3fa3",536873197]],["^15",[176,"^Q","Floating-Point\n``f32`` and ``f64``, 32 bits and single precision & 64 bits and double precision respectively. In modern CPUs, f64 is as fast as f32 but with greater precision, which is why if f32 isn’t explicitly specified, a floating number is inferred as f64 in rust.",536873331]],["^15",[176,"^O","^16",536873285]],["^15",[176,"^@",false,536873285]],["^15",[176,"^F",174,536873285]],["^15",[176,"^X",119,536873285]],["^15",[176,"^V",119,536873285]],["^15",[176,"^U",119,536873286]],["^15",[176,"^?",["^ "],536873331]],["^15",[176,"^17",true,536873285]],["^15",[176,"^;","~u64a98e71-2358-4ef9-9535-e5c2c1cf280a",536873285]],["^15",[177,"^Q","Numeric Operations\nSame as C++, here's reference: [Docs Book](https://doc.rust-lang.org/book/appendix-02-operators.html)",536873467]],["^15",[177,"^O","^16",536873334]],["^15",[177,"^@",false,536873334]],["^15",[177,"^F",176,536873334]],["^15",[177,"^X",119,536873334]],["^15",[177,"^V",119,536873334]],["^15",[177,"^U",119,536873335]],["^15",[177,"^?",["^ "],536873467]],["^15",[177,"^17",true,536873334]],["^15",[177,"^;","~u64a992b5-2d6b-40af-9f8b-2d7601dcbcf3",536873334]],["^15",[178,"^12",2,536873339]],["^15",[181,"^12",2,536873344]],["^15",[182,"^Q","NNBD\nRust is non-nullable by default, infact even the concept of ``null`` doesn’t exist in Rust. Every variable must either have a value or a type defined at-least and every variable must be assigned a value before being used. All of this is checked during compile time itself, and after compilation a variable must have a type. \nFor ex.:\n```rust\nlet y; // error as y doesn’t have a type\nlet z: i32; //ok\nlet x;\nx=2; //ok and x’s type is inferred as i32.\nlet a:i32;\nlet b= a; //error as a doesn’t have a value.\nlet m=2; //ok and m’s type is inferred as i32.\n```",536873439]],["^15",[182,"^O","^16",536873437]],["^15",[182,"^@",false,536873437]],["^15",[182,"^F",100,536873437]],["^15",[182,"^X",99,536873437]],["^15",[182,"^V",99,536873437]],["^15",[182,"^U",99,536873438]],["^15",[182,"^17",true,536873437]],["^15",[182,"^;","~u64aa64db-5eca-4059-bbb5-c44bb07752f9",536873437]],["^15",[183,"^K",1688888620140,536873470]],["^15",[183,"^[",191,536873504]],["^15",[183,"^O","^16",536873499]],["^15",[183,"^@",false,536873470]],["^15",[183,"^Y","char",536873470]],["^15",[183,"^11","Char",536873470]],["^15",[183,"^B",1688888818363,536873542]],["^15",[183,"^;","~u64bbdc0c-d501-4e89-987b-9fc8c0786714",536908117]],["^15",[184,"^U",148,536873471]],["^15",[186,"^K",1688888679961,536873480]],["^15",[186,"^[",188,536873489]],["^15",[186,"^O","^16",536873484]],["^15",[186,"^@",false,536873480]],["^15",[186,"^Y","bool",536873480]],["^15",[186,"^11","Bool",536873480]],["^15",[186,"^B",1688888835859,536873546]],["^15",[186,"^;","~u64bbdc0c-cfbd-4ab5-8d3e-a1aa77b5c302",536908117]],["^15",[187,"^Q","~``bool``\nTake up 1 byte of memory, and store either ``true`` or ``false`` as value.",536873546]],["^15",[187,"^O","^16",536873485]],["^15",[187,"^@",false,536873485]],["^15",[187,"^F",186,536873485]],["^15",[187,"^X",186,536873485]],["^15",[187,"^V",186,536873485]],["^15",[187,"^U",186,536873486]],["^15",[187,"^?",["^ "],536873546]],["^15",[187,"^17",true,536873485]],["^15",[187,"^;","~u64aa6569-f3c2-484c-b1b4-6a563c21865a",536873485]],["^15",[188,"^3","- ``bool``\n  Take up 1 byte of memory, and store either ``true`` or ``false`` as value.\n- Why 1 byte and not 1 bit ? \n  ![image.png](../assets/image_1688888379719_0.png)",536873548]],["^15",[188,"^18","~m1688888836797",536873547]],["^15",[188,"^Z","pages/Bool.md",536873489]],["^15",[189,"^Q","Why 1 byte and not 1 bit ? \n![image.png](../assets/image_1688888379719_0.png)",536873495]],["^15",[189,"^O","^16",536873495]],["^15",[189,"^@",false,536873495]],["^15",[189,"^F",187,536873495]],["^15",[189,"^X",186,536873495]],["^15",[189,"^V",186,536873495]],["^15",[189,"^U",186,536873496]],["^15",[189,"^?",["^ "],536873495]],["^15",[189,"^17",true,536873495]],["^15",[189,"^;","~u64aa6570-70f5-4d25-8ca8-5ac2bfbe0f0e",536873495]],["^15",[190,"^Q","~``char``\nA primitive type to store alphabetic values, A character in rust is a 4 byte Unicode Scalar Value stored inside ‘ ‘ (and not “ “, which is used for [[String]]s). Since it is Unicode, it can store ASCII but also other language characters and even emojis,\nin the range U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive. So a value ‘❤️’ is a single char in rust.",536873617]],["^15",[190,"^O","^16",536873500]],["^15",[190,"^@",false,536873500]],["^15",[190,"^F",183,536873500]],["^15",[190,"^X",183,536873500]],["^15",[190,"^V",183,536873500]],["^15",[190,"^U",118,536873517]],["^15",[190,"^U",183,536873517]],["^15",[190,"^?",["^ "],536873542]],["^15",[190,"^H",118,536873542]],["^15",[190,"^17",true,536873500]],["^15",[190,"^;","~u64aa6575-670e-4c24-b284-835916424d38",536873500]],["^15",[191,"^3","- ``char``\n  A primitive type to store alphabetic values, A character in rust is a 4 byte Unicode Scalar Value stored inside ‘ ‘ (and not “ “, which is used for [[String]]s). Since it is Unicode, it can store ASCII but also other language characters and even emojis,\n  in the range U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive. So a value ‘❤️’ is a single char in rust.\n-",536873622]],["^15",[191,"^18","~m1688888953353",536873625]],["^15",[191,"^Z","pages/Char.md",536873504]],["^15",[192,"^Q","",536873526]],["^15",[192,"^O","^16",536873526]],["^15",[192,"^@",false,536873526]],["^15",[192,"^F",190,536873526]],["^15",[192,"^X",183,536873526]],["^15",[192,"^V",183,536873526]],["^15",[192,"^U",183,536873527]],["^15",[192,"^?",["^ "],536873526]],["^15",[192,"^17",true,536873526]],["^15",[192,"^;","~u64aa65d1-49c4-48a6-92bb-7399c7f05a55",536873526]],["^15",[193,"^Q","Compound Types\nTypes that group multiple types into a single type. They are\n* [[Tuple]]\n* [[Array]]\n* [[Collection]]",536874636]],["^15",[193,"^O","^16",536873549]],["^15",[193,"^@",false,536873549]],["^15",[193,"^F",151,536873549]],["^15",[193,"^X",148,536873549]],["^15",[193,"^V",148,536873549]],["^15",[193,"^U",148,536874637]],["^15",[193,"^U",194,536874637]],["^15",[193,"^U",196,536874637]],["^15",[193,"^U",231,536874637]],["^15",[193,"^H",194,536908117]],["^15",[193,"^H",196,536908117]],["^15",[193,"^H",231,536908117]],["^15",[193,"^17",true,536873549]],["^15",[193,"^;","~u64aa6617-0c0c-4050-bfde-557d33e1dece",536873549]],["^15",[194,"^K",1688888926642,536873595]],["^15",[194,"^[",199,536873632]],["^15",[194,"^O","^16",536873627]],["^15",[194,"^@",false,536873595]],["^15",[194,"^Y","tuple",536873595]],["^15",[194,"^11","Tuple",536873595]],["^15",[194,"^B",1688890255876,536874452]],["^15",[194,"^;","~u64c20232-156a-43ea-a39f-9d2b0d536363",536916337]],["^15",[196,"^K",1688888931958,536873599]],["^15",[196,"^[",215,536874198]],["^15",[196,"^O","^16",536874193]],["^15",[196,"^@",false,536873599]],["^15",[196,"^Y","array",536873599]],["^15",[196,"^11","Array",536873599]],["^15",[196,"^B",1688890570744,536874626]],["^15",[196,"^;","~u64c20232-cddf-475d-a268-fb86dc2a67a8",536916337]],["^15",[198,"^Q","Fixed-size, multi-type and immutable.\nSyntax ``<let/const> <mutability> <varname>: (<type1>, <type2>...,<type n>) = (<value of type 1>, <value of type 2>..., <value of type n>)``\nFor ex.:\n```rust\nlet tup: (u8, bool, f32)= (1, true, 2.0);  //to declare\nlet x =tup.0; //to access\n```\nA single variable can bind to a tuple with multiple values/types is because a tuple is seen as a single compound element, so the variable binds to that.",536874452]],["^15",[198,"^O","^16",536873628]],["^15",[198,"^@",false,536873628]],["^15",[198,"^F",194,536873628]],["^15",[198,"^X",194,536873628]],["^15",[198,"^V",194,536873628]],["^15",[198,"^U",194,536873629]],["^15",[198,"^?",["^ "],536874452]],["^15",[198,"^17",true,536873628]],["^15",[198,"^;","~u64aa668b-9842-4f9e-80c1-0113f93a034a",536873628]],["^15",[199,"^3","- Fixed-size, multi-type and immutable.\n  Syntax ``<let/const> <mutability> <varname>: (<type1>, <type2>...,<type n>) = (<value of type 1>, <value of type 2>..., <value of type n>)``\n  For ex.:\n  ```rust\n  let tup: (u8, bool, f32)= (1, true, 2.0);  //to declare\n  let x =tup.0; //to access\n  ```\n  A single variable can bind to a tuple with multiple values/types is because a tuple is seen as a single compound element, so the variable binds to that.\n- Defining the types is optional as they can be automatically inferred too.\n- We access a tuple's values by its indices and using the ``.`` [[Operator]] on its variable, this is called tuple indexing. Indices start at 0.\n  Alternative, we can also use [[Pattern Matching]] to get a bind multiple variables to an entire tuple.\n  For ex.:\n  ```rust\n      let tup = (500, 6.4, 1);\n  \n      let (x, y, z) = tup;\n      let k= tup.0; //access by index\n  ```\n  This is called Tuple [[Destructuring]] because we destructure a single variable into multiple variables.\n-\n-",536874455]],["^15",[199,"^18","~m1688890255989",536874454]],["^15",[199,"^Z","pages/Tuple.md",536873632]],["^15",[200,"^Q","We access a tuple's values by its indices and using the ``.`` [[Operator]] on its variable, this is called tuple indexing. Indices start at 0.\nAlternative, we can also use [[Pattern Matching]] to get a bind multiple variables to an entire tuple.\nFor ex.:\n```rust\n    let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n    let k= tup.0; //access by index\n```\nThis is called Tuple [[Destructuring]] because we destructure a single variable into multiple variables.",536874017]],["^15",[200,"^O","^16",536873656]],["^15",[200,"^@",false,536873656]],["^15",[200,"^F",222,536874452]],["^15",[200,"^X",194,536873656]],["^15",[200,"^V",194,536873656]],["^15",[200,"^U",194,536873987]],["^15",[200,"^U",202,536873987]],["^15",[200,"^U",204,536873987]],["^15",[200,"^U",206,536873987]],["^15",[200,"^?",["^ "],536874017]],["^15",[200,"^H",202,536874017]],["^15",[200,"^H",204,536874017]],["^15",[200,"^H",206,536874017]],["^15",[200,"^17",true,536873656]],["^15",[200,"^;","~u64aa66ae-c3fc-4952-ae92-0a8eb1af1554",536873656]],["^15",[201,"^Q","",536873678]],["^15",[201,"^O","^16",536873678]],["^15",[201,"^@",false,536873678]],["^15",[201,"^F",205,536873967]],["^15",[201,"^X",194,536873678]],["^15",[201,"^V",194,536873678]],["^15",[201,"^U",194,536873679]],["^15",[201,"^?",["^ "],536873678]],["^15",[201,"^17",true,536873678]],["^15",[201,"^;","~u64aa66c6-7cdc-4cb8-b0e6-641347f1b06e",536873678]],["^15",[202,"^K",1688889217231,536873805]],["^15",[202,"^[",538,536885648]],["^15",[202,"^O","^16",536885643]],["^15",[202,"^@",false,536873805]],["^15",[202,"^Y","pattern matching",536873805]],["^15",[202,"^11","Pattern Matching",536873805]],["^15",[202,"^B",1690518414843,536919032]],["^15",[202,"^;","~u64c20232-a766-4118-b6d7-21485d3bb333",536916337]],["^15",[204,"^K",1688889405180,536873942]],["^15",[204,"^@",false,536873942]],["^15",[204,"^Y","destructuring",536873942]],["^15",[204,"^11","Destructuring",536873942]],["^15",[204,"^B",1688889405180,536873942]],["^15",[204,"^;","~u64c20232-5339-4cd8-9817-38926eaa16ea",536916337]],["^15",[205,"^Q","",536874148]],["^15",[205,"^O","^16",536873967]],["^15",[205,"^@",false,536873967]],["^15",[205,"^F",200,536873967]],["^15",[205,"^X",194,536873967]],["^15",[205,"^V",194,536873967]],["^15",[205,"^U",194,536874149]],["^15",[205,"^?",["^ "],536874148]],["^15",[205,"^17",true,536873967]],["^15",[205,"^;","~u64aa688d-c8de-4d03-af70-c1ffc118e174",536873967]],["^15",[206,"^K",1688889512187,536873986]],["^15",[206,"^[",1140,536922854]],["^15",[206,"^O","^16",536922850]],["^15",[206,"^@",false,536873986]],["^15",[206,"^Y","operator",536873986]],["^15",[206,"^11","Operator",536873986]],["^15",[206,"^B",1690967807216,536925807]],["^15",[206,"^;","~u64c20233-8b72-481a-8df0-999c52057d3d",536916346]],["^15",[207,"^Q","[[Expression]]",536874109]],["^15",[207,"^O","^16",536874099]],["^15",[207,"^@",false,536874099]],["^15",[207,"^F",69,536874099]],["^15",[207,"^X",28,536874099]],["^15",[207,"^V",28,536874099]],["^15",[207,"^U",28,536874110]],["^15",[207,"^U",208,536874110]],["^15",[207,"^H",208,536916343]],["^15",[207,"^17",true,536874099]],["^15",[207,"^;","~u64aa6940-cac1-467d-bdd0-f4d2773c7343",536874099]],["^15",[208,"^K",1688889672898,536874109]],["^15",[208,"^[",210,536874118]],["^15",[208,"^O","^16",536874113]],["^15",[208,"^@",false,536874109]],["^15",[208,"^Y","expression",536874109]],["^15",[208,"^11","Expression",536874109]],["^15",[208,"^B",1688889760209,536874174]],["^15",[208,"^;","~u64c20233-4ea2-48f0-930e-bf67d71e3992",536916343]],["^15",[209,"^Q","All expressions in Rust return some value, if they don't explicitly return any value then the [[Unit Type]] is returned implicitly.",536874174]],["^15",[209,"^O","^16",536874114]],["^15",[209,"^@",false,536874114]],["^15",[209,"^F",208,536874114]],["^15",[209,"^X",208,536874114]],["^15",[209,"^V",208,536874114]],["^15",[209,"^U",208,536874153]],["^15",[209,"^U",211,536874153]],["^15",[209,"^?",["^ "],536874174]],["^15",[209,"^H",211,536874174]],["^15",[209,"^17",true,536874114]],["^15",[209,"^;","~u64aa6949-5697-40ac-92ab-d758653f706f",536874114]],["^15",[210,"^3","- All expressions in Rust return some value, if they don't explicitly return any value then the [[Unit Type]] is returned implicitly.",536874176]],["^15",[210,"^18","~m1688889760366",536874175]],["^15",[210,"^Z","pages/Expression.md",536874118]],["^15",[211,"^K",1688889731747,536874152]],["^15",[211,"^[",213,536874183]],["^15",[211,"^O","^16",536874177]],["^15",[211,"^@",false,536874152]],["^15",[211,"^Y","unit type",536874152]],["^15",[211,"^11","Unit Type",536874152]],["^15",[211,"^B",1688889789553,536874190]],["^15",[211,"^;","~u64c20232-18e3-4f35-b241-b0c61b581abd",536916337]],["^15",[212,"^Q","The Unit [[Data Type]]\nThis is a data type in [[Rust]] that is simply a [[Tuple]] with neither any type nor any value. So the type and value both become ``( )``.\nFor ex.:\n```rust\nlet tup: () = (); //ok\n```",536874190]],["^15",[212,"^O","^16",536874178]],["^15",[212,"^@",false,536874178]],["^15",[212,"^F",211,536874178]],["^15",[212,"^X",211,536874178]],["^15",[212,"^V",211,536874178]],["^15",[212,"^U",28,536874187]],["^15",[212,"^U",148,536874187]],["^15",[212,"^U",194,536874187]],["^15",[212,"^U",211,536874187]],["^15",[212,"^?",["^ "],536874190]],["^15",[212,"^H",28,536874190]],["^15",[212,"^H",148,536874190]],["^15",[212,"^H",194,536874190]],["^15",[212,"^17",true,536874178]],["^15",[212,"^;","~u64aa69a1-16b4-4a6c-9d7c-6ab1a7c9d1f2",536874178]],["^15",[213,"^3","- The Unit [[Data Type]]\n  This is a data type in [[Rust]] that is simply a [[Tuple]] with neither any type nor any value. So the type and value both become ``( )``.\n  For ex.:\n  ```rust\n  let tup: () = (); //ok\n  ```",536874192]],["^15",[213,"^18","~m1688889790404",536874191]],["^15",[213,"^Z","pages/Unit Type.md",536874183]],["^15",[214,"^Q","Fixed-size, single-type & immutable\nSyntax is ``<let/const> <mutability>: [<type>; <size n>]= [<elem1>, ..., <elem n>]``\nFor ex.:\n```rust\nlet arr: [i32;3]= [1,2,3];\nlet x= arr[0]; //to access\n```\nThe type and size can be omitted, and it is inferred.",536874428]],["^15",[214,"^O","^16",536874194]],["^15",[214,"^@",false,536874194]],["^15",[214,"^F",196,536874194]],["^15",[214,"^X",196,536874194]],["^15",[214,"^V",196,536874194]],["^15",[214,"^U",196,536874195]],["^15",[214,"^?",["^ "],536874428]],["^15",[214,"^17",true,536874194]],["^15",[214,"^;","~u64aa69d3-a4ee-4361-baed-bd3ae83d431b",536874194]],["^15",[215,"^3","- Fixed-size, single-type & immutable\n  Syntax is ``<let/const> <mutability>: [<type>; <size n>]= [<elem1>, ..., <elem n>]``\n  For ex.:\n  ```rust\n  let arr: [i32;3]= [1,2,3];\n  let x= arr[0]; //to access\n  ```\n  The type and size can be omitted, and it is inferred.\n- Just like C++, arrays occupy space on the Stack.\n- Arrays can also be initialized with default values\n  For ex.:\n  ```rust\n  let arr = [3;5];  // Has 5 values, all are 3 and of type i32 as automatically inferred.\n  ```\n- Accessing a value out of bounds leads to a [[Panic]] at runtime/compile-time if the compiler has the index available at compile-time.\n- [[Destructuring]] using [[Pattern Matching]] also works for arrays\n  For ex.:\n  ```rust\n  let arr= [1,2,3];\n  let [x,y,z] = arr;\n  ```\n-",536874632]],["^15",[215,"^18","~m1688890572361",536874631]],["^15",[215,"^Z","pages/Array.md",536874198]],["^15",[216,"^Q","Just like C++, arrays occupy space on the Stack.",536874223]],["^15",[216,"^O","^16",536874207]],["^15",[216,"^@",false,536874207]],["^15",[216,"^F",214,536874432]],["^15",[216,"^X",196,536874207]],["^15",[216,"^V",196,536874207]],["^15",[216,"^U",196,536874208]],["^15",[216,"^?",["^ "],536874432]],["^15",[216,"^17",true,536874207]],["^15",[216,"^;","~u64aa6a1a-f4ee-47ea-b2e0-05d52e95d262",536874207]],["^15",[217,"^Q","Arrays can also be initialized with default values\nFor ex.:\n```rust\nlet arr = [3;5];  // Has 5 values, all are 3 and of type i32 as automatically inferred.\n```",536874404]],["^15",[217,"^O","^16",536874304]],["^15",[217,"^@",false,536874304]],["^15",[217,"^F",216,536874304]],["^15",[217,"^X",196,536874304]],["^15",[217,"^V",196,536874304]],["^15",[217,"^U",196,536874305]],["^15",[217,"^?",["^ "],536874404]],["^15",[217,"^17",true,536874304]],["^15",[217,"^;","~u64aa6a8c-fd2f-4070-9402-af58535e0d20",536874304]],["^15",[218,"^Q","Accessing a value out of bounds leads to a [[Panic]] at runtime/compile-time if the compiler has the index available at compile-time.",536874397]],["^15",[218,"^O","^16",536874356]],["^15",[218,"^@",false,536874356]],["^15",[218,"^F",217,536874356]],["^15",[218,"^X",196,536874356]],["^15",[218,"^V",196,536874356]],["^15",[218,"^U",196,536874370]],["^15",[218,"^U",219,536874370]],["^15",[218,"^?",["^ "],536874397]],["^15",[218,"^H",219,536874397]],["^15",[218,"^17",true,536874356]],["^15",[218,"^;","~u64aa6ae6-4f63-4d66-aa54-6de273e2f6c9",536874356]],["^15",[219,"^K",1688890103093,536874369]],["^15",[219,"^[",702,536896560]],["^15",[219,"^O","^16",536896555]],["^15",[219,"^@",false,536874369]],["^15",[219,"^Y","panic",536874369]],["^15",[219,"^11","Panic",536874369]],["^15",[219,"^B",1689557113978,536897064]],["^15",[219,"^;","~u64bbdc0d-477c-4c92-bf1a-fc5bd6a79ba7",536908141]],["^15",[220,"^Q","[[Destructuring]] using [[Pattern Matching]] also works for arrays\nFor ex.:\n```rust\nlet arr= [1,2,3];\nlet [x,y,z] = arr;\n```",536874626]],["^15",[220,"^O","^16",536874400]],["^15",[220,"^@",false,536874400]],["^15",[220,"^F",218,536874400]],["^15",[220,"^X",196,536874400]],["^15",[220,"^V",196,536874400]],["^15",[220,"^U",196,536874614]],["^15",[220,"^U",202,536874614]],["^15",[220,"^U",204,536874614]],["^15",[220,"^?",["^ "],536874626]],["^15",[220,"^H",202,536874626]],["^15",[220,"^H",204,536874626]],["^15",[220,"^17",true,536874400]],["^15",[220,"^;","~u64aa6b32-b998-4d49-a97e-b955d07d72ec",536874400]],["^15",[222,"^Q","Defining the types is optional as they can be automatically inferred too.",536874452]],["^15",[222,"^O","^16",536874452]],["^15",[222,"^@",false,536874452]],["^15",[222,"^F",198,536874452]],["^15",[222,"^X",194,536874452]],["^15",[222,"^V",194,536874452]],["^15",[222,"^U",194,536874453]],["^15",[222,"^?",["^ "],536874452]],["^15",[222,"^17",true,536874452]],["^15",[222,"^;","~u64aa6b8f-fe34-4980-9408-0a065f296176",536874452]],["^15",[228,"^K",1688890484194,536874579]],["^15",[228,"^[",534,536885457]],["^15",[228,"^O","^16",536885451]],["^15",[228,"^@",false,536874579]],["^15",[228,"^Y","option type",536874579]],["^15",[228,"^11","Option Type",536874579]],["^15",[228,"^B",1689519834561,536895837]],["^15",[228,"^;","~u64bbdc0d-ce58-47d4-bd3b-e16f5db79d59",536908141]],["^15",[229,"^Q","",536874601]],["^15",[229,"^O","^16",536874601]],["^15",[229,"^@",false,536874601]],["^15",[229,"^F",166,536874601]],["^15",[229,"^X",119,536874601]],["^15",[229,"^V",119,536874601]],["^15",[229,"^U",119,536874602]],["^15",[229,"^?",["^ "],536874601]],["^15",[229,"^17",true,536874601]],["^15",[229,"^;","~u64aa6c99-3936-4328-a388-50bcdaedceba",536874601]],["^15",[230,"^Q","",536874629]],["^15",[230,"^O","^16",536874629]],["^15",[230,"^@",false,536874629]],["^15",[230,"^F",220,536874629]],["^15",[230,"^X",196,536874629]],["^15",[230,"^V",196,536874629]],["^15",[230,"^U",196,536874630]],["^15",[230,"^?",["^ "],536874629]],["^15",[230,"^17",true,536874629]],["^15",[230,"^;","~u64aa6ccb-4a60-4c82-80a4-3a5a770beb06",536874629]],["^15",[231,"^K",1688891809252,536874636]],["^15",[231,"^[",233,536874645]],["^15",[231,"^O","^16",536874640]],["^15",[231,"^@",false,536874636]],["^15",[231,"^Y","collection",536874636]],["^15",[231,"^11","Collection",536874636]],["^15",[231,"^B",1689519304403,536895480]],["^15",[231,"^;","~u64bbdc0d-1440-4751-8ca4-b1a2126e96ee",536908126]],["^15",[232,"^Q","These [[Data Type]]s are generally on the heap and are provided by the [[Standard Library]]. They  store collections of values on heap, which allows them to have unfixed size and grow dynamically. But it also means these data types take time in (de)allocation.",536874726]],["^15",[232,"^O","^16",536874641]],["^15",[232,"^@",false,536874641]],["^15",[232,"^F",234,536874677]],["^15",[232,"^X",231,536874641]],["^15",[232,"^V",231,536874641]],["^15",[232,"^U",93,536874671]],["^15",[232,"^U",148,536874671]],["^15",[232,"^U",231,536874671]],["^15",[232,"^?",["^ "],536874726]],["^15",[232,"^H",93,536874726]],["^15",[232,"^H",148,536874726]],["^15",[232,"^17",true,536874641]],["^15",[232,"^;","~u64aa71a1-137c-48ff-af10-666c4faf2753",536874641]],["^15",[233,"^3","- Advanced Data Types, that are formed by using the primitive types.\n- These [[Data Type]]s are generally on the heap and are provided by the [[Standard Library]]. They  store collections of values on heap, which allows them to have unfixed size and grow dynamically. But it also means these data types take time in (de)allocation.\n- All Collections can be found at [Docs](https://doc.rust-lang.org/std/collections/index.html)\n- [[Vector]]\n- [[String]]\n- [[HashMap]]",536895483]],["^15",[233,"^18","~m1689519304721",536895482]],["^15",[233,"^Z","pages/Collection.md",536874645]],["^15",[234,"^Q","Advanced Data Types, that are formed by using the primitive types.",536874699]],["^15",[234,"^O","^16",536874677]],["^15",[234,"^@",false,536874677]],["^15",[234,"^F",231,536874677]],["^15",[234,"^X",231,536874677]],["^15",[234,"^V",231,536874677]],["^15",[234,"^U",231,536874678]],["^15",[234,"^?",["^ "],536874699]],["^15",[234,"^17",true,536874677]],["^15",[234,"^;","~u64aa71be-8012-4b67-90ac-ed76a9c0ba4e",536874677]],["^15",[235,"^Q","",536874703]],["^15",[235,"^O","^16",536874703]],["^15",[235,"^@",false,536874703]],["^15",[235,"^F",93,536874703]],["^15",[235,"^X",93,536874703]],["^15",[235,"^V",93,536874703]],["^15",[235,"^U",93,536874704]],["^15",[235,"^?",["^ "],536874703]],["^15",[235,"^17",true,536874703]],["^15",[235,"^;","~u64aa71e4-551c-4e99-9a1e-4fcdd23f9b57",536874703]],["^15",[236,"^Q","All Collections can be found at [Docs](https://doc.rust-lang.org/std/collections/index.html)",536874757]],["^15",[236,"^O","^16",536874729]],["^15",[236,"^@",false,536874729]],["^15",[236,"^F",232,536874729]],["^15",[236,"^X",231,536874729]],["^15",[236,"^V",231,536874729]],["^15",[236,"^U",231,536874730]],["^15",[236,"^?",["^ "],536874757]],["^15",[236,"^17",true,536874729]],["^15",[236,"^;","~u64aa71fe-3348-48c9-b512-9fc2725080ef",536874729]],["^15",[237,"^Q","[[Vector]]",536874764]],["^15",[237,"^O","^16",536874760]],["^15",[237,"^@",false,536874760]],["^15",[237,"^F",236,536874760]],["^15",[237,"^X",231,536874760]],["^15",[237,"^V",231,536874760]],["^15",[237,"^U",231,536874765]],["^15",[237,"^U",238,536874765]],["^15",[237,"^?",["^ "],536874764]],["^15",[237,"^H",238,536874764]],["^15",[237,"^17",true,536874760]],["^15",[237,"^;","~u64aa7217-4fc6-4be4-96b9-09ff5504a156",536874760]],["^15",[238,"^K",1688896180187,536874764]],["^15",[238,"^[",240,536874773]],["^15",[238,"^O","^16",536874768]],["^15",[238,"^@",false,536874764]],["^15",[238,"^Y","vector",536874764]],["^15",[238,"^11","Vector",536874764]],["^15",[238,"^B",1690040323164,536910835]],["^15",[238,"^;","~u64bbdc0d-28fa-4419-b9b4-aeaa80124be6",536908141]],["^15",[239,"^Q","Just like vectors in C++. Contiguous blocks of dynamically allocated memory with same [[Data Type]]s. \nThey are defined as ``Vec<T>`` [[Struct]].\nFor ex.:\n```rust\n   let v: Vec<i32> = Vec::new(); //new empty vector\n```\nHere defining the type is necessary as that is specifying the type for the [[Generic Type]] used in ``Vec::new()``, however Rust can infer the type automatically if the vector is initialized with some value or if the vector receives values after initialization.\nFor ex.:\n```rust\nlet mut v= Vec::new();\nv.push(2); //ok\nlet v2= Vec::from([1,2]); //ok\n```\nThe variable must be mutable to make the vector mutable.",536898404]],["^15",[239,"^O","^16",536874769]],["^15",[239,"^@",false,536874769]],["^15",[239,"^F",238,536874769]],["^15",[239,"^X",238,536874769]],["^15",[239,"^V",238,536874769]],["^15",[239,"^U",131,536874895]],["^15",[239,"^U",148,536874895]],["^15",[239,"^U",238,536874895]],["^15",[239,"^U",242,536874895]],["^15",[239,"^H",131,536908141]],["^15",[239,"^H",148,536908141]],["^15",[239,"^H",242,536908141]],["^15",[239,"^17",true,536874769]],["^15",[239,"^;","~u64aa82b4-c5ea-4919-a02e-c232822598a6",536874769]],["^15",[240,"^3","- Just like vectors in C++. Contiguous blocks of dynamically allocated memory with same [[Data Type]]s. \n  They are defined as ``Vec<T>`` [[Struct]].\n  For ex.:\n  ```rust\n     let v: Vec<i32> = Vec::new(); //new empty vector\n  ```\n  Here defining the type is necessary as that is specifying the type for the [[Generic Type]] used in ``Vec::new()``, however Rust can infer the type automatically if the vector is initialized with some value or if the vector receives values after initialization.\n  For ex.:\n  ```rust\n  let mut v= Vec::new();\n  v.push(2); //ok\n  let v2= Vec::from([1,2]); //ok\n  ```\n  The variable must be mutable to make the vector mutable.\n- We can also use the ``vec!`` [[Macro]] to initialize vectors.\n  For ex.:\n  ```rust\n  let v= vec![1,2,3];\n  ```\n  Rust automatically infers the type as ``i32`` [[Number]] making the vector ``Vec<i32>``since the values are given.\n- ``.push(<value>)``\n  Pushes the value of the type to the vector.\n- Reading an individual value\n  We can do so like an array, or using the special ``.get(<int index>)`` [[Function]]. \n  ```rust\n  let arr=vec![1,2,3];\n  let elem= &arr[2]; //ok, gets an immutable reference\n  let elem2= arr[2]; //copies the value\n  let elem3= match arr.get(2) {\n  Some(value) => value,\n  None => 0\n  };\n  ```\n  The ``.get`` allows accessing invalid index without [[Panic]]king by using [[Option Type]]. The normal copy follows the [[Copy or Move]] behavior. The [[Reference Type]] access follows the [[Ownership]] and [[Borrow]] rules, i.e., if there's an immutable reference then a mutable reference can't exist.\n  For ex.:\n  ```rust\n  let mut v= vec![1,2,3];\n  let elem= &v[2]; //immutable reference\n  v.push(2); //error\n  ```\n  This code fails because even though the index itself won't be affected, the immutable reference stored in ``elem`` is pointing to a memory address that may change as the vector may need to allocate more memory with the push which takes a mutable reference and hence may need to copy all the values to the new addresses.\n- Reading the whole vector\n  We can use the ``for..in`` [[Loop]], like so\n  ```rust\n      let mut v = vec![100, 32, 57];\n      for i in &mut v {\n          *i += 50;\n      }\n  //or immutably\n      for i in &v {\n          println!(\"{i}\");\n      }\n  ```\n  The loop takes a [[Reference Type]]. We can directly use the variable to get the value, but to modify it we must use the Dereference [[Operator]] ``*``. The [[Borrow]] and [[Ownership]] rules prohibit modifying the vector inside its loop.\n- We can use [[Enumerated Type]]s or [[Trait Object]]s to store multiple [[Data Type]]s in a Vector.\n- Dropping a vector also cleans up its elements automatically\n  Meaning if we have\n  ```rust\n      {\n          let v = vec![1, 2, 3, 4];\n  \n          // do stuff with v\n      } // <- v goes out of scope and is freed here\n  ```\n  Then when ``v`` is dropped, its elements which are [[Number]]s here are cleaned up as well, the *[[Borrow]] Checker* ensures the references are valid so the dropped vector isn't accessed anymore.\n-\n-",536910838]],["^15",[240,"^18","~m1690040323526",536910837]],["^15",[240,"^Z","pages/Vector.md",536874773]],["^15",[242,"^K",1688896240112,536874827]],["^15",[242,"^[",467,536881929]],["^15",[242,"^O","^16",536881922]],["^15",[242,"^@",false,536874827]],["^15",[242,"^Y","struct",536874827]],["^15",[242,"^11","Struct",536874827]],["^15",[242,"^B",1690438072601,536917342]],["^15",[242,"^;","~u64c20233-a6d7-4aa3-a154-6e2a3d95f3ab",536916346]],["^15",[243,"^Q","",536874898]],["^15",[243,"^O","^16",536874898]],["^15",[243,"^@",false,536874898]],["^15",[243,"^F",252,536875438]],["^15",[243,"^X",238,536874898]],["^15",[243,"^V",238,536874898]],["^15",[243,"^U",238,536874899]],["^15",[243,"^17",true,536874898]],["^15",[243,"^;","~u64aa836f-82e1-4bde-8c64-b51f904a09f7",536874898]],["^15",[244,"^Q","Just like other langs, rust supports Generics. \nThey are simply abstract [[Data Type]]s that act as stand-ins for more concrete types defined elsewhere. The benefit is that we get a type definition that allows multiple [[Data Type]]s in the same place. \nRust's powerful compiler requires us to only use features allowed by the type definition, through [[Trait]]s. \n\nFor ex.: \n```rust\nfn largest<T>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n     let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list); //Rust can infer the correct type for T automatically\n}\n```\nWhilst a correct example of a Generic Type, fails to compile. This is because it is not guaranteed that every concrete type that will replace T will implement the ``>`` [[Operator]] (greater than).\nRust allows us to restrict the usage of items like ``largest`` [[Function]] here to only types that will implement this behavior, this means the call-site will fail to call the function, to do so we use [[Trait]]s, so here we make the function like so\n\n```rust\nfn largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n```\n\nAnd this says that concrete types for T must implement the ``std::cmp::PartialOrd`` [[Trait]].",536898891]],["^15",[244,"^O","^16",536874903]],["^15",[244,"^@",false,536874903]],["^15",[244,"^F",131,536874903]],["^15",[244,"^X",131,536874903]],["^15",[244,"^V",131,536874903]],["^15",[244,"^U",130,536898747]],["^15",[244,"^U",131,536898747]],["^15",[244,"^U",148,536898747]],["^15",[244,"^U",206,536898747]],["^15",[244,"^U",414,536898747]],["^15",[244,"^H",130,536916331]],["^15",[244,"^H",148,536916331]],["^15",[244,"^H",206,536916331]],["^15",[244,"^H",414,536916331]],["^15",[244,"^17",true,536874903]],["^15",[244,"^;","~u64aa8371-caa7-4bab-82f3-f0fa1b7df686",536874903]],["^15",[245,"^Q","We can also use the ``vec!`` [[Macro]] to initialize vectors.\nFor ex.:\n```rust\nlet v= vec![1,2,3];\n```\nRust automatically infers the type as ``i32`` [[Number]] making the vector ``Vec<i32>``since the values are given.",536874988]],["^15",[245,"^O","^16",536874915]],["^15",[245,"^@",false,536874915]],["^15",[245,"^F",239,536875271]],["^15",[245,"^X",238,536874915]],["^15",[245,"^V",238,536874915]],["^15",[245,"^U",119,536874966]],["^15",[245,"^U",238,536874966]],["^15",[245,"^U",246,536874966]],["^15",[245,"^H",119,536908141]],["^15",[245,"^H",246,536908141]],["^15",[245,"^17",true,536874915]],["^15",[245,"^;","~u64aa839d-076f-496c-a93f-85e1b7664322",536874915]],["^15",[246,"^K",1688896456847,536874925]],["^15",[246,"^[",900,536908106]],["^15",[246,"^O","^16",536896532]],["^15",[246,"^@",false,536874925]],["^15",[246,"^Y","macro",536874925]],["^15",[246,"^11","Macro",536874925]],["^15",[246,"^B",1690893290117,536921482]],["^15",[246,"^;","~u64c20232-8a0c-4c38-9c42-5b97398521e6",536916328]],["^15",[247,"^Q","~``.push(<value>)``\nPushes the value of the type to the vector.",536875221]],["^15",[247,"^O","^16",536874976]],["^15",[247,"^@",false,536874976]],["^15",[247,"^F",245,536874976]],["^15",[247,"^X",238,536874976]],["^15",[247,"^V",238,536874976]],["^15",[247,"^U",238,536874977]],["^15",[247,"^17",true,536874976]],["^15",[247,"^;","~u64aa83f6-05fa-4fb9-beab-afcd46db893d",536874976]],["^15",[249,"^Q","Reading an individual value\nWe can do so like an array, or using the special ``.get(<int index>)`` [[Function]]. \n```rust\nlet arr=vec![1,2,3];\nlet elem= &arr[2]; //ok, gets an immutable reference\nlet elem2= arr[2]; //copies the value\nlet elem3= match arr.get(2) {\nSome(value) => value,\nNone => 0\n};\n```\nThe ``.get`` allows accessing invalid index without [[Panic]]king by using [[Option Type]]. The normal copy follows the [[Copy or Move]] behavior. The [[Reference Type]] access follows the [[Ownership]] and [[Borrow]] rules, i.e., if there's an immutable reference then a mutable reference can't exist.\nFor ex.:\n```rust\nlet mut v= vec![1,2,3];\nlet elem= &v[2]; //immutable reference\nv.push(2); //error\n```\nThis code fails because even though the index itself won't be affected, the immutable reference stored in ``elem`` is pointing to a memory address that may change as the vector may need to allocate more memory with the push which takes a mutable reference and hence may need to copy all the values to the new addresses.",536910762]],["^15",[249,"^O","^16",536875221]],["^15",[249,"^@",false,536875221]],["^15",[249,"^F",247,536875221]],["^15",[249,"^X",238,536875221]],["^15",[249,"^V",238,536875221]],["^15",[249,"^U",130,536875486]],["^15",[249,"^U",219,536875486]],["^15",[249,"^U",228,536875486]],["^15",[249,"^U",238,536875486]],["^15",[249,"^U",253,536875486]],["^15",[249,"^U",254,536875486]],["^15",[249,"^U",255,536875486]],["^15",[249,"^U",256,536875486]],["^15",[249,"^H",130,536908141]],["^15",[249,"^H",219,536908141]],["^15",[249,"^H",228,536908141]],["^15",[249,"^H",253,536908141]],["^15",[249,"^H",254,536908141]],["^15",[249,"^H",255,536908141]],["^15",[249,"^H",256,536908141]],["^15",[249,"^17",true,536875221]],["^15",[249,"^;","~u64aa8f35-8a24-4e0a-8797-91f3d6cca3e1",536875221]],["^15",[251,"^Q","Just like other languages. \nHowever, functions by theirselves are not a data type and the compiler might inline them in some cases.\n\nUnlike *C++*, Functions can be defined anywhere, but they must be accessible by the caller’s scope.\nBasic syntax:\n``fn <function name>(<params>)-> <return type> { \n…  \nreturn <value>;\n}``\nFor ex.:\n```rust\nfn another_function(x: i32, unit_label: char) {\n println!(\"The value of x is: {x} and char is {unit_label}\");\n}\n```\n* Functions must define the types of their params in rust.",536918486]],["^15",[251,"^O","^16",536875315]],["^15",[251,"^@",false,536875315]],["^15",[251,"^F",130,536875315]],["^15",[251,"^X",130,536875315]],["^15",[251,"^V",130,536875315]],["^15",[251,"^U",130,536875316]],["^15",[251,"^?",["^ "],536918486]],["^15",[251,"^17",true,536875315]],["^15",[251,"^;","~u64aa909f-5642-48d6-849a-fdc952cc85e3",536875315]],["^15",[252,"^Q","",536875438]],["^15",[252,"^O","^16",536875438]],["^15",[252,"^@",false,536875438]],["^15",[252,"^F",263,536875798]],["^15",[252,"^X",238,536875438]],["^15",[252,"^V",238,536875438]],["^15",[252,"^U",238,536875439]],["^15",[252,"^17",true,536875438]],["^15",[252,"^;","~u64aa910f-3114-44be-b7f8-1e0ebf66c40b",536875438]],["^15",[253,"^K",1688899962462,536875468]],["^15",[253,"^[",437,536880231]],["^15",[253,"^O","^16",536880226]],["^15",[253,"^@",false,536875468]],["^15",[253,"^Y","reference type",536875468]],["^15",[253,"^11","Reference Type",536875468]],["^15",[253,"^B",1690040238749,536910793]],["^15",[253,"^;","~u64c20233-47ae-4f3d-bca7-d41564dfcca5",536916346]],["^15",[254,"^K",1688900067049,536875475]],["^15",[254,"^[",873,536908096]],["^15",[254,"^@",false,536875475]],["^15",[254,"^Y","borrow",536910760]],["^15",[254,"^11","Borrow",536910760]],["^15",[254,"^B",1690127587623,536914489]],["^15",[254,"^;","~u64c20233-0ac4-4b71-8331-fe8945501e18",536916346]],["^15",[255,"^K",1688900067050,536875475]],["^15",[255,"^[",379,536878857]],["^15",[255,"^O","^16",536878852]],["^15",[255,"^@",false,536875475]],["^15",[255,"^Y","ownership",536875475]],["^15",[255,"^11","Ownership",536875475]],["^15",[255,"^B",1688919548342,536880140]],["^15",[255,"^;","~u64c20233-e1b0-470c-a3e6-de4a7db5e73f",536916346]],["^15",[256,"^K",1688900084241,536875485]],["^15",[256,"^[",405,536879220]],["^15",[256,"^O","^16",536879182]],["^15",[256,"^@",false,536875485]],["^15",[256,"^Y","copy or move",536879212]],["^15",[256,"^11","Copy or Move",536879212]],["^15",[256,"^B",1690039193431,536910259]],["^15",[256,"^;","~u64c20233-7413-42ff-86dc-f0d99c22f11c",536916346]],["^15",[258,"^Q","Reading the whole vector\nWe can use the ``for..in`` [[Loop]], like so\n```rust\n    let mut v = vec![100, 32, 57];\n    for i in &mut v {\n        *i += 50;\n    }\n//or immutably\n    for i in &v {\n        println!(\"{i}\");\n    }\n```\nThe loop takes a [[Reference Type]]. We can directly use the variable to get the value, but to modify it we must use the Dereference [[Operator]] ``*``. The [[Borrow]] and [[Ownership]] rules prohibit modifying the vector inside its loop.",536910762]],["^15",[258,"^O","^16",536875645]],["^15",[258,"^@",false,536875645]],["^15",[258,"^F",249,536875645]],["^15",[258,"^X",238,536875645]],["^15",[258,"^V",238,536875645]],["^15",[258,"^U",206,536875744]],["^15",[258,"^U",238,536875744]],["^15",[258,"^U",253,536875744]],["^15",[258,"^U",254,536875744]],["^15",[258,"^U",255,536875744]],["^15",[258,"^U",259,536875744]],["^15",[258,"^H",206,536908141]],["^15",[258,"^H",253,536908141]],["^15",[258,"^H",254,536908141]],["^15",[258,"^H",255,536908141]],["^15",[258,"^H",259,536908141]],["^15",[258,"^17",true,536875645]],["^15",[258,"^;","~u64aa92b3-40a7-4053-809a-b38d155dbded",536875645]],["^15",[259,"^K",1688900370374,536875661]],["^15",[259,"^[",336,536878305]],["^15",[259,"^O","^16",536878300]],["^15",[259,"^@",false,536875661]],["^15",[259,"^Y","loop",536875661]],["^15",[259,"^11","Loop",536875661]],["^15",[259,"^B",1690518350740,536919009]],["^15",[259,"^;","~u64c20232-93ba-431f-837c-e1e79496ca42",536916337]],["^15",[260,"^Q","We can use [[Enumerated Type]]s or [[Trait Object]]s to store multiple [[Data Type]]s in a Vector.",536875802]],["^15",[260,"^O","^16",536875762]],["^15",[260,"^@",false,536875762]],["^15",[260,"^F",258,536875762]],["^15",[260,"^X",238,536875762]],["^15",[260,"^V",238,536875762]],["^15",[260,"^U",148,536875799]],["^15",[260,"^U",238,536875799]],["^15",[260,"^U",261,536875799]],["^15",[260,"^U",262,536875799]],["^15",[260,"^H",148,536908141]],["^15",[260,"^H",261,536908141]],["^15",[260,"^H",262,536908141]],["^15",[260,"^17",true,536875762]],["^15",[260,"^;","~u64aa93b2-307e-4630-8df6-4f40221c8a5c",536875762]],["^15",[261,"^5",511,536908120]],["^15",[261,"^K",1688900721598,536875769]],["^15",[261,"^[",510,536884374]],["^15",[261,"^O","^16",536884369]],["^15",[261,"^@",false,536875769]],["^15",[261,"^Y","enumerated type",536875769]],["^15",[261,"^11","Enumerated Type",536875769]],["^15",[261,"^?",["^ ","^19",["^1:",["Enum"]]],536884380]],["^15",[261,"^4",["^ ","^19","Enum"],536884380]],["^15",[261,"^B",1689167327017,536885447]],["^15",[261,"^;","~u64bbdc0d-c35e-42d0-8fb1-89bfc23eb9b5",536908141]],["^15",[262,"^K",1688900731041,536875776]],["^15",[262,"^[",1016,536915037]],["^15",[262,"^O","^16",536882937]],["^15",[262,"^@",false,536875776]],["^15",[262,"^Y","trait object",536875776]],["^15",[262,"^11","Trait Object",536875776]],["^15",[262,"^B",1690137599145,536915486]],["^15",[262,"^;","~u64c20233-f0a7-4c9e-bf6c-9dd312863183",536916343]],["^15",[263,"^Q","Dropping a vector also cleans up its elements automatically\nMeaning if we have\n```rust\n    {\n        let v = vec![1, 2, 3, 4];\n\n        // do stuff with v\n    } // <- v goes out of scope and is freed here\n```\nThen when ``v`` is dropped, its elements which are [[Number]]s here are cleaned up as well, the *[[Borrow]] Checker* ensures the references are valid so the dropped vector isn't accessed anymore.",536910835]],["^15",[263,"^O","^16",536875798]],["^15",[263,"^@",false,536875798]],["^15",[263,"^F",260,536875798]],["^15",[263,"^X",238,536875798]],["^15",[263,"^V",238,536875798]],["^15",[263,"^U",119,536910836]],["^15",[263,"^U",238,536910836]],["^15",[263,"^U",254,536910836]],["^15",[263,"^?",["^ "],536910835]],["^15",[263,"^H",119,536910835]],["^15",[263,"^H",254,536910835]],["^15",[263,"^17",true,536875798]],["^15",[263,"^;","~u64aa9489-8951-4333-aa9c-df728e7c743e",536875798]],["^15",[265,"^Q","[[String]]",536875882]],["^15",[265,"^O","^16",536875878]],["^15",[265,"^@",false,536875878]],["^15",[265,"^F",237,536875878]],["^15",[265,"^X",231,536875878]],["^15",[265,"^V",231,536875878]],["^15",[265,"^U",118,536875883]],["^15",[265,"^U",231,536875883]],["^15",[265,"^?",["^ "],536875882]],["^15",[265,"^H",118,536875882]],["^15",[265,"^17",true,536875878]],["^15",[265,"^;","~u64aa9f19-c26f-4f2a-b673-a4e98d25447c",536875878]],["^15",[266,"^3","alias:: str\nNot really an alias, as String and str are different things but the term is used interchangeably.\n\n- Collection of bytes, the Collection itself provides many features on the underlying bytes and interprets them as text. At the core of rust, lies only a single type, the ``str`` [[Data Type]], then the [[Standard Library]] provides the ``String`` [[Data Type]] collection.\n  \n  The ``str`` type is a string [[Slice]] so it represents a fixed-size string whereas the ``String`` type is growable. There are various methods to convert value from either type into the other.\n  \n  Despite intuition, a ``String`` is *NOT* a collection over [[Char]]s. Infact, [[Char]]s have nothing to do with strings (be they ``str`` or ``String``).\n- ``String``\n  Growable, mutable and [[Owned]] Collection which parses its bytes as UTF-8 strings.\n  The ``String`` type is simply a wrapper over [[Vector]] of bytes but with certain restrictions, guarantees and features.\n  \n  To create a new String we use ``String::new()`` much like a Vector.\n  For ex.:\n  ```rust\n  let x= “abc”.to_string();\n  let mut y=String::new();\n  y=”abc”.to_string();\n  let z= String::from(“abc”);\n  ```\n- ``str``\n  An ``str`` is just a [[Slice]] of a string meaning it is a fixed-size immutable string slice. It is also called a String literal as the ``str`` can only be declared at compile-time. However, it's [[Reference Type]] ``&str`` can be created at any time.\n  \n  For ex.:\n  ```rust\n    let value = 3;\n      let yo = match value {\n          1 => \"1\",\n          other => {\n              let someOtherValue = other.to_string();\n              &someOtherValue[..]\n          }\n      };\n  ```\n  This code results in an error as the ``&str`` from ``1`` does not have the same [[Lifetime]] as the ``other`` arm in the [[Pattern Matching]]. The first arm has an ``&str`` with static lifetime as the str is known at compile time making its reference ``&str`` have a static lifetime but the latter is only known at run-time making its lifetime smaller than the other arm. We can fix it like so\n  ```rust\n      let value = 3;\n      let _yo = match value {\n          1 => \"1\".to_string(),\n          other => {\n              let someOtherValue = other.to_string();\n              (&someOtherValue[..]).to_string()\n          }\n      };\n  ```\n  So now both arms return a ``String`` [[Data Type]]. \n  \n  \n   \n  ``\"abc\".to_owned()`` [[TODO]] also define it all better here\n- Conversion between ``String`` and ``str``\n  To convert a ``String`` to a ``str`` we use the [[Slice]] [[Operator]] like so \n  ```rust\n  let s= String::from(\"axb\");\n  let x = &s[..];\n  ```\n  ``x `` is of type ``&str`` here.\n  \n  And to convert an ``str`` to ``String``, we can\n  ```rust\n  let s= \"x\";\n  let y= String::from(s); //ok\n  let z= x.to_string(); //ok\n  ```\n  We can also use ``&str`` [[Reference Type]] with these [[Function]]s.\n  \n  * ``.as_string()``\n  Gets a ``String`` as an ``&str``, equivalent to ``&<String object>[..]`` [[Slice]].\n- ``.push_str(<String>)`` or ``.push(<Char>)``\n  Appends a String or [[Char]] to a ``String`` object.\n  \n  * Concatenation\n  A bit different in Rust due to [[Ownership]] rules. \n  ``String`` can't be concatenated to another ``String``, it can only be concatenated to an ``&str``, or ``&String`` which would be automatically coerced into ``&str`` using [[Deref Coercion]].\n  For ex.:\n  ```rust\n  let s1= String::from(\"yo\");\n  let s2= String::from(\"na\");\n  let s3= s1+ &s2; //works but s1 loses Ownership of its data.\n  ```\n  This is because the ``+`` Operation is as ``Add`` [[Method]] on any custom [[Data Type]] in Rust and the ``Add`` method for String looks like so \n  ```rust\n  fn add(self, s: &str) -> String \n  ```\n  \n  In other words, every string concatenation requires at-least one ``String``, and then there can be any number of ``&str``s and we can concatenate them.\n  For ex.:\n  ```rust\n      let s1 = String::from(\"tic\");\n      let s2 = String::from(\"tac\");\n      let s3 = String::from(\"toe\");\n  \n      let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n  ```\n  Intuitively, this makes sense because Rust needs to know of a place where to store the concatenated String, if there are only immutable [[Reference Type]]s then it doesn't have that, if it has more than one  ``String``s then it's not sure which String to use, and even if it is, the developer won't be sure which one it is and would lose [[Ownership]].\n  \n  * The ``format!(<String>)`` [[Macro]]\n  This macro is used for String concatenation as it returns a new ``String`` with all the strings concatenated.\n  For ex.:\n  ```rust\n  let s1= String::from(\"yo\");\n  let s2= String::from(\"yoaa\");\n  let s3= \"as\";\n  let s3= format!(\"{s1} and {s2} {s3}\"); //works\n  ```\n  Since it creates a new ``String``, it doesn't need the [[Ownership]] of any ``String`` and hence it takes the immutable [[Reference Type]] of all the strings passed to it.\n- Indexing\n  Integer indices to access characters (not [[Char]]) in a string in Rust isn't valid. This is because each character is UTF-8 encoded. \n  A ``String`` is a wrapper over ``Vec<u8>``, but UTF-8 requires 1 to 4 bytes (4*8 = 32 bits) per character, this variable size is by UTF-8 spec. This means it is not sure if a given index is a single character or a part of a multi-byte character and hence accessing ``String`` by index is not guaranteed to return the right character. \n  For ex.:\n  ```rust\n  let hello = \"Здравствуйте\";\n  let answer = &hello[0]; //is an error\n  ```\n  This doesn't compile in Rust as rust avoids such errors and here the error would be correct, as we are trying to get the first character, which we would expect would be the Cyrillic letter ``Ze`` and not Arabic Number ``3``, it takes 2 bytes according to UTF-8 and hence both index 0 and 1 make up the character ``Ze``. \n  \n  We can use ``&hello[0..2]`` (end exclusive) and that would work as string [[Slice]]s are allowed anyway. But String [[Slice]]s are risky, if the start or end index of a string slice bisects a character, it [[Panic]]s. \n  \n  We can see why [[Char]] isn't used to represent characters in ``String`` as string slice from 0 to 1 above would return a string with the right character, which has taken 2 bytes and Rust can't know if the string slice from 0 to 1 is a single character or it is a string.\n  \n  * There are 3 ways Rust sees characters in String. \n  For “नमस्ते”,\n  \n  It’s length is 18 in bytes and this is how it looks as a byte-array,\n  [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]\n   \n  Rust sees chars as Unicode Scalar Values, basically like this \n  ['न', 'म', 'स', '्', 'त', 'े']\n  The 4th and 6th letter here are called *diacritics* as they don’t make sense on their own. \n  \n  Lastly, here’s how we interpret these letters,\n  [\"न\", \"म\", \"स्\", \"ते\"]\n  These are the *Grapheme Clusters* of the word Namaste.\n  A grapheme cluster is a more accurate name of what we call a letter in English. \n  \n  This is why indexing is not done in Rust. This is also why, [[Slice]] operations are risky, for ex.:\n  ```rust\n  let hello = String::from(\"Здравствуйте\");\n  //hello[0..1]; //will cause the program to panic as the first byte is a part of 2 to make up a Unicode Scalar value, so \n  hello[0..2] //works\n  ```\n-\n- Raw string\n  Get a string as defined, we use ``\"\\ <string, can be multiple lines> \";``\n  \n  For ex.:\n  ```rust\n  let contents = \"\\\n  Rust:\n  safe, fast, productive.\n  Pick three.\n  Duct tape.\";\n  \n  ```\n  or use ``r#\" <string> \"#``\n  For ex.:\n  ```rust\n  let abc= r#\"my string\"#;\n  ```\n-\n-",536926311]],["^15",[266,"^18","~m1704064698348",536926310]],["^15",[266,"^Z","pages/String.md",536875888]],["^15",[267,"^Q","alias:: str\nNot really an alias, as String and str are different things but the term is used interchangeably.",536875975]],["^15",[267,"^O","^16",536875934]],["^15",[267,"~:block/invalid-properties",["^1:",[]],536875975]],["^15",[267,"^@",false,536875934]],["^15",[267,"^F",118,536875934]],["^15",[267,"^X",118,536875934]],["^15",[267,"^V",118,536875934]],["^15",[267,"^U",118,536875939]],["^15",[267,"^U",268,536875939]],["^15",[267,"^:",true,536875975]],["^15",[267,"^?",["^ ","^19",["^1:",["str"]]],536875975]],["^15",[267,"^J",["^14",["^19"]],536875975]],["^15",[267,"^4",["^ ","^19","str"],536875975]],["^15",[267,"^H",268,536875975]],["^15",[267,"^17",true,536875934]],["^15",[267,"^;","~u64aa9ffe-62e8-4d72-894d-eaf50b75a9b9",536875934]],["^15",[268,"^K",1688903682750,536875938]],["^15",[268,"^@",false,536875938]],["^15",[268,"^Y","str",536875938]],["^15",[268,"^11","str",536875938]],["^15",[268,"^B",1688903682750,536875938]],["^15",[268,"^;","~u64c20232-58fb-4e62-a876-5d0f4f54a1d5",536916334]],["^15",[271,"^Q","Collection of bytes, the Collection itself provides many features on the underlying bytes and interprets them as text. At the core of rust, lies only a single type, the ``str`` [[Data Type]], then the [[Standard Library]] provides the ``String`` [[Data Type]] collection.\n\nThe ``str`` type is a string [[Slice]] so it represents a fixed-size string whereas the ``String`` type is growable. There are various methods to convert value from either type into the other.\n\nDespite intuition, a ``String`` is *NOT* a collection over [[Char]]s. Infact, [[Char]]s have nothing to do with strings (be they ``str`` or ``String``).",536894823]],["^15",[271,"^O","^16",536875953]],["^15",[271,"^@",false,536875953]],["^15",[271,"^F",267,536875953]],["^15",[271,"^X",118,536875953]],["^15",[271,"^V",118,536875953]],["^15",[271,"^U",93,536894787]],["^15",[271,"^U",118,536894787]],["^15",[271,"^U",148,536894787]],["^15",[271,"^U",183,536894787]],["^15",[271,"^U",274,536894787]],["^15",[271,"^?",["^ "],536894823]],["^15",[271,"^H",93,536894823]],["^15",[271,"^H",148,536894823]],["^15",[271,"^H",183,536894823]],["^15",[271,"^H",274,536894823]],["^15",[271,"^17",true,536875953]],["^15",[271,"^;","~u64aaa010-71c4-4ebe-b13f-34460b036e78",536875953]],["^15",[273,"^Q","~``str``\nAn ``str`` is just a [[Slice]] of a string meaning it is a fixed-size immutable string slice. It is also called a String literal as the ``str`` can only be declared at compile-time. However, it's [[Reference Type]] ``&str`` can be created at any time.\n\nFor ex.:\n```rust\n  let value = 3;\n    let yo = match value {\n        1 => \"1\",\n        other => {\n            let someOtherValue = other.to_string();\n            &someOtherValue[..]\n        }\n    };\n```\nThis code results in an error as the ``&str`` from ``1`` does not have the same [[Lifetime]] as the ``other`` arm in the [[Pattern Matching]]. The first arm has an ``&str`` with static lifetime as the str is known at compile time making its reference ``&str`` have a static lifetime but the latter is only known at run-time making its lifetime smaller than the other arm. We can fix it like so\n```rust\n    let value = 3;\n    let _yo = match value {\n        1 => \"1\".to_string(),\n        other => {\n            let someOtherValue = other.to_string();\n            (&someOtherValue[..]).to_string()\n        }\n    };\n```\nSo now both arms return a ``String`` [[Data Type]]. \n\n\n \n``\"abc\".to_owned()`` [[TODO]] also define it all better here",536877016]],["^15",[273,"^O","^16",536876098]],["^15",[273,"^@",false,536876098]],["^15",[273,"^F",277,536876665]],["^15",[273,"^X",118,536876098]],["^15",[273,"^V",118,536876878]],["^15",[273,"^U",4,536877013]],["^15",[273,"^U",118,536877013]],["^15",[273,"^U",148,536877013]],["^15",[273,"^U",202,536877013]],["^15",[273,"^U",253,536877013]],["^15",[273,"^U",274,536877013]],["^15",[273,"^U",280,536877013]],["^15",[273,"^?",["^ "],536877016]],["^15",[273,"^H",4,536877016]],["^15",[273,"^H",148,536877016]],["^15",[273,"^H",202,536877016]],["^15",[273,"^H",253,536877016]],["^15",[273,"^H",274,536877016]],["^15",[273,"^H",280,536877016]],["^15",[273,"^17",true,536876098]],["^15",[273,"^;","~u64aaa4b0-9509-4f5d-ae5f-d54d840f18e6",536876098]],["^15",[274,"^K",1688904882197,536876102]],["^15",[274,"^[",455,536881409]],["^15",[274,"^O","^16",536881404]],["^15",[274,"^@",false,536876102]],["^15",[274,"^Y","slice",536876102]],["^15",[274,"^11","Slice",536876102]],["^15",[274,"^B",1689031694127,536881868]],["^15",[274,"^;","~u64bbdc0d-91cd-4847-ac74-30130de25d88",536908129]],["^15",[275,"^Q","Conversion between ``String`` and ``str``\nTo convert a ``String`` to a ``str`` we use the [[Slice]] [[Operator]] like so \n```rust\nlet s= String::from(\"axb\");\nlet x = &s[..];\n```\n``x `` is of type ``&str`` here.\n\nAnd to convert an ``str`` to ``String``, we can\n```rust\nlet s= \"x\";\nlet y= String::from(s); //ok\nlet z= x.to_string(); //ok\n```\nWe can also use ``&str`` [[Reference Type]] with these [[Function]]s.\n\n* ``.as_string()``\nGets a ``String`` as an ``&str``, equivalent to ``&<String object>[..]`` [[Slice]].",536895470]],["^15",[275,"^O","^16",536876191]],["^15",[275,"^@",false,536876191]],["^15",[275,"^F",273,536876878]],["^15",[275,"^X",118,536876191]],["^15",[275,"^V",118,536876191]],["^15",[275,"^U",118,536877114]],["^15",[275,"^U",130,536877114]],["^15",[275,"^U",206,536877114]],["^15",[275,"^U",253,536877114]],["^15",[275,"^U",274,536877114]],["^15",[275,"^?",["^ "],536895470]],["^15",[275,"^H",130,536895470]],["^15",[275,"^H",206,536895470]],["^15",[275,"^H",253,536895470]],["^15",[275,"^H",274,536895470]],["^15",[275,"^17",true,536876191]],["^15",[275,"^;","~u64aaa543-2598-448b-8bda-f18de01b128e",536876191]],["^15",[277,"^Q","~``String``\nGrowable, mutable and [[Owned]] Collection which parses its bytes as UTF-8 strings.\nThe ``String`` type is simply a wrapper over [[Vector]] of bytes but with certain restrictions, guarantees and features.\n\nTo create a new String we use ``String::new()`` much like a Vector.\nFor ex.:\n```rust\nlet x= “abc”.to_string();\nlet mut y=String::new();\ny=”abc”.to_string();\nlet z= String::from(“abc”);\n```",536876363]],["^15",[277,"^O","^16",536876205]],["^15",[277,"^@",false,536876205]],["^15",[277,"^F",271,536876205]],["^15",[277,"^X",118,536876205]],["^15",[277,"^V",118,536876205]],["^15",[277,"^U",118,536876290]],["^15",[277,"^U",238,536876290]],["^15",[277,"^U",278,536876290]],["^15",[277,"^?",["^ "],536876363]],["^15",[277,"^H",238,536876363]],["^15",[277,"^H",278,536876363]],["^15",[277,"^17",true,536876205]],["^15",[277,"^;","~u64aaa569-e60d-436a-a212-8e226f8467dc",536876205]],["^15",[278,"^K",1688905087063,536876215]],["^15",[278,"^O","^16",536879189]],["^15",[278,"^@",false,536876215]],["^15",[278,"^Y","owned",536876215]],["^15",[278,"^11","Owned",536876215]],["^15",[278,"^B",1688905087063,536876215]],["^15",[278,"^;","~u64aaa57f-67d6-4aa0-a932-af94c30cdd68",536876215]],["^15",[280,"^K",1688905714890,536876570]],["^15",[280,"^[",791,536903581]],["^15",[280,"^O","^16",536903576]],["^15",[280,"^@",false,536876570]],["^15",[280,"^Y","lifetime",536876570]],["^15",[280,"^11","Lifetime",536876570]],["^15",[280,"^B",1690040355718,536910841]],["^15",[280,"^;","~u64c20233-9dd3-481a-84c8-08a67ce48bb7",536916352]],["^15",[281,"^Q","~``.push_str(<String>)`` or ``.push(<Char>)``\nAppends a String or [[Char]] to a ``String`` object.\n\n* Concatenation\nA bit different in Rust due to [[Ownership]] rules. \n``String`` can't be concatenated to another ``String``, it can only be concatenated to an ``&str``, or ``&String`` which would be automatically coerced into ``&str`` using [[Deref Coercion]].\nFor ex.:\n```rust\nlet s1= String::from(\"yo\");\nlet s2= String::from(\"na\");\nlet s3= s1+ &s2; //works but s1 loses Ownership of its data.\n```\nThis is because the ``+`` Operation is as ``Add`` [[Method]] on any custom [[Data Type]] in Rust and the ``Add`` method for String looks like so \n```rust\nfn add(self, s: &str) -> String \n```\n\nIn other words, every string concatenation requires at-least one ``String``, and then there can be any number of ``&str``s and we can concatenate them.\nFor ex.:\n```rust\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n```\nIntuitively, this makes sense because Rust needs to know of a place where to store the concatenated String, if there are only immutable [[Reference Type]]s then it doesn't have that, if it has more than one  ``String``s then it's not sure which String to use, and even if it is, the developer won't be sure which one it is and would lose [[Ownership]].\n\n* The ``format!(<String>)`` [[Macro]]\nThis macro is used for String concatenation as it returns a new ``String`` with all the strings concatenated.\nFor ex.:\n```rust\nlet s1= String::from(\"yo\");\nlet s2= String::from(\"yoaa\");\nlet s3= \"as\";\nlet s3= format!(\"{s1} and {s2} {s3}\"); //works\n```\nSince it creates a new ``String``, it doesn't need the [[Ownership]] of any ``String`` and hence it takes the immutable [[Reference Type]] of all the strings passed to it.",536894678]],["^15",[281,"^O","^16",536877123]],["^15",[281,"^@",false,536877123]],["^15",[281,"^F",275,536877123]],["^15",[281,"^X",118,536877123]],["^15",[281,"^V",118,536877123]],["^15",[281,"^U",118,536894525]],["^15",[281,"^U",148,536894525]],["^15",[281,"^U",183,536894525]],["^15",[281,"^U",246,536894525]],["^15",[281,"^U",253,536894525]],["^15",[281,"^U",255,536894525]],["^15",[281,"^U",461,536894525]],["^15",[281,"^U",497,536894525]],["^15",[281,"^?",["^ "],536894678]],["^15",[281,"^H",148,536894678]],["^15",[281,"^H",183,536894678]],["^15",[281,"^H",246,536894678]],["^15",[281,"^H",253,536894678]],["^15",[281,"^H",255,536894678]],["^15",[281,"^H",461,536894678]],["^15",[281,"^H",497,536894678]],["^15",[281,"^17",true,536877123]],["^15",[281,"^;","~u64aaadd5-07a7-472f-b2ba-45ff9b12f04c",536877123]],["^15",[282,"^Q","A scope is the range within a program for which an item is valid. There's a single global scope and many local scopes in any program. A new custom scope can be created with {…}.\ntitle:: Scope\n\nFor ex.:\n```rust\nfn xyz() {\n\t{\n\t\tlet y:i32=2;\n\t}\n\tprintln!(y); //will throw error as y is not in the same scope, it is also already dropped.\n}\n```",536877537]],["^15",[282,"^O","^16",536877130]],["^15",[282,"^@",false,536877130]],["^15",[282,"^F",89,536877130]],["^15",[282,"^X",89,536877130]],["^15",[282,"^V",89,536877130]],["^15",[282,"^U",89,536877131]],["^15",[282,"^?",["^ "],536877193]],["^15",[282,"^17",true,536877130]],["^15",[282,"^;","~u64aaae3a-29bd-4c6d-a0e6-916a7fcc5536",536877130]],["^15",[283,"^3","- A scope is the range within a program for which an item is valid. There's a single global scope and many local scopes in any program. A new custom scope can be created with {…}.\n  title:: Scope\n  \n  For ex.:\n  ```rust\n  fn xyz() {\n  \t{\n  \t\tlet y:i32=2;\n  \t}\n  \tprintln!(y); //will throw error as y is not in the same scope, it is also already dropped.\n  }\n  ```\n- Return\n  A scope block always returns a value but that value is discarded if there is no receiver or there's no semicolon at the scope's end.\n  For ex.:\n  ```rust\n  let x = {\n  2\n  }; //works\n  ```\n  Scope blocks can return a custom value if there's an expression as the last instruction in them otherwise they return the [[Unit Type]] as default.\n- Variable Scope\n  \n  For ex.:\n  ```rust\n  {\n  \tlet s = “aa”; //immutable string\n  }\n  ```\n  In this example, ``s`` isn’t valid before being declared and is only valid till the end of the scope, after which it goes out of scope and is hence disposed. \n  \n  Variables also go out of scope after their last usage in the code. But this also means, that if a variable is used at the very end of the program then it will remain in scope until then. This ability of a compiler to tell if a variable is no longer is being used before the end of the scope block is called *Non-Lexical Lifetimes (NLL)*.\n  \n  * Just like RAII (Resource Acquisition Is Initialization) works in C++, the values on heap in rust are deallocated when the scope finishes. \n  For ex.:\n  ```rust\n  {\n  let s= String::from(“yo”)  //mutable string\n  }\n  ```\n  The ``s`` loses its value after the scope is finished. But this [[String]] is on the heap, so it actually has to deallocate the memory allocated for the strings. For this, rust requires the type to implement *drop* function. This function is called at the end of the scope automatically and must clear the memory.\n  \n  * [[Variable]]s are deallocated in the reverse order of their creation.",536910242]],["^15",[283,"^18","~m1690039143929",536910241]],["^15",[283,"^Z","pages/Scope.md",536877538]],["^15",[293,"^3","- Just like other languages. \n  However, functions by theirselves are not a data type and the compiler might inline them in some cases.\n  \n  Unlike *C++*, Functions can be defined anywhere, but they must be accessible by the caller’s scope.\n  Basic syntax:\n  ``fn <function name>(<params>)-> <return type> { \n  …  \n  return <value>;\n  }``\n  For ex.:\n  ```rust\n  fn another_function(x: i32, unit_label: char) {\n   println!(\"The value of x is: {x} and char is {unit_label}\");\n  }\n  ```\n  * Functions must define the types of their params in rust.\n- Return\n  Function [[Scope]] blocks follow the same return rules as any scope, also meaning that they implicitly return the [[Unit Type]] if no other type is defined . But they can also use the ``return`` keyword, which only works with functions. A return keyword immediately returns a result from a function.\n  For ex.:\n  ```rust\n  fn yo()->i32 {\n   return 2; //ok\n  }\n  \n  fn ayo()->i32 {\n   2 //also ok but '2;' won't be as this is a statement.\n  }\n  ```\n- The ``fn`` [[Data Type]] and the ``Fn`` [[Trait]]\n  Functions in Rust aren't a data type, but there's a type associated with them, the ``fn`` type. This is called a *Function Pointer* and is a [[Pointer]] type that can point to function definitions on the stack.\n  This allows us to pass functions around as arguments.\n  \n  Syntax:\n  ``\n  fn(<param type 1>, <param type n>) -> <return> type \n  ``\n  And that's how we define these types.\n  \n  For ex.:\n  ```rust\n  fn yo(x: i32) -> f64 {\n      2.0\n  }\n  \n  fn na(x: fn(i32) -> f64) {\n      x(2);\n  }\n  \n  fn main() {\n      let a: fn(i32) -> f64 = yo;\n      na(a); //works\n  }\n  ```\n  \n  * ``Fn`` [[Trait]]: Part of the 3 traits, ``Fn``, ``FnMut`` and ``FnOnce``. Function pointers implement all 3 of these traits that [[Closure]]s also use. \n  Meaning, we can use [[Generic Type]]s that constrain to [[Closure]]s with these traits, and also pass them Function Pointers. \n  \n  For ex.:\n  ```rust\n      enum Status {\n          Value(u32),\n          Stop,\n      }\n  \n  \n  fn main() {\n      let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect(); //works\n  }\n  ```\n  Here, we can create a [[Vector]] of [[Enum]]s using a [[Range]] and passing a function to an argument that accepts [[Closure]]s. \n  \n  * [[Type Alias]]: We can use them with Function Pointers like so\n  ```rust\n  fn yo(x:i32, y:i32) {} \n  fn main() {\n  type Binop = fn(i32, i32) -> ();\n   let x: Binop = yo;\n   x(2,4);//ok\n  }\n  ```\n-",536919403]],["^15",[293,"^18","~m1690519324999",536919402]],["^15",[293,"^Z","pages/Function.md",536877200]],["^15",[295,"^Q","Return\nFunction [[Scope]] blocks follow the same return rules as any scope, also meaning that they implicitly return the [[Unit Type]] if no other type is defined . But they can also use the ``return`` keyword, which only works with functions. A return keyword immediately returns a result from a function.\nFor ex.:\n```rust\nfn yo()->i32 {\n return 2; //ok\n}\n\nfn ayo()->i32 {\n 2 //also ok but '2;' won't be as this is a statement.\n}\n```",536877783]],["^15",[295,"^O","^16",536877325]],["^15",[295,"^@",false,536877325]],["^15",[295,"^F",251,536918471]],["^15",[295,"^X",130,536877325]],["^15",[295,"^V",130,536877325]],["^15",[295,"^U",89,536877777]],["^15",[295,"^U",130,536877777]],["^15",[295,"^U",211,536877777]],["^15",[295,"^?",["^ "],536918471]],["^15",[295,"^H",89,536918471]],["^15",[295,"^H",211,536918471]],["^15",[295,"^17",true,536877325]],["^15",[295,"^;","~u64aac0f6-b57f-4347-a485-d9230fe7b96b",536877325]],["^15",[296,"^Q","Statements vs Expressions\nStatements are instructions that perform some actions and don’t return a value. Expressions are the same but return a value. [[Function]]s definitions in Rust are statements. But calling a function is an \n expression. This distinction is not as visible in other languages but in rust,\n```rust\nlet x = (let y = 6); \n```\nis an error as ‘let’ is a statement and hence doesn’t return anything. \nHowever, a custom [[Scope]] block is an expression. Every scope block in Rust returns something.\n\nFor ex.:\n```rust\nlet y = {\n let x= 1;\n x+1 //Here x+1 is an expression, as it is evaluated then the value is being returned\n}; //Note the semicolon, it is required for custom scope blocks which need to return a value\nprintln!(“{}”,y); //prints 2\n```",536877539]],["^15",[296,"^O","^16",536877331]],["^15",[296,"^@",false,536877331]],["^15",[296,"^F",207,536877331]],["^15",[296,"^X",28,536877331]],["^15",[296,"^V",28,536877331]],["^15",[296,"^U",28,536877458]],["^15",[296,"^U",89,536877458]],["^15",[296,"^U",130,536877458]],["^15",[296,"^H",89,536916343]],["^15",[296,"^H",130,536916343]],["^15",[296,"^17",true,536877331]],["^15",[296,"^;","~u64aac110-9fd7-4a55-81fe-10b5d14b9a00",536877331]],["^15",[303,"^Q","",536877532]],["^15",[303,"^O","^16",536877532]],["^15",[303,"^@",false,536877532]],["^15",[303,"^F",306,536877732]],["^15",[303,"^X",130,536877532]],["^15",[303,"^V",130,536877532]],["^15",[303,"^U",130,536877533]],["^15",[303,"^?",["^ "],536877532]],["^15",[303,"^17",true,536877532]],["^15",[303,"^;","~u64aac23d-d749-4edd-abd4-35e0eeafca78",536877532]],["^15",[304,"^Q","Return\nA scope block always returns a value but that value is discarded if there is no receiver or there's no semicolon at the scope's end.\nFor ex.:\n```rust\nlet x = {\n2\n}; //works\n```\nScope blocks can return a custom value if there's an expression as the last instruction in them otherwise they return the [[Unit Type]] as default.",536877761]],["^15",[304,"^O","^16",536877553]],["^15",[304,"^@",false,536877553]],["^15",[304,"^F",282,536877553]],["^15",[304,"^X",89,536877553]],["^15",[304,"^V",89,536877553]],["^15",[304,"^U",89,536877758]],["^15",[304,"^U",211,536877758]],["^15",[304,"^?",["^ "],536877761]],["^15",[304,"^H",211,536877761]],["^15",[304,"^17",true,536877553]],["^15",[304,"^;","~u64aac246-cfae-4744-9a52-e710176df5b0",536877553]],["^15",[305,"^Q","Variable Scope\n\nFor ex.:\n```rust\n{\n\tlet s = “aa”; //immutable string\n}\n```\nIn this example, ``s`` isn’t valid before being declared and is only valid till the end of the scope, after which it goes out of scope and is hence disposed. \n\nVariables also go out of scope after their last usage in the code. But this also means, that if a variable is used at the very end of the program then it will remain in scope until then. This ability of a compiler to tell if a variable is no longer is being used before the end of the scope block is called *Non-Lexical Lifetimes (NLL)*.\n\n* Just like RAII (Resource Acquisition Is Initialization) works in C++, the values on heap in rust are deallocated when the scope finishes. \nFor ex.:\n```rust\n{\nlet s= String::from(“yo”)  //mutable string\n}\n```\nThe ``s`` loses its value after the scope is finished. But this [[String]] is on the heap, so it actually has to deallocate the memory allocated for the strings. For this, rust requires the type to implement *drop* function. This function is called at the end of the scope automatically and must clear the memory.\n\n* [[Variable]]s are deallocated in the reverse order of their creation.",536910240]],["^15",[305,"^O","^16",536877641]],["^15",[305,"^@",false,536877641]],["^15",[305,"^F",304,536877641]],["^15",[305,"^X",89,536877641]],["^15",[305,"^V",89,536877641]],["^15",[305,"^U",89,536910237]],["^15",[305,"^U",99,536910237]],["^15",[305,"^U",118,536910237]],["^15",[305,"^?",["^ "],536910240]],["^15",[305,"^H",99,536910240]],["^15",[305,"^H",118,536910240]],["^15",[305,"^17",true,536877641]],["^15",[305,"^;","~u64aac2e1-f16a-43a5-bf7d-63c6dc3f8607",536877641]],["^15",[306,"^Q","The ``fn`` [[Data Type]] and the ``Fn`` [[Trait]]\nFunctions in Rust aren't a data type, but there's a type associated with them, the ``fn`` type. This is called a *Function Pointer* and is a [[Pointer]] type that can point to function definitions on the stack.\nThis allows us to pass functions around as arguments.\n\nSyntax:\n``\nfn(<param type 1>, <param type n>) -> <return> type \n``\nAnd that's how we define these types.\n\nFor ex.:\n```rust\nfn yo(x: i32) -> f64 {\n    2.0\n}\n\nfn na(x: fn(i32) -> f64) {\n    x(2);\n}\n\nfn main() {\n    let a: fn(i32) -> f64 = yo;\n    na(a); //works\n}\n```\n\n* ``Fn`` [[Trait]]: Part of the 3 traits, ``Fn``, ``FnMut`` and ``FnOnce``. Function pointers implement all 3 of these traits that [[Closure]]s also use. \nMeaning, we can use [[Generic Type]]s that constrain to [[Closure]]s with these traits, and also pass them Function Pointers. \n\nFor ex.:\n```rust\n    enum Status {\n        Value(u32),\n        Stop,\n    }\n\n\nfn main() {\n    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect(); //works\n}\n```\nHere, we can create a [[Vector]] of [[Enum]]s using a [[Range]] and passing a function to an argument that accepts [[Closure]]s. \n\n* [[Type Alias]]: We can use them with Function Pointers like so\n```rust\nfn yo(x:i32, y:i32) {} \nfn main() {\ntype Binop = fn(i32, i32) -> ();\n let x: Binop = yo;\n x(2,4);//ok\n}\n```",536919401]],["^15",[306,"^O","^16",536877732]],["^15",[306,"^@",false,536877732]],["^15",[306,"^F",295,536877732]],["^15",[306,"^X",130,536877732]],["^15",[306,"^V",130,536877732]],["^15",[306,"^U",130,536918975]],["^15",[306,"^U",131,536918975]],["^15",[306,"^U",148,536918975]],["^15",[306,"^U",238,536918975]],["^15",[306,"^U",414,536918975]],["^15",[306,"^U",511,536918975]],["^15",[306,"^U",714,536918975]],["^15",[306,"^U",878,536918975]],["^15",[306,"^U",1062,536918975]],["^15",[306,"^U",1087,536918975]],["^15",[306,"^?",["^ "],536919401]],["^15",[306,"^H",131,536919401]],["^15",[306,"^H",148,536919401]],["^15",[306,"^H",238,536919401]],["^15",[306,"^H",414,536919401]],["^15",[306,"^H",511,536919401]],["^15",[306,"^H",714,536919401]],["^15",[306,"^H",878,536919401]],["^15",[306,"^H",1062,536919401]],["^15",[306,"^H",1087,536919401]],["^15",[306,"^17",true,536877732]],["^15",[306,"^;","~u64aac381-d8ac-42a8-a933-742a25e7c3d0",536877732]],["^15",[307,"^Q","[[Comment]]",536877803]],["^15",[307,"^O","^16",536877787]],["^15",[307,"^@",false,536877787]],["^15",[307,"^F",296,536877787]],["^15",[307,"^X",28,536877787]],["^15",[307,"^V",28,536877787]],["^15",[307,"^U",28,536877804]],["^15",[307,"^U",308,536877804]],["^15",[307,"^H",308,536916343]],["^15",[307,"^17",true,536877787]],["^15",[307,"^;","~u64aac49c-8f2c-42e4-8958-d5357865cfde",536877787]],["^15",[308,"^K",1688913064604,536877803]],["^15",[308,"^[",310,536877812]],["^15",[308,"^O","^16",536877805]],["^15",[308,"^@",false,536877803]],["^15",[308,"^Y","comment",536877803]],["^15",[308,"^11","Comment",536877803]],["^15",[308,"^B",1688913424073,536878056]],["^15",[308,"^;","~u64c20233-fff7-432f-ab5b-961731a4929c",536916343]],["^15",[309,"^Q","Works as normal, ``//`` for single line and ``/* */`` for multi-line. ``///`` and ``//!`` for documentation is supported as well.",536877969]],["^15",[309,"^O","^16",536877806]],["^15",[309,"^@",false,536877806]],["^15",[309,"^F",308,536877806]],["^15",[309,"^X",308,536877806]],["^15",[309,"^V",308,536877806]],["^15",[309,"^U",308,536877807]],["^15",[309,"^?",["^ "],536877969]],["^15",[309,"^17",true,536877806]],["^15",[309,"^;","~u64aac4a9-b386-4692-9fd4-2bab918bd74a",536877806]],["^15",[310,"^3","- Works as normal, ``//`` for single line and ``/* */`` for multi-line. ``///`` and ``//!`` for documentation is supported as well.\n- /// for documentation comments \n  /// supports Markdown in it and allows documenting things,\n  For ex.:\n  ```rust\n  /// Adds one to the number given.\n  ///\n  /// # Examples\n  ///\n  /// ```\n  /// let arg = 5;\n  /// let answer = my_crate::add_one(arg);\n  ///\n  /// assert_eq!(6, answer);\n  /// ```\n  pub fn add_one(x: i32) -> i32 {\n      x + 1\n  }\n  \n  ```\n- [[Cargo]] ``doc``\n  Running this generates the HTML documentation for all the doc commented lines by using the rustdoc tool distributed with Rust. ``–open`` flag on it will open the built HTML page.\n- ``//!``\n  These type documentation comments document the parent item of a doc comment, i.e., the item that contains the doc comment following the //! styled doc comment. \n  For ex.:\n  ```rust\n  //! # My Crate\n  //!\n  //! `my_crate` is a collection of utilities to make performing certain\n  //! calculations more convenient.\n   \n  /// Adds one to the number given.\n  // --snip--\n  fn addOne() {}\n  ```\n  Here ``//!`` documents the crate. This is because the next doc comment’s parent is the crate itself,i.e. ``///`` is in a crate and //! adds documentation for it.\n  So this is the final generated doc\n  ![image.png](../assets/image_1688913423536_0.png)",536878058]],["^15",[310,"^18","~m1688913425364",536878057]],["^15",[310,"^Z","pages/Comment.md",536877812]],["^15",[311,"^Q","/// for documentation comments \n/// supports Markdown in it and allows documenting things,\nFor ex.:\n```rust\n/// Adds one to the number given.\n///\n/// # Examples\n///\n/// ```\n/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n\n```",536877876]],["^15",[311,"^O","^16",536877827]],["^15",[311,"^@",false,536877827]],["^15",[311,"^F",309,536877827]],["^15",[311,"^X",308,536877827]],["^15",[311,"^V",308,536877827]],["^15",[311,"^U",308,536877828]],["^15",[311,"^?",["^ "],536877876]],["^15",[311,"^17",true,536877827]],["^15",[311,"^;","~u64aac4bd-a098-4eac-b1fa-5c55a13fc92d",536877827]],["^15",[312,"^Q","[[Cargo]] ``doc``\nRunning this generates the HTML documentation for all the doc commented lines by using the rustdoc tool distributed with Rust. ``–open`` flag on it will open the built HTML page.",536877914]],["^15",[312,"^O","^16",536877876]],["^15",[312,"^@",false,536877876]],["^15",[312,"^F",311,536877876]],["^15",[312,"^X",308,536877876]],["^15",[312,"^V",308,536877876]],["^15",[312,"^U",45,536877887]],["^15",[312,"^U",308,536877887]],["^15",[312,"^?",["^ "],536877908]],["^15",[312,"^H",45,536877908]],["^15",[312,"^17",true,536877876]],["^15",[312,"^;","~u64aac516-c326-4294-a3c0-ef3d2d1f9065",536877876]],["^15",[314,"^Q","~``//!``\nThese type documentation comments document the parent item of a doc comment, i.e., the item that contains the doc comment following the //! styled doc comment. \nFor ex.:\n```rust\n//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n \n/// Adds one to the number given.\n// --snip--\nfn addOne() {}\n```\nHere ``//!`` documents the crate. This is because the next doc comment’s parent is the crate itself,i.e. ``///`` is in a crate and //! adds documentation for it.\nSo this is the final generated doc\n![image.png](../assets/image_1688913423536_0.png)",536878056]],["^15",[314,"^O","^16",536877941]],["^15",[314,"^@",false,536877941]],["^15",[314,"^F",312,536877941]],["^15",[314,"^X",308,536877941]],["^15",[314,"^V",308,536877941]],["^15",[314,"^U",308,536877942]],["^15",[314,"^?",["^ "],536878056]],["^15",[314,"^17",true,536877941]],["^15",[314,"^;","~u64aac588-3b9a-43d4-867a-0a1d1a643633",536877941]],["^15",[315,"^Q","[[Control Flow]]",536878096]],["^15",[315,"^O","^16",536878060]],["^15",[315,"^@",false,536878060]],["^15",[315,"^F",307,536878060]],["^15",[315,"^X",28,536878060]],["^15",[315,"^V",28,536878060]],["^15",[315,"^U",28,536878097]],["^15",[315,"^U",321,536878097]],["^15",[315,"^H",321,536916343]],["^15",[315,"^17",true,536878060]],["^15",[315,"^;","~u64aac62f-3a15-4e34-afbd-2ba798d1d882",536878060]],["^15",[316,"^K",1688913463408,536878064]],["^15",[316,"^[",319,536878073]],["^15",[316,"^O","^16",536878068]],["^15",[316,"^@",false,536878064]],["^15",[316,"^Y","conditional",536878064]],["^15",[316,"^11","Conditional",536878064]],["^15",[316,"^B",1689185287150,536887578]],["^15",[316,"^;","~u64c20232-1143-4673-b2bc-9e58f8e3272f",536916337]],["^15",[317,"^Q","[[Struct]]",536881920]],["^15",[317,"^O","^16",536878064]],["^15",[317,"^@",false,536878064]],["^15",[317,"^F",315,536878064]],["^15",[317,"^X",28,536878064]],["^15",[317,"^V",28,536878064]],["^15",[317,"^U",28,536881921]],["^15",[317,"^U",242,536881921]],["^15",[317,"^H",242,536916343]],["^15",[317,"^17",true,536878064]],["^15",[317,"^;","~u64aac637-ee28-465d-b171-387e17141c39",536878064]],["^15",[319,"^3","- These statements allow simple branching. Unlike languages like JS, non- [[Bool]]s aren’t automatically converted to [[Bool]]s .\n- If-else if-else\n  The ``if``/``else if``/``else`` blocks, these blocks are also called ‘arms’.\n  Syntax:\n  ``if x< y {…}\n  else if x> y {…}\n  else {…}``\n  \n  * if is an expression. So it returns a value. Hence we can do this,\n  ```rust\n  let z = if 2<3 { 2 } else { 3 };\n  ```\n  However, if we return values of differing types then it is an [[Error]] as both arms have to return values of same [[Data Type]] and that type must be assignable.\n- if let-else if-else\n  Uses [[Pattern Matching]], it's a shorter form of ``match`` expressions, as it only cares about given arms.\n  Unlike match arms which covers all cases, matches one case, if-let covers one case and ignores all the rest. We can still have multiple arms with ``if let-else if-else``.\n  Syntax:\n  ``\n  if let <Pattern> = <variable/value> { }\n  else if <Pattern> = <variable/value> { }\n  else {}\n  ``\n  \n  For ex.:\n  ```rust\n  fn main() {\n   let x= Some(2);\n   if let Some(value) = x { //Pattern matching\n    //do something with value\n   } //that's it, it implicitly does _ => () to ignore all the rest cases.\n  \n   let y =2;\n   if let 3 = y {\n    //something\n   }\n   else if let 2 = y {\n    //ya\n   }\n   else {\n     //...\n    }\n  }\n  ```\n  \n  * Unlike ``match``, if let can even use pattern matching against different variables/values in each arm.\n-\n-",536887584]],["^15",[319,"^18","~m1689185290750",536887583]],["^15",[319,"^Z","pages/Conditional.md",536878073]],["^15",[320,"^Q","if let-else if-else\nUses [[Pattern Matching]], it's a shorter form of ``match`` expressions, as it only cares about given arms.\nUnlike match arms which covers all cases, matches one case, if-let covers one case and ignores all the rest. We can still have multiple arms with ``if let-else if-else``.\nSyntax:\n``\nif let <Pattern> = <variable/value> { }\nelse if <Pattern> = <variable/value> { }\nelse {}\n``\n\nFor ex.:\n```rust\nfn main() {\n let x= Some(2);\n if let Some(value) = x { //Pattern matching\n  //do something with value\n } //that's it, it implicitly does _ => () to ignore all the rest cases.\n\n let y =2;\n if let 3 = y {\n  //something\n }\n else if let 2 = y {\n  //ya\n }\n else {\n   //...\n  }\n}\n```\n\n* Unlike ``match``, if let can even use pattern matching against different variables/values in each arm.",536887578]],["^15",[320,"^O","^16",536878092]],["^15",[320,"^@",false,536878092]],["^15",[320,"^F",326,536878252]],["^15",[320,"^X",316,536878092]],["^15",[320,"^V",316,536878092]],["^15",[320,"^U",202,536887157]],["^15",[320,"^U",316,536887157]],["^15",[320,"^?",["^ "],536887578]],["^15",[320,"^H",202,536887578]],["^15",[320,"^17",true,536878092]],["^15",[320,"^;","~u64aac656-f4b8-4365-85f4-c98da9fe9f94",536878092]],["^15",[321,"^K",1688913597812,536878096]],["^15",[321,"^[",323,536878105]],["^15",[321,"^O","^16",536878100]],["^15",[321,"^@",false,536878096]],["^15",[321,"^Y","control flow",536878096]],["^15",[321,"^11","Control Flow",536878096]],["^15",[321,"^B",1688913839666,536878296]],["^15",[321,"^;","~u64c20233-6bbc-436c-9bde-dc45fc0a278e",536916343]],["^15",[322,"^Q","These statements allow altering the flow of code execution depending on some condition.",536878108]],["^15",[322,"^O","^16",536878101]],["^15",[322,"^@",false,536878101]],["^15",[322,"^F",321,536878101]],["^15",[322,"^X",321,536878101]],["^15",[322,"^V",321,536878101]],["^15",[322,"^U",321,536878102]],["^15",[322,"^?",["^ "],536878108]],["^15",[322,"^17",true,536878101]],["^15",[322,"^;","~u64aac6be-b549-4894-baa5-30d6018b2297",536878101]],["^15",[323,"^3","- These statements allow altering the flow of code execution depending on some condition.\n- [[Conditional]]\n- [[Loop]]",536878299]],["^15",[323,"^18","~m1688913840372",536878298]],["^15",[323,"^Z","pages/Control Flow.md",536878105]],["^15",[324,"^Q","[[Conditional]]",536878112]],["^15",[324,"^O","^16",536878108]],["^15",[324,"^@",false,536878108]],["^15",[324,"^F",322,536878108]],["^15",[324,"^X",321,536878108]],["^15",[324,"^V",321,536878108]],["^15",[324,"^U",316,536878113]],["^15",[324,"^U",321,536878113]],["^15",[324,"^?",["^ "],536878112]],["^15",[324,"^H",316,536878112]],["^15",[324,"^17",true,536878108]],["^15",[324,"^;","~u64aac6d9-8529-4cac-b194-9cdec59fcb66",536878108]],["^15",[325,"^Q","These statements allow simple branching. Unlike languages like JS, non- [[Bool]]s aren’t automatically converted to [[Bool]]s .",536878125]],["^15",[325,"^O","^16",536878117]],["^15",[325,"^@",false,536878117]],["^15",[325,"^F",316,536878117]],["^15",[325,"^X",316,536878117]],["^15",[325,"^V",316,536878117]],["^15",[325,"^U",186,536878124]],["^15",[325,"^U",316,536878118]],["^15",[325,"^?",["^ "],536878125]],["^15",[325,"^H",186,536878125]],["^15",[325,"^17",true,536878117]],["^15",[325,"^;","~u64aac6e4-fae3-4a14-a3be-2795c8180413",536878117]],["^15",[326,"^Q","If-else if-else\nThe ``if``/``else if``/``else`` blocks, these blocks are also called ‘arms’.\nSyntax:\n``if x< y {…}\nelse if x> y {…}\nelse {…}``\n\n* if is an expression. So it returns a value. Hence we can do this,\n```rust\nlet z = if 2<3 { 2 } else { 3 };\n```\nHowever, if we return values of differing types then it is an [[Error]] as both arms have to return values of same [[Data Type]] and that type must be assignable.",536887316]],["^15",[326,"^O","^16",536878130]],["^15",[326,"^@",false,536878130]],["^15",[326,"^F",325,536878130]],["^15",[326,"^X",316,536878130]],["^15",[326,"^V",316,536878130]],["^15",[326,"^U",129,536878278]],["^15",[326,"^U",148,536878278]],["^15",[326,"^U",316,536878278]],["^15",[326,"^?",["^ "],536887316]],["^15",[326,"^H",129,536887316]],["^15",[326,"^H",148,536887316]],["^15",[326,"^17",true,536878130]],["^15",[326,"^;","~u64aac6f3-8e88-4f25-b71a-22c21dcfa6a1",536878130]],["^15",[333,"^Q","Rust divides errors into 2 categories, *Recoverable* and *Non-Recoverable* Errors. \nSimple errors like File not Found can be handled as their failing is expected so they are recoverable errors and are represented with the [[Result Type]], but errors such as accessing an invalid index in an [[Array]] is not expected so it is a type of non-recoverable error, these are triggered through the ``panic!`` [[Macro]].",536896462]],["^15",[333,"^O","^16",536878282]],["^15",[333,"^@",false,536878282]],["^15",[333,"^F",129,536878282]],["^15",[333,"^X",129,536878282]],["^15",[333,"^V",129,536878282]],["^15",[333,"^U",129,536896447]],["^15",[333,"^U",196,536896447]],["^15",[333,"^U",246,536896447]],["^15",[333,"^U",687,536896447]],["^15",[333,"^?",["^ "],536896462]],["^15",[333,"^H",196,536896462]],["^15",[333,"^H",246,536896462]],["^15",[333,"^H",687,536896462]],["^15",[333,"^17",true,536878282]],["^15",[333,"^;","~u64aac77b-c990-4a0c-a9c3-d6f63035ebaf",536878282]],["^15",[334,"^Q","[[Loop]]",536878296]],["^15",[334,"^O","^16",536878292]],["^15",[334,"^@",false,536878292]],["^15",[334,"^F",324,536878292]],["^15",[334,"^X",321,536878292]],["^15",[334,"^V",321,536878292]],["^15",[334,"^U",259,536878297]],["^15",[334,"^U",321,536878297]],["^15",[334,"^?",["^ "],536878296]],["^15",[334,"^H",259,536878296]],["^15",[334,"^17",true,536878292]],["^15",[334,"^;","~u64aac7ac-c834-4d02-ae28-0cd1b8f6a2fd",536878292]],["^15",[335,"^Q","~``loop``, ``while`` and ``for``. ``break`` and ``continue`` are also expressions, and can be\nused with loops for some neat operations.",536878320]],["^15",[335,"^O","^16",536878301]],["^15",[335,"^@",false,536878301]],["^15",[335,"^F",259,536878301]],["^15",[335,"^X",259,536878301]],["^15",[335,"^V",259,536878301]],["^15",[335,"^U",259,536878302]],["^15",[335,"^17",true,536878301]],["^15",[335,"^;","~u64aac7b1-c697-4323-ae88-fcc375537634",536878301]],["^15",[336,"^3","- ``loop``, ``while`` and ``for``. ``break`` and ``continue`` are also expressions, and can be\n  used with loops for some neat operations.\n- ``break``\n  Breaks the loop. Unlike other langs, break in Rust can also return values.\n- ``loop``\n  Infinite loop.\n  For ex.:\n  ```rust\n      let mut x= 1;\n      let z = loop {\n          if x==20 {\n             break 25 //semicolon not required, but can be put.\n          }\n          x+=1;\n      }; //puts 25 in z\n  ```\n  \n  * loop label: Using a custom keyword we can break/continue a specific loop. \n  For ex.\n  ```rust\n      let z = 'xyz_loop: loop {\n          if x==20 {\n             'two: loop {\n              if x==25 {\n                  break 'two;\n              }\n              x+=1;\n             }\n             break 'xyz_loop x;\n          }\n          x+=1;\n      };\n  ```\n- ``while``\n  Works as other langs.\n  ``while <condition> {\n  …\n  }``\n  \n  * while let: Using [[Pattern Matching]], while let is another form of while that also initializes a variable.\n  For ex.:\n  ```rust\n      let mut stack = Vec::new();\n   \n      stack.push(1);\n      stack.push(2);\n      stack.push(3);\n   \n      while let Some(top) = stack.pop() {\n          println!(\"{}\", top);\n      }\n  \n  ```\n- ``for``\n  In Rust, only ``for..in`` type of Loop exists. So it can only loop over [[Collection]]s or more specifically [[Iterator]]s.\n  For ex.:\n  ```rust\n  let arr = [1,2,5,3]\n  for element in arr { //copies/moves each element to element and then passes it to the body\n  \t//yuh\n  }\n  ```\n  \n  * We can create an [[Iterable]] and assign it directly to a loop with [[Range]].\n  For ex.:\n  ```rust\n  for elem in (1..4).rev() { \\\\ 1..4 generates a Range with 3 elements 1, 2, 3 and rev() reverses the range. \n   \\\\aye\n  }\n  ```\n  * for with index: If we need the index too, we can use [[Destructuring]] and the ``.iter()`` [[Function]] already implemented for all [[Iterable]]s.\n  For ex.:\n  ```rust\n  for (index, elem) in arr.iter().enumerate() {\n  //\n  } //works\n  ```\n  ``.iter()`` is already defined for [T;KSize] [[Data Type]]s and enumerate() on it returns a tuple with index and value.\n-\n-\n-",536919011]],["^15",[336,"^18","~m1690518351098",536919010]],["^15",[336,"^Z","pages/Loop.md",536878305]],["^15",[337,"^Q","~``break``\nBreaks the loop. Unlike other langs, break in Rust can also return values.",536878345]],["^15",[337,"^O","^16",536878323]],["^15",[337,"^@",false,536878323]],["^15",[337,"^F",335,536878323]],["^15",[337,"^X",259,536878323]],["^15",[337,"^V",259,536878323]],["^15",[337,"^U",259,536878324]],["^15",[337,"^17",true,536878323]],["^15",[337,"^;","~u64aacb96-660f-40c9-a18a-c973be896505",536878323]],["^15",[338,"^Q","~``loop``\nInfinite loop.\nFor ex.:\n```rust\n    let mut x= 1;\n    let z = loop {\n        if x==20 {\n           break 25 //semicolon not required, but can be put.\n        }\n        x+=1;\n    }; //puts 25 in z\n```\n\n* loop label: Using a custom keyword we can break/continue a specific loop. \nFor ex.\n```rust\n    let z = 'xyz_loop: loop {\n        if x==20 {\n           'two: loop {\n            if x==25 {\n                break 'two;\n            }\n            x+=1;\n           }\n           break 'xyz_loop x;\n        }\n        x+=1;\n    };\n```",536878446]],["^15",[338,"^O","^16",536878348]],["^15",[338,"^@",false,536878348]],["^15",[338,"^F",337,536878348]],["^15",[338,"^X",259,536878348]],["^15",[338,"^V",259,536878348]],["^15",[338,"^U",259,536878349]],["^15",[338,"^17",true,536878348]],["^15",[338,"^;","~u64aacc7a-bcd4-47be-b61a-0eb881b697a2",536878348]],["^15",[339,"^U",259,536878369]],["^15",[340,"^U",259,536878369]],["^15",[341,"^U",259,536878369]],["^15",[342,"^U",259,536878369]],["^15",[343,"^U",259,536878369]],["^15",[344,"^U",259,536878369]],["^15",[345,"^U",259,536878369]],["^15",[347,"^U",259,536878409]],["^15",[348,"^U",259,536878409]],["^15",[349,"^U",259,536878409]],["^15",[350,"^U",259,536878409]],["^15",[351,"^U",259,536878409]],["^15",[352,"^U",259,536878409]],["^15",[353,"^U",259,536878409]],["^15",[354,"^U",259,536878409]],["^15",[355,"^U",259,536878409]],["^15",[356,"^U",259,536878409]],["^15",[357,"^U",259,536878409]],["^15",[358,"^U",259,536878409]],["^15",[359,"^U",259,536878409]],["^15",[360,"^U",259,536878409]],["^15",[361,"^Q","~``while``\nWorks as other langs.\n``while <condition> {\n…\n}``\n\n* while let: Using [[Pattern Matching]], while let is another form of while that also initializes a variable.\nFor ex.:\n```rust\n    let mut stack = Vec::new();\n \n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n \n    while let Some(top) = stack.pop() {\n        println!(\"{}\", top);\n    }\n\n```",536878571]],["^15",[361,"^O","^16",536878449]],["^15",[361,"^@",false,536878449]],["^15",[361,"^F",338,536878449]],["^15",[361,"^X",259,536878449]],["^15",[361,"^V",259,536878449]],["^15",[361,"^U",202,536878525]],["^15",[361,"^U",259,536878525]],["^15",[361,"^H",202,536908126]],["^15",[361,"^17",true,536878449]],["^15",[361,"^;","~u64aacd43-3ea5-4e8f-9421-13d7b6531a34",536878449]],["^15",[362,"^U",259,536878473]],["^15",[363,"^U",259,536878473]],["^15",[364,"^U",259,536878473]],["^15",[365,"^U",259,536878507]],["^15",[366,"^U",259,536878507]],["^15",[367,"^U",259,536878507]],["^15",[368,"^U",259,536878507]],["^15",[369,"^U",259,536878507]],["^15",[370,"^U",259,536878507]],["^15",[371,"^U",259,536878507]],["^15",[372,"^U",259,536878507]],["^15",[373,"^U",259,536878507]],["^15",[374,"^Q","~``for``\nIn Rust, only ``for..in`` type of Loop exists. So it can only loop over [[Collection]]s or more specifically [[Iterator]]s.\nFor ex.:\n```rust\nlet arr = [1,2,5,3]\nfor element in arr { //copies/moves each element to element and then passes it to the body\n\t//yuh\n}\n```\n\n* We can create an [[Iterable]] and assign it directly to a loop with [[Range]].\nFor ex.:\n```rust\nfor elem in (1..4).rev() { \\\\ 1..4 generates a Range with 3 elements 1, 2, 3 and rev() reverses the range. \n \\\\aye\n}\n```\n* for with index: If we need the index too, we can use [[Destructuring]] and the ``.iter()`` [[Function]] already implemented for all [[Iterable]]s.\nFor ex.:\n```rust\nfor (index, elem) in arr.iter().enumerate() {\n//\n} //works\n```\n``.iter()`` is already defined for [T;KSize] [[Data Type]]s and enumerate() on it returns a tuple with index and value.",536919009]],["^15",[374,"^O","^16",536878558]],["^15",[374,"^@",false,536878558]],["^15",[374,"^F",361,536878558]],["^15",[374,"^X",259,536878558]],["^15",[374,"^V",259,536878558]],["^15",[374,"^U",130,536919000]],["^15",[374,"^U",148,536919000]],["^15",[374,"^U",204,536919000]],["^15",[374,"^U",231,536919000]],["^15",[374,"^U",259,536919000]],["^15",[374,"^U",375,536919000]],["^15",[374,"^U",692,536919000]],["^15",[374,"^U",1087,536919000]],["^15",[374,"^?",["^ "],536919009]],["^15",[374,"^H",130,536919009]],["^15",[374,"^H",148,536919009]],["^15",[374,"^H",204,536919009]],["^15",[374,"^H",231,536919009]],["^15",[374,"^H",375,536919009]],["^15",[374,"^H",692,536919009]],["^15",[374,"^H",1087,536919009]],["^15",[374,"^17",true,536878558]],["^15",[374,"^;","~u64aacdd3-1aea-40cb-9bd4-493e0c98b22c",536878558]],["^15",[375,"^K",1688915560257,536878632]],["^15",[375,"^@",false,536878632]],["^15",[375,"^Y","iterable",536878632]],["^15",[375,"^11","Iterable",536878632]],["^15",[375,"^B",1688915560257,536878632]],["^15",[375,"^;","~u64bbdc0d-4cd7-4789-a071-e436c28dc0d9",536908126]],["^15",[376,"^Q","",536878748]],["^15",[376,"^O","^16",536878748]],["^15",[376,"^@",false,536878748]],["^15",[376,"^F",377,536878848]],["^15",[376,"^X",259,536878748]],["^15",[376,"^V",259,536878748]],["^15",[376,"^U",259,536878749]],["^15",[376,"^17",true,536878748]],["^15",[376,"^;","~u64aacef2-91e8-4275-878e-a9064da6b0ad",536878748]],["^15",[377,"^Q","",536878848]],["^15",[377,"^O","^16",536878848]],["^15",[377,"^@",false,536878848]],["^15",[377,"^F",374,536878848]],["^15",[377,"^X",259,536878848]],["^15",[377,"^V",259,536878848]],["^15",[377,"^U",259,536878849]],["^15",[377,"^17",true,536878848]],["^15",[377,"^;","~u64aacf96-a0c8-4aa1-9f23-5009de5a4f32",536878848]],["^15",[378,"^Q","Rust is a systems programming language so it allows memory access like *C++*. All programs have to manage their memory usage, i.e. (de)allocating memory. Other languages either run a *GC* for the same  or leave it up-to the programmer (*C*). But in rust, a third method, [[Ownership]] is used. Using this method memory (de)allocation rules are checked right at compile time and the program doesn’t even compile if they aren’t followed. So rust has no *GC*, just a very guaranteeing memory model.",536879047]],["^15",[378,"^O","^16",536878853]],["^15",[378,"^@",false,536878853]],["^15",[378,"^F",255,536878853]],["^15",[378,"^X",255,536878853]],["^15",[378,"^V",255,536878853]],["^15",[378,"^U",255,536878854]],["^15",[378,"^?",["^ "],536879047]],["^15",[378,"^H",255,536879047]],["^15",[378,"^17",true,536878853]],["^15",[378,"^;","~u64aad00f-c16c-4690-a5f4-0277934f8e3a",536878853]],["^15",[379,"^3","- Rust is a systems programming language so it allows memory access like *C++*. All programs have to manage their memory usage, i.e. (de)allocating memory. Other languages either run a *GC* for the same  or leave it up-to the programmer (*C*). But in rust, a third method, [[Ownership]] is used. Using this method memory (de)allocation rules are checked right at compile time and the program doesn’t even compile if they aren’t followed. So rust has no *GC*, just a very guaranteeing memory model.\n- Stack vs Heap\n  *Stack* is a fixed size contiguous (adjacent, touching borders) segment of memory. This is a LIFO approach as data must be pushed and popped. \n  In a *heap*, the size isn’t fixed so when we want to store some data, the chunk is allocated and the address returned through a pointer. \n  Pushing to the *stack* is faster than to the *heap*, because the allocator has to allocate the space and do a few other things. \n  Same for reading. When we read from the *stack*, the entire *stack* is moved to the processor and then elements can be accessed very fastly. \n  \n  However, since a *heap* is not a contiguous segment of memory, it can’t be passed all at once to the *L caches*. So the read is slower. \n  \n  *Stack* and *heap* aren’t treated much differently in other languages but in Rust they are, and ownership rules help in understanding how Rust operates with them.\n- Ownership Rules\n  * Each value in Rust has an *owner*.\n  * There can only be one owner at a time.\n  * When the owner goes out of scope, the value will be dropped.\n- The [[Copy or Move]] defines how ownership affects [[Variable]]s.\n- Returning Ownership\n  [[Function]]s can return ownership too. \n  For ex.:\n  ```rust\n  fn main() {\n  let x = String::from(\"yo\");\n  let y = give_and_get_ownership(x); //y gets the ownership from the function\n  \n  }\n  \n  fn give_and_get_ownership(x: String)-> String {\n   x //x has the ownership here \n  }\n  \n  ```\n-\n-",536880142]],["^15",[379,"^18","~m1688919548693",536880141]],["^15",[379,"^Z","pages/Ownership.md",536878857]],["^15",[380,"^Q","Ownership Rules\n* Each value in Rust has an *owner*.\n* There can only be one owner at a time.\n* When the owner goes out of scope, the value will be dropped.",536878995]],["^15",[380,"^O","^16",536878899]],["^15",[380,"^@",false,536878899]],["^15",[380,"^F",381,536878934]],["^15",[380,"^X",255,536878899]],["^15",[380,"^V",255,536878899]],["^15",[380,"^U",255,536878900]],["^15",[380,"^?",["^ "],536878995]],["^15",[380,"^17",true,536878899]],["^15",[380,"^;","~u64aad04b-75e5-4319-a2bd-9f9a5cebfda2",536878899]],["^15",[381,"^Q","Stack vs Heap\n*Stack* is a fixed size contiguous (adjacent, touching borders) segment of memory. This is a LIFO approach as data must be pushed and popped. \nIn a *heap*, the size isn’t fixed so when we want to store some data, the chunk is allocated and the address returned through a pointer. \nPushing to the *stack* is faster than to the *heap*, because the allocator has to allocate the space and do a few other things. \nSame for reading. When we read from the *stack*, the entire *stack* is moved to the processor and then elements can be accessed very fastly. \n\nHowever, since a *heap* is not a contiguous segment of memory, it can’t be passed all at once to the *L caches*. So the read is slower. \n\n*Stack* and *heap* aren’t treated much differently in other languages but in Rust they are, and ownership rules help in understanding how Rust operates with them.",536879035]],["^15",[381,"^O","^16",536878934]],["^15",[381,"^@",false,536878934]],["^15",[381,"^F",378,536878934]],["^15",[381,"^X",255,536878934]],["^15",[381,"^V",255,536878934]],["^15",[381,"^U",255,536878935]],["^15",[381,"^?",["^ "],536879035]],["^15",[381,"^17",true,536878934]],["^15",[381,"^;","~u64aad088-2ef4-42b6-9bda-5f0cfc15c1e2",536878934]],["^15",[382,"^Q","The [[Copy or Move]] defines how ownership affects [[Variable]]s.",536879997]],["^15",[382,"^O","^16",536878996]],["^15",[382,"^@",false,536878996]],["^15",[382,"^F",380,536878996]],["^15",[382,"^X",255,536878996]],["^15",[382,"^V",255,536878996]],["^15",[382,"^U",99,536879994]],["^15",[382,"^U",255,536879994]],["^15",[382,"^U",256,536879994]],["^15",[382,"^?",["^ "],536879997]],["^15",[382,"^H",99,536879997]],["^15",[382,"^H",256,536879997]],["^15",[382,"^17",true,536878996]],["^15",[382,"^;","~u64aad0fd-c88f-404e-b9c1-59e764f7ca4f",536878996]],["^15",[383,"^U",89,536879052]],["^15",[384,"^U",89,536879052]],["^15",[385,"^U",89,536879052]],["^15",[386,"^U",89,536879052]],["^15",[387,"^U",89,536879052]],["^15",[388,"^U",89,536879052]],["^15",[389,"^U",89,536879093]],["^15",[390,"^U",89,536879093]],["^15",[391,"^U",89,536879093]],["^15",[392,"^U",89,536879093]],["^15",[393,"^U",89,536879093]],["^15",[394,"^U",89,536879093]],["^15",[396,"^Q","In Rust, values on the stack are copied automatically. \nFor ex.:\n```rust\nlet a=2;\nlet b=a;\n```\nSince this is a simple [[Data Type]] and is on the stack, it is copied directly. \n\nAnd similarly,\n```rust\nlet s1 = String.from(“hello”);\nlet s2 = s1;\n```\nThe stack also has ``s1`` and ``s2`` which hold the *Reference* to the [[String]] values on the heap so that reference is copied but not the data itself. Meaning we get\n![image.png](../assets/image_1688917576881_0.png)\n\nSo modifying one or the other would affect the other. To prevent this and also the double free problem, which is, if s1 and s2 both try to free the memory then it would cause memory corruption, Rust invalidates the copied variable. This turns the copy operation into a move operation automatically.\n\nFor ex.:\n```rust\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n \n    println!(\"{}, world!\", s1);\n```\nis an error as ``s1`` is the owner of the data and when we copy ``s1`` into ``s2``, then ``s2`` takes [[Ownership]] of the value and in doing so makes ``s1`` invalid as it doesn’t have the ownership anymore, so ``s1`` shouldn't be accessed anymore.\nSo, Rust, through [[Ownership]] rules ensure the references to the values on the heap are safe.\n\nThis is also to say, copy/move is ok but if a value has been moved we can't access it, and if we try to it is an error, but otherwise it is not.",536879958]],["^15",[396,"^O","^16",536879183]],["^15",[396,"^@",false,536879183]],["^15",[396,"^F",256,536879183]],["^15",[396,"^X",256,536879183]],["^15",[396,"^V",256,536879183]],["^15",[396,"^U",118,536879645]],["^15",[396,"^U",148,536879645]],["^15",[396,"^U",255,536879645]],["^15",[396,"^U",256,536879645]],["^15",[396,"^?",["^ "],536879958]],["^15",[396,"^H",118,536879958]],["^15",[396,"^H",148,536879958]],["^15",[396,"^H",255,536879958]],["^15",[396,"^17",true,536879183]],["^15",[396,"^;","~u64aad522-554c-4950-a988-944f7e1af54c",536879183]],["^15",[397,"^Q","",536879190]],["^15",[397,"^O","^16",536879190]],["^15",[397,"^@",false,536879190]],["^15",[397,"^F",278,536879190]],["^15",[397,"^X",278,536879190]],["^15",[397,"^V",278,536879190]],["^15",[397,"^U",278,536879191]],["^15",[397,"^?",["^ "],536879190]],["^15",[397,"^17",true,536879190]],["^15",[397,"^;","~u64aad534-ff87-4e3b-a139-ab33b663ee1e",536879190]],["^15",[400,"^U",256,536879219]],["^15",[401,"^U",256,536879219]],["^15",[402,"^U",256,536879219]],["^15",[403,"^U",256,536879219]],["^15",[404,"^U",256,536879219]],["^15",[405,"^3","- In Rust, values on the stack are copied automatically. \n  For ex.:\n  ```rust\n  let a=2;\n  let b=a;\n  ```\n  Since this is a simple [[Data Type]] and is on the stack, it is copied directly. \n  \n  And similarly,\n  ```rust\n  let s1 = String.from(“hello”);\n  let s2 = s1;\n  ```\n  The stack also has ``s1`` and ``s2`` which hold the *Reference* to the [[String]] values on the heap so that reference is copied but not the data itself. Meaning we get\n  ![image.png](../assets/image_1688917576881_0.png)\n  \n  So modifying one or the other would affect the other. To prevent this and also the double free problem, which is, if s1 and s2 both try to free the memory then it would cause memory corruption, Rust invalidates the copied variable. This turns the copy operation into a move operation automatically.\n  \n  For ex.:\n  ```rust\n      let s1 = String::from(\"hello\");\n      let s2 = s1;\n   \n      println!(\"{}, world!\", s1);\n  ```\n  is an error as ``s1`` is the owner of the data and when we copy ``s1`` into ``s2``, then ``s2`` takes [[Ownership]] of the value and in doing so makes ``s1`` invalid as it doesn’t have the ownership anymore, so ``s1`` shouldn't be accessed anymore.\n  So, Rust, through [[Ownership]] rules ensure the references to the values on the heap are safe.\n  \n  This is also to say, copy/move is ok but if a value has been moved we can't access it, and if we try to it is an error, but otherwise it is not.\n- To actually copy the data, we use the ``.clone()`` [[Function]] implemented by the [[Data Type]]s on the heap as well as [[Pointer]]s. \n  \n  For ex.:\n  ```rust\n  let s1= String::from(\"yo\");\n  let s2= s1.clone(); //This is an expensive operation as the heap will be recreated.\n  ```\n- Values on the stack such as integers can be cloned or copied, i.e., copy or ``.clone()`` are the same thing for  them. As a general rule, all scalar [[Data Type]]s use copying and not moving. And tuples also use copying if they consist of types that implement ``Copy`` [[Trait]]. \n  \n  This copy/move scenario works everywhere, even with [[Function]] calls. So passing a heap variable to a function will turn the variable invalid.\n-",536910271]],["^15",[405,"^18","~m1690039229697",536910270]],["^15",[405,"^Z","pages/Copy or Move.md",536879220]],["^15",[408,"^Q","To actually copy the data, we use the ``.clone()`` [[Function]] implemented by the [[Data Type]]s on the heap as well as [[Pointer]]s. \n\nFor ex.:\n```rust\nlet s1= String::from(\"yo\");\nlet s2= s1.clone(); //This is an expensive operation as the heap will be recreated.\n```",536910250]],["^15",[408,"^O","^16",536879628]],["^15",[408,"^@",false,536879628]],["^15",[408,"^F",396,536879628]],["^15",[408,"^X",256,536879628]],["^15",[408,"^V",256,536879628]],["^15",[408,"^U",130,536910247]],["^15",[408,"^U",148,536910247]],["^15",[408,"^U",256,536910247]],["^15",[408,"^U",878,536910247]],["^15",[408,"^?",["^ "],536910250]],["^15",[408,"^H",130,536910250]],["^15",[408,"^H",148,536910250]],["^15",[408,"^H",878,536910250]],["^15",[408,"^17",true,536879628]],["^15",[408,"^;","~u64aad7f0-c631-4b34-8148-06ef35de374d",536879628]],["^15",[413,"^Q","Values on the stack such as integers can be cloned or copied, i.e., copy or ``.clone()`` are the same thing for  them. As a general rule, all scalar [[Data Type]]s use copying and not moving. And tuples also use copying if they consist of types that implement ``Copy`` [[Trait]]. \n\nThis copy/move scenario works everywhere, even with [[Function]] calls. So passing a heap variable to a function will turn the variable invalid.",536910259]],["^15",[413,"^O","^16",536879729]],["^15",[413,"^@",false,536879729]],["^15",[413,"^F",408,536879729]],["^15",[413,"^X",256,536879729]],["^15",[413,"^V",256,536879729]],["^15",[413,"^U",130,536910263]],["^15",[413,"^U",148,536910263]],["^15",[413,"^U",256,536910263]],["^15",[413,"^U",414,536910263]],["^15",[413,"^U",945,536910263]],["^15",[413,"^?",["^ "],536910259]],["^15",[413,"^H",130,536910259]],["^15",[413,"^H",148,536910259]],["^15",[413,"^H",414,536910259]],["^15",[413,"^17",true,536879729]],["^15",[413,"^;","~u64aad8ce-4504-4fed-b45f-a195b0f264c9",536879729]],["^15",[414,"^K",1688918302350,536879788]],["^15",[414,"^[",417,536879843]],["^15",[414,"^O","^16",536879838]],["^15",[414,"^@",false,536879788]],["^15",[414,"^Y","trait",536879788]],["^15",[414,"^11","Trait",536879788]],["^15",[414,"^B",1690955532409,536924854]],["^15",[414,"^;","~u64c20233-aec4-4af6-adae-7cb9bf672d7a",536916349]],["^15",[415,"^Q","",536879813]],["^15",[415,"^O","^16",536879813]],["^15",[415,"^@",false,536879813]],["^15",[415,"^F",413,536879813]],["^15",[415,"^X",256,536879813]],["^15",[415,"^V",256,536879813]],["^15",[415,"^U",256,536879814]],["^15",[415,"^?",["^ "],536879813]],["^15",[415,"^17",true,536879813]],["^15",[415,"^;","~u64aad92c-1771-4b61-92ec-8428a30563a9",536879813]],["^15",[416,"^Q","Common Traits in the [[Standard Library]] \n* ``Copy``\nThe ``Copy`` trait can only be implemented for a [[Data Type]] if it doesn't implement the ``Drop`` Trait.\n\n* ``Sized``\nThis trait is automatically applied to all types whose size is known at compile time. We can apply it to [[Generic Type]]s and custom [[Data Type]]s too .\n \nFor ex.:\n```rust\nfn yo<T> (a: T) {}\n//is actually\n//fn yo <T:Sized> (a:T) {…}\n\n//Hence\n//fn yo<T: ?Sized> (a: &T) {…} //allows DSTs to be passed to yo as well\n```\nThe ``?<trait>`` syntax says ``T`` may or may not implement the ``Sized`` trait. This syntax is only applicable for ``Sized`` trait. We can pass [[Dynamically Sized Type]]s using this trait.",536902595]],["^15",[416,"^O","^16",536879839]],["^15",[416,"^@",false,536879839]],["^15",[416,"^F",1045,536916346]],["^15",[416,"^X",414,536879839]],["^15",[416,"^V",414,536879839]],["^15",[416,"^U",93,536902580]],["^15",[416,"^U",131,536902580]],["^15",[416,"^U",148,536902580]],["^15",[416,"^U",414,536902580]],["^15",[416,"^U",777,536902580]],["^15",[416,"^H",93,536916346]],["^15",[416,"^H",131,536916346]],["^15",[416,"^H",148,536916346]],["^15",[416,"^H",777,536916346]],["^15",[416,"^17",true,536879839]],["^15",[416,"^;","~u64aadbf4-bd1f-44ef-9ca0-d98dd91eee3c",536879839]],["^15",[417,"^3","- ``trait``\n  Kind of like an *interface* from other langs.\n  Traits allow us to define functionality that can be shared to one or more [[Data Type]]s. By [[Data Type]]s we refer to [[Struct]] and [[Enum]]s.\n- Traits are defined using ``trait``, and then for a type they are implemented using ``impl`` blocks.\n  Much like *interface*s, ``trait``s can just define the [[Method]] Signatures, and the actual implementation for the methods can be given by the type implementing the  Trait.\n  \n  Syntax:\n  ``\n  <Optional Access Modifier> trait <trait name> {\n   fn <method 1 name>(<params>)-> <Optional Return Type>;\n   //can define a default implementation\n  fn <method 2 name>(<params>)-> <Optional Return Type> { } //ok\n   ...\n    fn <method n name>(<params>)-> <Optional Return Type>;\n  }\n  ``\n  And then to implement them,\n  \n  ``\n  impl <trait name> for <Struct/Enum name> {\n   <Method 1 definition>{...}\n    <Method 2 definition>{...}\n   ...\n    <Method n definition>{...}\n  }\n  ``\n  \n  For ex.:\n  ```rust\n  pub trait Dance{\n   fn move(&Self)-> i32;\n   \n  }\n  \n  struct X{\n   x:i32,\n  }\n  \n  impl Dance for X {\n   fn move(&self)-> i32 {\n   2+2\n   }\n  }\n  \n  fn main() {\n   let x= X{2};\n   x.move(); //works\n  }\n  ```\n  \n  The [[Access Modifier]]s are applied to trait definitions too and they are *private* by default, so if a [[Crate]]/ [[Module]] has a private trait then it can't be used by an external [[Crate]] to implement the trait on its types, this doesn't mean private traits defined for public types have their implementations hidden, the implemented methods are still available to external [[Crate]]s.\n- Traits have to be implemented on [[Data Type]]s by the compile-time, Rust doesn't support dynamically implementing traits on types at runtime. So [[Function]]s can't implement Traits, but [[Macro]]s can.\n- All [[Method]]s in a trait definition without a default implementation need to be defined when the trait is implemented for a [[Data Type]].\n- Default implementation\n  A trait definition can define a default implementation for a [[Method]], and then that definition is used if the implementing type doesn't override it.\n  \n  For ex.:\n  \n  ```rust\n  pub trait Dance{\n   fn move(&Self)-> i32 { }\n  }\n  \n  struct X{\n   x:i32,\n  }\n  \n  impl Dance for X {\n  \n  }\n  //ok\n  \n  ```\n  The empty ``impl`` block is necessary as it defines ``Dance`` is being implemented on ``X``.\n  \n  Trait implementations with empty bodies are called *Marker Trait*s or *Tag Trait*s.\n- Orphan Rule\n  This is part of a property called [[coherence]]. According to it, a ``trait`` can be implemented for a type iff either the trait or the [[Data Type]] is local to the [[Crate]] (defined in the same [[Crate]]). \n  \n  For ex.:\n  If crate ``A`` defines a trait ``X`` then it can define the trait ``X`` for any [[Data Type]] , local or external, such as a type ``T`` from crate ``B``. \n  Similarly, if crate ``A`` defines a type ``T`` then it can implement trait ``X`` defined in crate B for its type ``T``. \n  But if crate ``C`` defines neither type ``T`` or trait ``X`` but takes them from crate ``A`` and ``B``, i.e., both are external then this is not allowed according to this rule.\n  \n  This is to ensure the Parent type exists, and other people’s code can’t break our own or theirs because a trait/type is defined at a place different from the crate where it is created.\n  \n  * Newtype Pattern: It is possible to avoid the Orphan Rule by simply wrapping the external type ``T`` in a new type and then implementing a trait on this new type. It's called so because of a similar pattern in Haskell.\n  For ex.:\n  ```rust\n  use std::fmt;\n   \n  struct Wrapper{\n      v: Vec<String>\n  }\n   \n  impl fmt::Display for Wrapper {\n      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n          write!(f, \"[{}]\", self.v.join(\", \"))\n      }\n  }\n   \n  fn main() {\n      let w = Wrapper{v:vec![String::from(\"hello\"), String::from(\"world\")]};\n      println!(\"w = {}\", w);\n  }\n  \n  ```\n- ``self``\n  We use ``self`` in a trait to pass an instance of the type to the function, allowing us to call other [[Method]]s and fields.\n  While this means we can’t access a type-specific method/field in a trait’s default method, we can access trait-specific methods because of it. \n  For ex.:\n  ```rust\n  pub trait X {\n      fn na();\n      fn ya(&self);\n      fn yo(&self) -> String {\n          Self::na();\n          self.ya();\n          return \"na\".to_string();\n      } //works because self will always have na() and ya() as it’s defined on trait itself.\n      fn ayo(&mut self);\n  }\n  \n  struct A {\n      x: i32,\n  }\n  \n  impl X for A {\n      fn na() {}\n      fn ya(&self) {}\n      fn ayo(&mut self) {\n          self.x += 2;\n      }\n  }\n  \n  fn main() {\n      let mut a = A { x: 2 };\n      a.ayo();\n  }\n  ```\n  However, non-default implemented trait methods can access instance fields and methods.\n- [[Function]]/ [[Method]] Parameters/Return Types can use [[Trait]]s too\n  When Parameters use traits, they require the type of object being passed as argument to implement the trait(s).\n  These are simply a syntax sugar for using [[Generic Type]]s, aka ``Trait Bound`` Syntax.\n  \n  Syntax:\n  \n  ``\n  fn <somename>(<param name>: <optional reference &> impl <trait name> + <any other trait> + .., <param 2>) {...}\n  ``\n  \n  For ex.:\n  ```rust\n  pub trait X {\n   fn notify() {}\n  }\n  pub fn notify(item: &impl X) { //Requires the type of object being passed to notify() to implement the trait X\n      println!(\"Breaking news! {}\", item.notify());\n  }\n  ```\n  \n  * ``Trait Bound`` Syntax: \n  The ``impl Trait`` is simply a syntax sugar for a longer syntax which is just the [[Generic Type]] syntax.\n  \n  For ex.:\n  ```rust\n  pub trait X {\n   fn notify() {}\n  }\n  pub fn notify<T: X>(item: &T) { \n      println!(\"Breaking news! {}\", item.notify());\n  }\n  ```\n  There's a slight difference between the 2 syntaxes, the ``impl Trait`` syntax requires simply the type of the argument object to implement the trait, but it doesn't require the object's types to be the same.\n  For ex.:\n  ```rust\n  pub trait X {\n   fn notify() {}\n  }\n  pub fn notify<T: X>(item: &T, item2: &T) {  //accepts a single type T and that T must be the same for both the args/params\n  }\n  pub fn notify(item: &impl X, item2: &impl X) {  //accepts 2 types, they can be the same, they just need to implement the trait X\n  }\n  \n  ```\n  \n  * The Return types can use the ``impl Trait`` and [[Generic Type]]s too\n  However, there's a limitation with the Rust Compiler that disallows different code paths returning different types. All code paths in a [[Function]]/ [[Method]] must return the same [[Data Type]] object, and that type must implement the given trait(s). \n  For ex.:\n  ```rust\n  pub trait X {}\n  \n  struct A{ }\n  \n  impl X for A {}\n  \n  struct B{ }\n  \n  impl X for B {}\n  \n  fn yo()-> impl X {\n   if (1==2) {\n     return A{};\n    }\n  else {\n    return B{};\n   }\n  }\n  //whilst it should work, doesn't. Gives an error as both must return the same type of object.\n  ```\n- Conditionally implementing [[Method]]s and Traits for custom [[Data Type]]s\n  Using ``Trait Bound`` Syntax, we can define methods or traits for types that have\n  given traits.\n  For ex.:\n  ```rust\n  struct X<T> {…}\n  trait Y {}\n  trait Z {\n  fn na() {}\n  }\n  \n  impl<T: Y> X<T> {\n  \tfn yo() { }\n  }\n  \n  impl<T: Y> Z for X<T> {\n  \t\n  }\n  \n  impl<T> Y for X<T> {\n  \n  }\n  ```\n  For a type ``T`` used to create the object of ``X``, the method ``yo()`` can only be called if ``T`` implements the trait ``Y`` and the methods of trait ``Z``, i.e., ``na()`` can only be called if ``T`` implements the trait ``Y``.\n  \n  This is how we conditionally implement [[Method]]s/Traits for a [[Data Type]]. Yes, this condition is resolved at compile-time itself as the concrete definitions are put in by the compiler.\n  \n  * Blanket Implementation\n  We can also apply traits to [[Generic Type]]s directly. These are known as blanket implementations as they apply a trait to multiple types.\n  \n  For ex.:\n  ```rust\n  impl<T: Display> ToString for T {\n      // --snip--\n  }\n  ```\n  This is how the ``ToString`` trait is already applied in the [[Standard Library]], for any [[Data Type]] that implements the trait ``Display``, the trait ``ToString`` is automatically applied. Similarly we can apply our own traits to multiple types at once too.\n- Multiple Traits for [[Generic Type]]s definition are combined with the ``+`` [[Operator]]\n  \n  For ex.:\n  ```rust\n  trait X{}\n  trait Y{}\n  pb fn yo<T: X+Y>() {}\n  ```\n- [[Generic Type]]s can use traits, and traits can use generics too.\n  For ex.:\n  ```rust\n  pub trait X<T> {\n      fn yo(x: T);\n      fn no(&self, x: T);\n      fn ok() -> Option<T>;\n      fn lol(&self) -> Option<T>;\n  }\n  \n  struct A {}\n  \n  impl<T> X<T> for A {\n      fn yo(x: T) {}\n      fn no(&self, x: T) {}\n      fn ok() -> Option<T> {\n          None\n      }\n      fn lol(&self) -> Option<T> {\n          None\n      }\n  }\n  \n  struct B {}\n  \n  impl X<i32> for B {\n      fn yo(x: i32) {}\n      fn no(&self, x: i32) {\n          println!(\"yo no\");\n      }\n      fn ok() -> Option<i32> {\n          println!(\"ok\");\n          None\n      }\n      fn lol(&self) -> Option<i32> {\n          None\n      }\n  }\n  \n  fn main() {\n      let a = A {};\n      a.no(2);\n      A::yo(4);\n      A::ok() as Option<i32>;\n      a.lol() as Option<i32>;\n  \n      let b = B {};\n      b.no(2);\n      //b.no(\"ab\"); //error\n      //B::ok() as Option<f64>; //error\n  } // works\n  \n  ```\n  Just like [[Method]] ``impl`` blocks we can conditionally define traits for [[Data Type]]s too. \n  However, generics or not, a trait can only be implemented once for any [[Data Type]]. So if we conditionally define a trait for a type, then it's methods are only available for that type.\n  \n  * [[Associated Type]]s provide an alternative to using traits with generics. The benefit of using associated types is that the caller code has no need of knowing the type or defining it, it is all handled by the type implementing the trait itself.\n- Common Traits in the [[Standard Library]] \n  * ``Copy``\n  The ``Copy`` trait can only be implemented for a [[Data Type]] if it doesn't implement the ``Drop`` Trait.\n  \n  * ``Sized``\n  This trait is automatically applied to all types whose size is known at compile time. We can apply it to [[Generic Type]]s and custom [[Data Type]]s too .\n   \n  For ex.:\n  ```rust\n  fn yo<T> (a: T) {}\n  //is actually\n  //fn yo <T:Sized> (a:T) {…}\n  \n  //Hence\n  //fn yo<T: ?Sized> (a: &T) {…} //allows DSTs to be passed to yo as well\n  ```\n  The ``?<trait>`` syntax says ``T`` may or may not implement the ``Sized`` trait. This syntax is only applicable for ``Sized`` trait. We can pass [[Dynamically Sized Type]]s using this trait.\n- Derivable Traits\n  By using ``#[derive]`` [[Macro Attribute]] we can make our [[Data Type]]s automatically implement a given trait. This only works for a few basic traits like ``PartialEq``. \n  For ex.:\n  ```rust\n  #[derive(PartialEq, Debug)]\n  struct X{}\n  ```\n  \n  These are some more derivable traits\n  * Comparison traits: [`Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html), [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html), [`Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html), [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n  * [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), to create `T` from `&T` via a copy.\n  * [`Copy`](https://doc.rust-lang.org/core/marker/trait.Copy.html), to give a type 'copy semantics' instead of 'move semantics'.\n  * [`Hash`](https://doc.rust-lang.org/std/hash/trait.Hash.html), to compute a hash from `&T`.\n  * [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html), to create an empty instance of a data type.\n  * [`Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html), to format a value using the `{:?}` formatter.\n- ``Deref`` and ``DerefMut``\n  Traits defined in ``std::ops``.\n  \n  * ``Deref``: Any [[Data Type]] that implements this trait can use the dereference [[Operator]] ``*``. \n  [[Pointer]]s and non-primitive [[Reference Type]]s implement it in [[Standard Library]] .\n  \n  The main method of this trait is the ``deref()`` [[Method]] which is called when value of the implementing type is getting dereferenced.\n  ``Deref`` and its ``deref()`` return immutable [[Reference Type]]s.\n  \n  * Since [[Pointer]]s implement the ``Deref`` [[Trait]], they can be dereferenced.\n  For ex.:\n  ```rust\n  fn main {\n   let x = Box::new(2);\n   println!(\"{}\", *x);\n  }\n  ```\n  That is also to say, a pointer has a [[Reference Type]] to the data (as the data is stored in a separate memory address from the pointer itself). Since Reference values can't be used without being dereferenced we need to use the ``*`` [[Operator]].\n  \n  We can implement this Trait for our types too,\n  For ex.:\n  ```rust\n  use std::ops::Deref;\n  \n  struct MyBox<T>(T);\n  \n  impl<T> MyBox<T> {\n      fn new(x: T) -> MyBox<T> {\n          MyBox(x)\n      }\n  }\n  \n  impl<T> Deref for MyBox<T> {\n      type Target = T;\n  \n      fn deref(&self) -> &Self::Target { //notice dereference returns the &T\n          &self.0\n      }\n  }\n  \n  fn main() {\n   let x = MyBox::new(2);\n   *x; //returns 2\n   //is the same as\n   *(x.deref()); //also returns 2\n  }\n  ```\n  using an [[Associated Type]] ``target``.\n  The reason ``deref()`` [[Method]] returns a [[Reference Type]] is simply because if it returned the value directly, it would invoke [[Copy or Move]] and transfer the [[Ownership]] out of ``MyBox``. \n  The main goal dereferencing is to reach a primitive type, as primitive types have the concrete implementation for how actually dereferencing works without transferring [[Ownership]] or [[Copy or Move]]ing. \n  So if our type ``T`` dereferences into a value of type ``K`` (i.e., ``T``'s ``Deref`` trait's ``deref`` method returned ``&K``) which dereferences into a primitive type such as ``i32`` then the dereference chain to go from ``&T`` to ``i32`` would be\n  ``*<T value>``->``*<K value>``->``*<i32 value>`` where the dereference of ``*<i32 value>`` is defined internally.\n  \n  The feature by which Rust automatically goes from ``*<T value>`` to ``<i32 value>`` is called [[Deref Coercion]].```\n  \n  * ``DerefMut``:  This trait and its ``deref()`` method return mutable references.\n  Rust's [[Deref Coercion]] uses the following chain\n  \n  * From ``&T`` to ``&U`` if ``T: Deref<Target=U>``, i.e., ``T`` implements the ``Deref`` trait. and returns a value of type ``&U`` from its ``deref()`` [[Method]].\n   \n  * From ``&mut T`` to ``&mut U`` if ``T: DerefMut<Target=U>``\n  * From ``&mut T`` to ``&U`` if ``T: Deref<Target=U>``\n- ``Drop`` Trait\n  This trait needs implementation for the ``drop`` [[Method]] which takes a mutable [[Borrow]] of ``self`` and then runs some cleanup/deallocation code. The ``drop`` method is called automatically by the Rust compiler when the instance of the type goes out of [[Scope]]. ``Drop`` trait is included in the [[Prelude]]. Basically, the ``drop()`` method is much like a *Destructor* from other languages.\n  \n  For ex.:\n  ```rust\n  struct MyT{ yo:i32 }\n  impl Drop for MyT {\n  \tfn drop(&mut self) {\n  \t//do something with self.yo. \n   }\n  }\n  ```\n  \n  * Smart-[[Pointer]]s implement this trait.\n  \n  * We can't explicitly call the ``drop()`` [[Method]] as it leads to the *Double Free* error. So, Rust provides a way to let the compiler know as well as call it early. It is the ``std::mem::drop(<value of type T that implements Drop>)`` [[Function]] in the [[Prelude]].\n  For ex.:\n  ```rust\n  fn main() {\n   let x = Box::new(2);\n   drop(x); //works\n  }\n  ```\n- ``Send`` and ``Sync`` Traits\n  Defined in ``std::marker``.\n  \n  The send trait indicates the [[Ownership]] of the [[Data Type]] that implements it can be transferred between threads. Almost all types in Rust implement it, but not types such as [[Rc<T>]]. \n  \n  Similarly, the sync trait indicates the type implementing it is safe to be accessed from multiple threads. \n  \n  * Both of these are known as marker traits as they are in the marker Module and they have no [[Method]]s to implement either, they just mark a type and are used to indicate rust's concurrency rules are followed. \n  Still, we can have custom implementation for both but that is part of [[unsafe]] Rust. \n  * All primitive types implement both of these. \n  * If a type is composed only of Send Trait implementing types then that type implicitly implements the send trait as well. Same with Sync trait as well.\n  * These traits are [[unsafe]].\n- [[unsafe]] Traits\n  Traits which have some [[unsafe]] [[Method]]s. \n  We declare these traits with ``unsafe`` and same for their ``impl`` blocks .\n  \n  For ex.:\n  ```rust\n  unsafe trait Foo {\n      // methods go here\n  }\n  \n  unsafe impl Foo for i32 {\n      // method implementations go here\n  }\n  \n  fn main() {}\n  ```\n- [[Supertrait]]\n- [[Future]]'s ``Future`` Trait\n  The future trait’s working helps us understand [[Async and Await]] Rust better.\n  \n  It basically looks like this, \n  ```rust\n  trait SimpleFuture {\n      type Output;\n      fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;\n  }\n   \n  enum Poll<T> {\n      Ready(T),\n      Pending,\n  }\n  ```\n  For ex. \n  ```rust\n  pub struct SocketRead<'a> {\n      socket: &'a Socket,\n  }\n   \n  impl SimpleFuture for SocketRead<'_> {\n      type Output = Vec<u8>;\n   \n      fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {\n          if self.socket.has_data_to_read() {\n              // The socket has data -- read it into a buffer and return it.\n              Poll::Ready(self.socket.read_buf())\n          } else {\n              // The socket does not yet have data.\n              //\n              // Arrange for `wake` to be called once data is available.\n              // When data becomes available, `wake` will be called, and the\n              // user of this `Future` will know to call `poll` again and\n              // receive data.\n              self.socket.set_readable_callback(wake);\n              Poll::Pending\n          }\n      }\n  }\n  ```\n  Basically, ``Future`` returns a ``Poll`` [[Enum]] from the ``poll`` [[Function]]. The [[Executor]] calls the ``poll`` function and the enum indicates if the future is complete or pending. \n  The poll function gets a [[Closure]] ``wake`` which tells the executor when it can wake and call the ``poll`` function again to forward the future towards completion. Using this functionality ``Future`` trait allows multiple Futures to be run in the same [[Thread]] as when one is pending other is run and so on for all of them.\n  \n  The actual future trait looks like so\n  ```rust\n  trait Future {\n      type Output;\n      fn poll(\n          // Note the change from `&mut self` to `Pin<&mut Self>`:\n          self: Pin<&mut Self>,\n          // and the change from `wake: fn()` to `cx: &mut Context<'_>`:\n          cx: &mut Context<'_>,\n      ) -> Poll<Self::Output>;\n  }\n  ```\n  They used [[Pinned Trait]] and the ``context`` [[Closure]] here. The ``context`` closure allows identifying which [[Function]] called the wake, otherwise it’s god’s plan as it is just a [[Pointer]] .\n  \n  A ``Future`` is stored inside a ``Waker`` [[Data Type]], this type provides the ``wake`` function and the future is also stored in this type. The executor receives this type and calls it a ``Task``. \n  \n  The ``wake`` function is essentially called through integration with an *IO-aware* system blocking primitive, such as *epoll* on Linux, *kqueue* on FreeBSD and MacOS, *IOCP* on Windows, and *ports* on Fuchsia (all of which are exposed through the cross-platform Rust [[Crate]] ``mio``). These primitives all allow a thread to block on multiple asynchronous IO events, returning once one of the events completes.\n- ``Stream`` \n  Just like [[Iterator]]s, but uses [[Async and Await]] and [[Future]]s. \n  For ex.:\n  ```rust\n  async fn send_recv() {\n      const BUFFER_SIZE: usize = 10;\n      let (mut tx, mut rx) = mpsc::channel::<i32>(BUFFER_SIZE);\n   \n      tx.send(1).await.unwrap();\n      tx.send(2).await.unwrap();\n      drop(tx);\n   \n      // `StreamExt::next` is similar to `Iterator::next`, but returns a\n      // type that implements `Future<Output = Option<T>>`.\n      assert_eq!(Some(1), rx.next().await);\n      assert_eq!(Some(2), rx.next().await);\n      assert_eq!(None, rx.next().await);\n  }\n  ```\n  or \n  when used in a [[Loop]],\n  ```rust\n  async fn sum_with_next(mut stream: Pin<&mut dyn Stream<Item = i32>>) -> i32 {\n      use futures::stream::StreamExt; // for `next`\n      let mut sum = 0;\n      while let Some(item) = stream.next().await {\n          sum += item;\n      }\n      sum\n  }\n  //for loop doesn’t work with stream. \n  ```\n-",536924856]],["^15",[417,"^18","~m1690955532711",536924855]],["^15",[417,"^Z","pages/Trait.md",536879843]],["^15",[419,"^Q","Derivable Traits\nBy using ``#[derive]`` [[Macro Attribute]] we can make our [[Data Type]]s automatically implement a given trait. This only works for a few basic traits like ``PartialEq``. \nFor ex.:\n```rust\n#[derive(PartialEq, Debug)]\nstruct X{}\n```\n\nThese are some more derivable traits\n* Comparison traits: [`Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html), [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html), [`Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html), [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n* [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), to create `T` from `&T` via a copy.\n* [`Copy`](https://doc.rust-lang.org/core/marker/trait.Copy.html), to give a type 'copy semantics' instead of 'move semantics'.\n* [`Hash`](https://doc.rust-lang.org/std/hash/trait.Hash.html), to compute a hash from `&T`.\n* [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html), to create an empty instance of a data type.\n* [`Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html), to format a value using the `{:?}` formatter.",536905509]],["^15",[419,"^O","^16",536879888]],["^15",[419,"^@",false,536879888]],["^15",[419,"^F",416,536879888]],["^15",[419,"^X",414,536879888]],["^15",[419,"^V",414,536879888]],["^15",[419,"^U",148,536905457]],["^15",[419,"^U",414,536905457]],["^15",[419,"^U",811,536905457]],["^15",[419,"^H",148,536916346]],["^15",[419,"^H",811,536916346]],["^15",[419,"^17",true,536879888]],["^15",[419,"^;","~u64aadc12-6ae3-4fa3-bb3b-7aecf095ca33",536879888]],["^15",[420,"^Q","",536879978]],["^15",[420,"^O","^16",536879978]],["^15",[420,"^@",false,536879978]],["^15",[420,"^F",421,536879993]],["^15",[420,"^X",255,536879978]],["^15",[420,"^V",255,536879978]],["^15",[420,"^U",255,536879979]],["^15",[420,"^?",["^ "],536879978]],["^15",[420,"^17",true,536879978]],["^15",[420,"^;","~u64aadd18-c033-4f3e-a97c-ffe1aa10595b",536879978]],["^15",[421,"^Q","",536879993]],["^15",[421,"^O","^16",536879993]],["^15",[421,"^@",false,536879993]],["^15",[421,"^F",422,536879997]],["^15",[421,"^X",255,536879993]],["^15",[421,"^V",255,536879993]],["^15",[421,"^U",255,536879994]],["^15",[421,"^?",["^ "],536879993]],["^15",[421,"^17",true,536879993]],["^15",[421,"^;","~u64aadd32-0c52-4d38-9ce4-e11a737de5a8",536879993]],["^15",[422,"^Q","Returning Ownership\n[[Function]]s can return ownership too. \nFor ex.:\n```rust\nfn main() {\nlet x = String::from(\"yo\");\nlet y = give_and_get_ownership(x); //y gets the ownership from the function\n\n}\n\nfn give_and_get_ownership(x: String)-> String {\n x //x has the ownership here \n}\n\n```",536880140]],["^15",[422,"^O","^16",536879997]],["^15",[422,"^@",false,536879997]],["^15",[422,"^F",382,536879997]],["^15",[422,"^X",255,536879997]],["^15",[422,"^V",255,536879997]],["^15",[422,"^U",130,536880020]],["^15",[422,"^U",255,536880020]],["^15",[422,"^?",["^ "],536880140]],["^15",[422,"^H",130,536880140]],["^15",[422,"^17",true,536879997]],["^15",[422,"^;","~u64aadd33-5a4a-47f6-8832-8120b65450af",536879997]],["^15",[425,"^12",2,536880144]],["^15",[428,"^12",2,536880149]],["^15",[431,"^12",2,536880154]],["^15",[432,"^K",1689028876292,536880190]],["^15",[432,"^O","^16",536880194]],["^15",[432,"^@",false,536880190]],["^15",[432,"^Y","rustup",536880190]],["^15",[432,"^11","rustup",536880190]],["^15",[432,"^B",1689028876292,536880190]],["^15",[432,"^;","~u64c20233-224a-49c8-82e2-90b989a9d436",536916343]],["^15",[433,"^Q","",536880195]],["^15",[433,"^O","^16",536880195]],["^15",[433,"^@",false,536880195]],["^15",[433,"^F",432,536880195]],["^15",[433,"^X",432,536880195]],["^15",[433,"^V",432,536880195]],["^15",[433,"^U",432,536880196]],["^15",[433,"^?",["^ "],536880195]],["^15",[433,"^17",true,536880195]],["^15",[433,"^;","~u64ac8919-d906-40d9-a22b-8a919af4194b",536880195]],["^15",[434,"^Q","[[Reference Type]]",536880218]],["^15",[434,"^O","^16",536880213]],["^15",[434,"^@",false,536880213]],["^15",[434,"^F",193,536880213]],["^15",[434,"^X",148,536880213]],["^15",[434,"^V",148,536880213]],["^15",[434,"^U",148,536880219]],["^15",[434,"^U",253,536880219]],["^15",[434,"^H",253,536908117]],["^15",[434,"^17",true,536880213]],["^15",[434,"^;","~u64ac895f-9a66-4b1f-b665-c0b734b23df2",536880213]],["^15",[435,"^Q","[[Pointer]]s",536908117]],["^15",[435,"^O","^16",536880220]],["^15",[435,"^@",false,536880220]],["^15",[435,"^F",434,536880220]],["^15",[435,"^X",148,536880220]],["^15",[435,"^V",148,536880220]],["^15",[435,"^U",148,536880221]],["^15",[435,"^U",878,536908117]],["^15",[435,"^H",878,536908117]],["^15",[435,"^17",true,536880220]],["^15",[435,"^;","~u64ac896a-fef2-4906-9c51-773c652d01de",536880220]],["^15",[436,"^Q","A reference in Rust, is much like a Reference in *C++*, it doesn't have take [[Ownership]], nor does it [[Copy or Move]], it simply stores a pointer to the actual value and passes it around. This is called [[Borrow]]ing. \n\nFor ex.:\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let p= &s1; //p's type is inferred as &String\n    sec(&s1);\n     println!(&s1); //ok\n}\n \nfn sec(s: &String) {\n    println!(\"{}\",s);\n}\n```\nIt looks like so\n![Three tables: the table for s contains only a pointer to the table for s1. The table for s1 contains the stack data for s1 and points to the string data on the heap.](../assets/image_1689029258981_0.png){:width 500 :height 500}\n\nHere, we do [[Borrow]]. `&` is the reference [[Operator]], it copies a reference to a value. On the contrary, we have the ``*`` [[Operator]] which is the *dereference* Operator and it reads the value at the given reference.\n\nSo with `&s1` we are borrowing the value behind ``s1``, which is to say the [[Function]] `sec` or `p` are not going to own the value ``hello``, simply have access to it. [[Borrow]] is a synonym to ‘referencing the value’ from other languages. \nBorrowed values cannot be modified, so ``sec`` can’t modify ``s`` as it is a reference.\n\nSince the [[Ownership]] of `s1` isn't given to `p` or `s`, the value inside `s1` will have a [[Lifetime]] of `s1`. Which is to say, the value inside isn't dropped when the `sec` [[Function]] is over and `s` goes out of [[Scope]].",536910793]],["^15",[436,"^O","^16",536880227]],["^15",[436,"^@",false,536880227]],["^15",[436,"^F",253,536880227]],["^15",[436,"^X",253,536880227]],["^15",[436,"^V",253,536880227]],["^15",[436,"^U",89,536880788]],["^15",[436,"^U",130,536880788]],["^15",[436,"^U",206,536880788]],["^15",[436,"^U",253,536880788]],["^15",[436,"^U",254,536908129]],["^15",[436,"^U",255,536880788]],["^15",[436,"^U",256,536880788]],["^15",[436,"^U",280,536880788]],["^15",[436,"^?",["^ "],536910793]],["^15",[436,"^H",89,536910793]],["^15",[436,"^H",130,536910793]],["^15",[436,"^H",206,536910793]],["^15",[436,"^H",254,536910793]],["^15",[436,"^H",255,536910793]],["^15",[436,"^H",256,536910793]],["^15",[436,"^H",280,536910793]],["^15",[436,"^17",true,536880227]],["^15",[436,"^;","~u64ac896c-6237-4288-a0d8-868f4524d364",536880227]],["^15",[437,"^3","- A reference in Rust, is much like a Reference in *C++*, it doesn't have take [[Ownership]], nor does it [[Copy or Move]], it simply stores a pointer to the actual value and passes it around. This is called [[Borrow]]ing. \n  \n  For ex.:\n  ```rust\n  fn main() {\n      let s1 = String::from(\"hello\");\n      let p= &s1; //p's type is inferred as &String\n      sec(&s1);\n       println!(&s1); //ok\n  }\n   \n  fn sec(s: &String) {\n      println!(\"{}\",s);\n  }\n  ```\n  It looks like so\n  ![Three tables: the table for s contains only a pointer to the table for s1. The table for s1 contains the stack data for s1 and points to the string data on the heap.](../assets/image_1689029258981_0.png){:width 500 :height 500}\n  \n  Here, we do [[Borrow]]. `&` is the reference [[Operator]], it copies a reference to a value. On the contrary, we have the ``*`` [[Operator]] which is the *dereference* Operator and it reads the value at the given reference.\n  \n  So with `&s1` we are borrowing the value behind ``s1``, which is to say the [[Function]] `sec` or `p` are not going to own the value ``hello``, simply have access to it. [[Borrow]] is a synonym to ‘referencing the value’ from other languages. \n  Borrowed values cannot be modified, so ``sec`` can’t modify ``s`` as it is a reference.\n  \n  Since the [[Ownership]] of `s1` isn't given to `p` or `s`, the value inside `s1` will have a [[Lifetime]] of `s1`. Which is to say, the value inside isn't dropped when the `sec` [[Function]] is over and `s` goes out of [[Scope]].\n- The [[Data Type]] of references is not the same as the type of the values they refer, it is a Reference Data Type which is either ``&<T>`` or ``&mut <T>``.\n- Just like [[Variable]]s, references can be *immutable* or *mutable*\n  An immutable reference is retrieved with the ``&`` [[Operator]] and the [[Data Type]] of the Reference type is ``&<T>``.\n  \n  A mutable reference is retrieved with ``& mut`` and the data type is ``& mut<T>``.\n  \n  Immutable references don't allow any modification on the value, only reads. A mutable reference does allow modification but it is very strict about that.\n  For ex.:\n  ```rust\n  fn main() {\n      let mut s = String::from(\"hello\");\n      sec(&mut s);\n  }\n   \n  fn sec(s: &mut String) {\n      s.push_str(\"yo\");\n      println!(\"{}\",s);\n  } //ok\n  ```\n  Mutable references require ``mut`` keyword on 3 things, \n  1. The [[Variable]] which will pass the mutable reference, this need to be mutable to allow mutable references being taken of it. An immutable variable can't give out a mutable reference.\n  2. The reference itself must be retrieved with the ``& mut`` keyword.\n  3. The [[Data Type]] of the mutable reference will be ``& mut T``. \n  \n  * If a value has a mutable reference to it, then it can only have the mutable reference and no other reference to it can be active at that time.\n  For ex.:\n  ```rust\n  let mut s= String::From(\"yo\");\n  let p = &mut s;\n  let x= &mut s; //ok, there are 2 mutable refs but NLL ensures p is already dropped\n  ```\n  Works, however\n  ```rust\n  let mut s= String::From(\"yo\");\n  let p = &mut s;\n  let x= &mut s; \n  \n  println!(“{} {}”, p,x); //error\n  ```\n  is an [[Error]] as both mutable references are alive at the same time.\n  \n  These restrictions ensures that an (im)mutable reference is always reading value at the correct address.\n  * There can't be a mutable reference when an immutable reference exists for a value.\n  \n  * There can be any number of immutable references, and all of them are valid even all at once.\n- Dangling pointers are avoided at compile-time itself in Rust through the use of [[Lifetime]]s.\n  For ex.:\n  ```rust\n  fn main(){\n    let p = sec();\n  }\n  \n  fn sec() -> &String{\n      let mut s = String::from(\"hello\");\n      \n      &s \n  }\n  ```\n  is an [[Error]] as even though the reference type is returned, the value itself can been already dropped. Rust knows this with the use of Lifetimes.\n- [[Slice]]\n- Do recall from *C++* that the size of a reference/pointer is fixed and it may be larger than a primitive type like [[Number]] int32 so don’t use refs for primitives. They do make things easier though.\n  \n  As can be seen here\n  ![image.png](../assets/image_1689031775031_0.png)\n- All References have an associated [[Lifetime]] with them.\n- Referencing and Dereferencing\n  \n  A [[Data Type]] ``&T`` simply stores value that is a memory address, so a ``&T`` value will never be equal/comparable to a value of type ``T``. \n  \n  ``T`` -> ``&T`` : We do this with ``<value>``-> ``&<value>``. The ``&`` [[Operator]] returns the memory address and a type ``&T`` can store the address.\n  \n  ``&T`` -> ``T`` : We do this with ``<value>`` -> ``*<value>`` where the ``*`` [[Operator]] is called the dereference operator. It accesses the value at the address pointed to by a ``&T`` value and returns a value of type ``T``.  \n  \n  * The memory address has a single type, i32 for 32-bit systems and i64 for 64-bit systems. But by having a different name for ``&T``, Rust ensures no type-checking is required when converting references/derefences.\n  \n  * Dereference of non-primitive [[Data Type]]s requires implementation of the ``Deref`` [[Trait]].\n-\n-",536910795]],["^15",[437,"^18","~m1690040239064",536910794]],["^15",[437,"^Z","pages/Reference Type.md",536880231]],["^15",[438,"^Q","Do recall from *C++* that the size of a reference/pointer is fixed and it may be larger than a primitive type like [[Number]] int32 so don’t use refs for primitives. They do make things easier though.\n\nAs can be seen here\n![image.png](../assets/image_1689031775031_0.png)",536881913]],["^15",[438,"^O","^16",536880335]],["^15",[438,"^@",false,536880335]],["^15",[438,"^F",453,536881396]],["^15",[438,"^X",253,536880335]],["^15",[438,"^V",253,536880335]],["^15",[438,"^U",119,536881901]],["^15",[438,"^U",253,536881901]],["^15",[438,"^H",119,536908129]],["^15",[438,"^17",true,536880335]],["^15",[438,"^;","~u64ac8a28-b4d8-48b9-aa99-aa001b015aa7",536880335]],["^15",[443,"^U",253,536880504]],["^15",[444,"^U",253,536880504]],["^15",[445,"^Q","Just like [[Variable]]s, references can be *immutable* or *mutable*\nAn immutable reference is retrieved with the ``&`` [[Operator]] and the [[Data Type]] of the Reference type is ``&<T>``.\n\nA mutable reference is retrieved with ``& mut`` and the data type is ``& mut<T>``.\n\nImmutable references don't allow any modification on the value, only reads. A mutable reference does allow modification but it is very strict about that.\nFor ex.:\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n    sec(&mut s);\n}\n \nfn sec(s: &mut String) {\n    s.push_str(\"yo\");\n    println!(\"{}\",s);\n} //ok\n```\nMutable references require ``mut`` keyword on 3 things, \n1. The [[Variable]] which will pass the mutable reference, this need to be mutable to allow mutable references being taken of it. An immutable variable can't give out a mutable reference.\n2. The reference itself must be retrieved with the ``& mut`` keyword.\n3. The [[Data Type]] of the mutable reference will be ``& mut T``. \n\n* If a value has a mutable reference to it, then it can only have the mutable reference and no other reference to it can be active at that time.\nFor ex.:\n```rust\nlet mut s= String::From(\"yo\");\nlet p = &mut s;\nlet x= &mut s; //ok, there are 2 mutable refs but NLL ensures p is already dropped\n```\nWorks, however\n```rust\nlet mut s= String::From(\"yo\");\nlet p = &mut s;\nlet x= &mut s; \n\nprintln!(“{} {}”, p,x); //error\n```\nis an [[Error]] as both mutable references are alive at the same time.\n\nThese restrictions ensures that an (im)mutable reference is always reading value at the correct address.\n* There can't be a mutable reference when an immutable reference exists for a value.\n\n* There can be any number of immutable references, and all of them are valid even all at once.",536908129]],["^15",[445,"^O","^16",536880789]],["^15",[445,"^@",false,536880789]],["^15",[445,"^F",447,536880895]],["^15",[445,"^X",253,536880789]],["^15",[445,"^V",253,536880789]],["^15",[445,"^U",99,536881208]],["^15",[445,"^U",129,536881208]],["^15",[445,"^U",148,536881208]],["^15",[445,"^U",206,536881208]],["^15",[445,"^U",253,536881208]],["^15",[445,"^H",99,536908129]],["^15",[445,"^H",129,536908129]],["^15",[445,"^H",148,536908129]],["^15",[445,"^H",206,536908129]],["^15",[445,"^17",true,536880789]],["^15",[445,"^;","~u64ac8c71-e4aa-40ec-accf-902555d0deb9",536880789]],["^15",[447,"^Q","The [[Data Type]] of references is not the same as the type of the values they refer, it is a Reference Data Type which is either ``&<T>`` or ``&mut <T>``.",536880965]],["^15",[447,"^O","^16",536880895]],["^15",[447,"^@",false,536880895]],["^15",[447,"^F",436,536880895]],["^15",[447,"^X",253,536880895]],["^15",[447,"^V",253,536880895]],["^15",[447,"^U",148,536880935]],["^15",[447,"^U",253,536880935]],["^15",[447,"^H",148,536908129]],["^15",[447,"^17",true,536880895]],["^15",[447,"^;","~u64ac8d08-dbe0-4a16-9db9-c1e24186384c",536880895]],["^15",[452,"^Q","Dangling pointers are avoided at compile-time itself in Rust through the use of [[Lifetime]]s.\nFor ex.:\n```rust\nfn main(){\n  let p = sec();\n}\n\nfn sec() -> &String{\n    let mut s = String::from(\"hello\");\n    \n    &s \n}\n```\nis an [[Error]] as even though the reference type is returned, the value itself can been already dropped. Rust knows this with the use of Lifetimes.",536881396]],["^15",[452,"^O","^16",536881324]],["^15",[452,"^@",false,536881324]],["^15",[452,"^F",445,536881324]],["^15",[452,"^X",253,536881324]],["^15",[452,"^V",253,536881324]],["^15",[452,"^U",129,536881372]],["^15",[452,"^U",253,536881372]],["^15",[452,"^U",280,536881372]],["^15",[452,"^H",129,536908129]],["^15",[452,"^H",280,536908129]],["^15",[452,"^17",true,536881324]],["^15",[452,"^;","~u64ac8f2e-5538-4439-b62b-288358307da8",536881324]],["^15",[453,"^Q","[[Slice]]",536881400]],["^15",[453,"^O","^16",536881396]],["^15",[453,"^@",false,536881396]],["^15",[453,"^F",452,536881396]],["^15",[453,"^X",253,536881396]],["^15",[453,"^V",253,536881396]],["^15",[453,"^U",253,536881401]],["^15",[453,"^U",274,536881401]],["^15",[453,"^H",274,536908129]],["^15",[453,"^17",true,536881396]],["^15",[453,"^;","~u64ac9002-bfbc-4b76-92e2-944a96943145",536881396]],["^15",[454,"^Q","A *slice* is a [[Reference Type]] to a contiguous segment of elements of a [[Collection]].\nSince it is a reference type, it doesn't have any [[Ownership]] of the values.\n\nFor ex.: For the [[String]], \n```rust\nlet s = String::from(“Hello”);\nlet x= &s[..];  //entire string\nlet y= &s[..5]; //index 0 to 5, end exclusive\nlet z = &s[2..]; //index 2 to the end exclusive\n//all of these have the type &str\nlet x = &mut s[..];  //type is &mut str\n```\nFor strings specifically, the indices must be valid and they must represent valid byte [[Char]]s ends, that is, the range mustn't bisect any multi-byte character in UTF-8. And only for types like ``String``, taking a slice returns a ``&str``. For other types, the slice returns ``&<T>[ ]`` [[Data Type]]. \n\n``&str`` is specially useful in [[Function]]s and [[Variable]]s , because not only can they take slices, but also ``String``s.\nFor ex.:\n```rust\nlet p= String::from(“hello”);\nlet x: &str = &p; //works as &p is coerced into &p[..]. \n```\nThis is due to [[Deref Coercion]].",536881868]],["^15",[454,"^O","^16",536881405]],["^15",[454,"^@",false,536881405]],["^15",[454,"^F",274,536881405]],["^15",[454,"^X",274,536881405]],["^15",[454,"^V",274,536881405]],["^15",[454,"^U",99,536881869]],["^15",[454,"^U",118,536881869]],["^15",[454,"^U",130,536881869]],["^15",[454,"^U",148,536881869]],["^15",[454,"^U",183,536881869]],["^15",[454,"^U",231,536881869]],["^15",[454,"^U",253,536881869]],["^15",[454,"^U",255,536881869]],["^15",[454,"^U",274,536881869]],["^15",[454,"^U",461,536881869]],["^15",[454,"^?",["^ "],536881868]],["^15",[454,"^H",99,536881868]],["^15",[454,"^H",118,536881868]],["^15",[454,"^H",130,536881868]],["^15",[454,"^H",148,536881868]],["^15",[454,"^H",183,536881868]],["^15",[454,"^H",231,536881868]],["^15",[454,"^H",253,536881868]],["^15",[454,"^H",255,536881868]],["^15",[454,"^H",461,536881868]],["^15",[454,"^17",true,536881405]],["^15",[454,"^;","~u64ac9091-6e21-4410-8f25-d81d1bbb0b0f",536881405]],["^15",[455,"^3","- A *slice* is a [[Reference Type]] to a contiguous segment of elements of a [[Collection]].\n  Since it is a reference type, it doesn't have any [[Ownership]] of the values.\n  \n  For ex.: For the [[String]], \n  ```rust\n  let s = String::from(“Hello”);\n  let x= &s[..];  //entire string\n  let y= &s[..5]; //index 0 to 5, end exclusive\n  let z = &s[2..]; //index 2 to the end exclusive\n  //all of these have the type &str\n  let x = &mut s[..];  //type is &mut str\n  ```\n  For strings specifically, the indices must be valid and they must represent valid byte [[Char]]s ends, that is, the range mustn't bisect any multi-byte character in UTF-8. And only for types like ``String``, taking a slice returns a ``&str``. For other types, the slice returns ``&<T>[ ]`` [[Data Type]]. \n  \n  ``&str`` is specially useful in [[Function]]s and [[Variable]]s , because not only can they take slices, but also ``String``s.\n  For ex.:\n  ```rust\n  let p= String::from(“hello”);\n  let x: &str = &p; //works as &p is coerced into &p[..]. \n  ```\n  This is due to [[Deref Coercion]].\n- Slices on [[Array]]s \n  For ex.:\n  ```rust\n  let a = [1,2,3,4,5];\n  let b = &a[..]; //b has the type &[i32].\n  ```\n-\n-\n-",536881871]],["^15",[455,"^18","~m1689031694890",536881870]],["^15",[455,"^Z","pages/Slice.md",536881409]],["^15",[456,"^Q","",536881534]],["^15",[456,"^O","^16",536881534]],["^15",[456,"^@",false,536881534]],["^15",[456,"^F",458,536881596]],["^15",[456,"^X",274,536881534]],["^15",[456,"^V",274,536881534]],["^15",[456,"^U",274,536881535]],["^15",[456,"^?",["^ "],536881591]],["^15",[456,"^17",true,536881534]],["^15",[456,"^;","~u64ac9144-bd85-4713-a4d0-f97216f4aea8",536881534]],["^15",[458,"^Q","",536881596]],["^15",[458,"^O","^16",536881596]],["^15",[458,"^@",false,536881596]],["^15",[458,"^F",459,536881674]],["^15",[458,"^X",274,536881596]],["^15",[458,"^V",274,536881596]],["^15",[458,"^U",274,536881597]],["^15",[458,"^?",["^ "],536881596]],["^15",[458,"^17",true,536881596]],["^15",[458,"^;","~u64ac91bb-0786-4431-b2b3-e9d24301df7b",536881596]],["^15",[459,"^Q","",536881674]],["^15",[459,"^O","^16",536881674]],["^15",[459,"^@",false,536881674]],["^15",[459,"^F",462,536881770]],["^15",[459,"^X",274,536881674]],["^15",[459,"^V",274,536881674]],["^15",[459,"^U",274,536881675]],["^15",[459,"^?",["^ "],536881770]],["^15",[459,"^17",true,536881674]],["^15",[459,"^;","~u64ac9299-ca80-4f75-8065-0bd46fd93bca",536881674]],["^15",[461,"^K",1689031486712,536881743]],["^15",[461,"^[",929,536909242]],["^15",[461,"^O","^16",536909186]],["^15",[461,"^@",false,536881743]],["^15",[461,"^Y","deref coercion",536881743]],["^15",[461,"^11","Deref Coercion",536881743]],["^15",[461,"^B",1690035741192,536909605]],["^15",[461,"^;","~u64c20233-cce8-4a0c-adfa-0ece235da863",536916346]],["^15",[462,"^Q","Slices on [[Array]]s \nFor ex.:\n```rust\nlet a = [1,2,3,4,5];\nlet b = &a[..]; //b has the type &[i32].\n```",536881782]],["^15",[462,"^O","^16",536881743]],["^15",[462,"^@",false,536881743]],["^15",[462,"^F",454,536881743]],["^15",[462,"^X",274,536881743]],["^15",[462,"^V",274,536881743]],["^15",[462,"^U",196,536881761]],["^15",[462,"^U",274,536881761]],["^15",[462,"^?",["^ "],536881782]],["^15",[462,"^H",196,536881782]],["^15",[462,"^17",true,536881743]],["^15",[462,"^;","~u64ac933e-c402-45db-8d33-cfb285e52964",536881743]],["^15",[465,"^U",253,536881873]],["^15",[466,"^Q","Rust has no concept of *Classes* from other languages. It only has *Struct*, which is a collection of types much like a [[Tuple]] but each type is assigned a name. Each Struct is a unique [[Data Type]].\n\nSyntax:\n``\nstruct <name>{\n\t<field_name>:<field_type>,\n\t<field_name>:<field_type>,\n}\n``\nEach name and [[Data Type]] pair in a struct definition is called a *field*.\n\nFor ex.:\n```rust\nstruct User{\n\tactive: bool,\n\tname: String,\n}\n\nlet user= User {\n  active: true,\n  name: String::from(\"yo\"),\n};\n\nlet pp= user.active; //to access any field's value.\n```\nAfter defining a struct, we can define values for its fields in an *instance*. We use the ``dot`` [[Operator]] to access each field's value.",536882637]],["^15",[466,"^O","^16",536881923]],["^15",[466,"^@",false,536881923]],["^15",[466,"^F",242,536881923]],["^15",[466,"^X",242,536881923]],["^15",[466,"^V",242,536881923]],["^15",[466,"^U",148,536882626]],["^15",[466,"^U",194,536882626]],["^15",[466,"^U",206,536882631]],["^15",[466,"^U",242,536882626]],["^15",[466,"^H",148,536908135]],["^15",[466,"^H",194,536908135]],["^15",[466,"^H",206,536908135]],["^15",[466,"^17",true,536881923]],["^15",[466,"^;","~u64ac94c5-073f-49a4-9552-7574529ec8c2",536881923]],["^15",[467,"^3","- Rust has no concept of *Classes* from other languages. It only has *Struct*, which is a collection of types much like a [[Tuple]] but each type is assigned a name. Each Struct is a unique [[Data Type]].\n  \n  Syntax:\n  ``\n  struct <name>{\n  \t<field_name>:<field_type>,\n  \t<field_name>:<field_type>,\n  }\n  ``\n  Each name and [[Data Type]] pair in a struct definition is called a *field*.\n  \n  For ex.:\n  ```rust\n  struct User{\n  \tactive: bool,\n  \tname: String,\n  }\n  \n  let user= User {\n    active: true,\n    name: String::from(\"yo\"),\n  };\n  \n  let pp= user.active; //to access any field's value.\n  ```\n  After defining a struct, we can define values for its fields in an *instance*. We use the ``dot`` [[Operator]] to access each field's value.\n- Just like [[Variable]]s, instances have ``mutability``.\n  \n  Every instance is an immutable instance by default, and we cannot modify any field’s value or the variable itself after initialization.\n  \n  To create a mutable instance we use ``let mut user = User{};``\n  This is also to say, Rust doesn’t have mutable fields, the entire instance should either be mutable or immutable.\n- Field init Shorthand\n  Rust allows creating a struct without specifying field names if the [[Variable]] name is the same as the field it is being assigned to.\n  \n  For ex.:\n  ```rust\n  struct User {\n  active: bool\n  }\n  \n  let active=true;\n  let user= User{\n  \tactive\n  }; //ok\n  ```\n- Struct update syntax\n  \n  A struct can be created from another struct without manually specifying each field,\n  For ex.:\n  ```rust\n  struct User {\n  active: bool,\n  name: String,\n  }\n  \n  let active= true;\n  let user= User{\n  \tactive,\n      name:String::from(\"yo\")\n  };\n  let user2= User{\n      ..user\n  };\n  println!(\"{}\",user.active);\n  //If we also do println(\"{}\", user.name); then it will be an error as user.name has lost ownership\n  ```\n  We can specify some *fields* if we want but we must specify them before defining the base struct. \n  Now it [[Copy or Move]]s the values from base struct into the new instance. The copy/move rules are followed the same. This makes the *field* of the base struct which lost [[Ownership]] in the move operation as invalid, however all the other fields can still be accessed.\n- [[Tuple]] Struct\n  We can create a struct which is exactly like a [[Tuple]] but just with a custom name and is a custom [[Data Type]] itself. \n  \n  For ex.:\n  ```rust\n  struct Color(i32, i32, i32);\n  struct AnotherColor(i32, i32, i32);\n  \n  //And to create an instance\n  let color= Color(0,1,2);\n  //and access \n  color.1; //like normal tuples.\n  \n  let another_color=AnotherColor(0,1,2);\n  ```\n  Here, ``color`` and ``another_color`` are not equal, even if they had the same values and fields, they are different types.\n- Unit-Like struct\n  Just like [[Unit Type]] which is just an empty [[Tuple]] , we have unit structs too.\n  For ex.:\n  ```rust\n  struct Abc;\n  let abc= Abc;\n  ```\n  and that’s it. It doesn't have much use.\n- [[Reference Type]]fields\n  We can have reference field types, like ``&str`` [[String]] , if we define [[Lifetime]]s . This is to ensure the struct owns the data until the instance exists to avoid bugs.\n- [[Method]]\n- [[Fully Qualified Syntax for Disambiguation]]\n-",536917345]],["^15",[467,"^18","~m1690438073419",536917344]],["^15",[467,"^Z","pages/Struct.md",536881929]],["^15",[472,"^Q","",536899369]],["^15",[472,"^O","^16",536882188]],["^15",[472,"^@",false,536882188]],["^15",[472,"^F",924,536908135]],["^15",[472,"^X",242,536882188]],["^15",[472,"^V",242,536882188]],["^15",[472,"^U",242,536899370]],["^15",[472,"^17",true,536882188]],["^15",[472,"^;","~u64ac95d3-f3a6-4541-a021-19c49f5fce78",536882188]],["^15",[473,"^Q","Field init Shorthand\nRust allows creating a struct without specifying field names if the [[Variable]] name is the same as the field it is being assigned to.\n\nFor ex.:\n```rust\nstruct User {\nactive: bool\n}\n\nlet active=true;\nlet user= User{\n\tactive\n}; //ok\n```",536882641]],["^15",[473,"^O","^16",536882193]],["^15",[473,"^@",false,536882193]],["^15",[473,"^F",474,536882219]],["^15",[473,"^X",242,536882193]],["^15",[473,"^V",242,536882193]],["^15",[473,"^U",99,536882379]],["^15",[473,"^U",242,536882379]],["^15",[473,"^H",99,536908135]],["^15",[473,"^17",true,536882193]],["^15",[473,"^;","~u64ac95d7-5845-48f9-9163-cb815c3523d7",536882193]],["^15",[474,"^Q","Just like [[Variable]]s, instances have ``mutability``.\n\nEvery instance is an immutable instance by default, and we cannot modify any field’s value or the variable itself after initialization.\n\nTo create a mutable instance we use ``let mut user = User{};``\nThis is also to say, Rust doesn’t have mutable fields, the entire instance should either be mutable or immutable.",536882347]],["^15",[474,"^O","^16",536882215]],["^15",[474,"^@",false,536882215]],["^15",[474,"^F",466,536882631]],["^15",[474,"^X",242,536882215]],["^15",[474,"^V",242,536882215]],["^15",[474,"^U",99,536882236]],["^15",[474,"^U",242,536882236]],["^15",[474,"^H",99,536908135]],["^15",[474,"^17",true,536882215]],["^15",[474,"^;","~u64ac960f-385a-4964-aa75-d2b449673d22",536882215]],["^15",[475,"^U",242,536882220]],["^15",[476,"^U",242,536882220]],["^15",[477,"^U",242,536882351]],["^15",[478,"^U",242,536882351]],["^15",[479,"^U",242,536882351]],["^15",[480,"^U",242,536882351]],["^15",[481,"^U",242,536882351]],["^15",[483,"^Q","Struct update syntax\n\nA struct can be created from another struct without manually specifying each field,\nFor ex.:\n```rust\nstruct User {\nactive: bool,\nname: String,\n}\n\nlet active= true;\nlet user= User{\n\tactive,\n    name:String::from(\"yo\")\n};\nlet user2= User{\n    ..user\n};\nprintln!(\"{}\",user.active);\n//If we also do println(\"{}\", user.name); then it will be an error as user.name has lost ownership\n```\nWe can specify some *fields* if we want but we must specify them before defining the base struct. \nNow it [[Copy or Move]]s the values from base struct into the new instance. The copy/move rules are followed the same. This makes the *field* of the base struct which lost [[Ownership]] in the move operation as invalid, however all the other fields can still be accessed.",536882573]],["^15",[483,"^O","^16",536882433]],["^15",[483,"^@",false,536882433]],["^15",[483,"^F",473,536882433]],["^15",[483,"^X",242,536882433]],["^15",[483,"^V",242,536882433]],["^15",[483,"^U",242,536882570]],["^15",[483,"^U",255,536882570]],["^15",[483,"^U",256,536882570]],["^15",[483,"^H",255,536908135]],["^15",[483,"^H",256,536908135]],["^15",[483,"^17",true,536882433]],["^15",[483,"^;","~u64ac9748-0be6-49ff-9ed1-e9d63af68b06",536882433]],["^15",[484,"^Q","[[Tuple]] Struct\nWe can create a struct which is exactly like a [[Tuple]] but just with a custom name and is a custom [[Data Type]] itself. \n\nFor ex.:\n```rust\nstruct Color(i32, i32, i32);\nstruct AnotherColor(i32, i32, i32);\n\n//And to create an instance\nlet color= Color(0,1,2);\n//and access \ncolor.1; //like normal tuples.\n\nlet another_color=AnotherColor(0,1,2);\n```\nHere, ``color`` and ``another_color`` are not equal, even if they had the same values and fields, they are different types.",536882730]],["^15",[484,"^O","^16",536882576]],["^15",[484,"^@",false,536882576]],["^15",[484,"^F",483,536882576]],["^15",[484,"^X",242,536882576]],["^15",[484,"^V",242,536882576]],["^15",[484,"^U",148,536882609]],["^15",[484,"^U",194,536882609]],["^15",[484,"^U",242,536882609]],["^15",[484,"^H",148,536908135]],["^15",[484,"^H",194,536908135]],["^15",[484,"^17",true,536882576]],["^15",[484,"^;","~u64ac97dc-de2b-4668-bdf4-ec770c9a8217",536882576]],["^15",[486,"^Q","Unit-Like struct\nJust like [[Unit Type]] which is just an empty [[Tuple]] , we have unit structs too.\nFor ex.:\n```rust\nstruct Abc;\nlet abc= Abc;\n```\nand that’s it. It doesn't have much use.",536882810]],["^15",[486,"^O","^16",536882733]],["^15",[486,"^@",false,536882733]],["^15",[486,"^F",484,536882733]],["^15",[486,"^X",242,536882733]],["^15",[486,"^V",242,536882733]],["^15",[486,"^U",194,536882752]],["^15",[486,"^U",211,536882752]],["^15",[486,"^U",242,536882752]],["^15",[486,"^H",194,536908135]],["^15",[486,"^H",211,536908135]],["^15",[486,"^17",true,536882733]],["^15",[486,"^;","~u64ac98d1-91ca-4244-b09c-12757b71fc4b",536882733]],["^15",[493,"^Q","[[Reference Type]]fields\nWe can have reference field types, like ``&str`` [[String]] , if we define [[Lifetime]]s . This is to ensure the struct owns the data until the instance exists to avoid bugs.",536882873]],["^15",[493,"^O","^16",536882810]],["^15",[493,"^@",false,536882810]],["^15",[493,"^F",486,536882810]],["^15",[493,"^X",242,536882810]],["^15",[493,"^V",242,536882810]],["^15",[493,"^U",118,536882858]],["^15",[493,"^U",242,536882858]],["^15",[493,"^U",253,536882858]],["^15",[493,"^U",280,536882858]],["^15",[493,"^H",118,536908135]],["^15",[493,"^H",253,536908135]],["^15",[493,"^H",280,536908135]],["^15",[493,"^17",true,536882810]],["^15",[493,"^;","~u64ac991e-9463-4010-9dbc-855e4e60e742",536882810]],["^15",[494,"^Q","[[Method]]",536882906]],["^15",[494,"^O","^16",536882876]],["^15",[494,"^@",false,536882876]],["^15",[494,"^F",493,536882876]],["^15",[494,"^X",242,536882876]],["^15",[494,"^V",242,536882876]],["^15",[494,"^U",242,536882907]],["^15",[494,"^U",497,536882907]],["^15",[494,"^H",497,536908135]],["^15",[494,"^17",true,536882876]],["^15",[494,"^;","~u64ac9981-73dd-462f-8b81-108db96e1e1a",536882876]],["^15",[497,"^5",506,536884057]],["^15",[497,"^K",1689134143041,536882906]],["^15",[497,"^[",499,536882916]],["^15",[497,"^O","^16",536882910]],["^15",[497,"^@",false,536882906]],["^15",[497,"^Y","method",536882906]],["^15",[497,"^11","Method",536882906]],["^15",[497,"^?",["^ ","^19",["^1:",["Associated Function"]]],536884057]],["^15",[497,"^4",["^ ","^19","Associated Function"],536884057]],["^15",[497,"^B",1689661925521,536901619]],["^15",[497,"^;","~u64c20233-2695-4d63-a3b0-43d5cf41e467",536916349]],["^15",[498,"^Q","Method\nMethods are [[Function]]s defined for the [[Struct]]s/ [[Enumerated Type]]s/ [[Trait Object]]s. They are defined inside a special block with a keyword ``impl``, this is for organization, and makes it easier to find out where a custom [[Data Type]] has been defined implementations/behaviors for it, kind of like C++ where we have separate header and source files and unlike C++ there's no need for definition in the [[Data Type]] itself. Since all methods are associated with a [[Data Type]], they are also called *Associated Function*s.\n\nSyntax: \n``\nimpl <T> {\n fn someMethod(<self/&self>,<some Params>) -> <some return type> {}\n}\n``\n\n\nFor ex.:\n```rust\nstruct Rect{\n\tlength: i32,\n\tbreadth: i32\n}\n\nimpl Rect {\n\tfn area(&self) -> i32 {\n\tself.length * self.breadth\n } \n}\nfn main() {\n let rect= Rect(2,4);\n let area=rect.area(); //works\n}\n```\n\nA single custom [[Data Type]], can have multiple ``impl`` blocks for it.",536884107]],["^15",[498,"^O","^16",536882911]],["^15",[498,"^@",false,536882911]],["^15",[498,"^F",505,536884050]],["^15",[498,"^X",497,536882911]],["^15",[498,"^V",497,536882911]],["^15",[498,"^U",130,536882993]],["^15",[498,"^U",148,536882993]],["^15",[498,"^U",242,536882993]],["^15",[498,"^U",261,536882993]],["^15",[498,"^U",262,536882993]],["^15",[498,"^U",497,536882993]],["^15",[498,"^?",["^ "],536884107]],["^15",[498,"^H",130,536884107]],["^15",[498,"^H",148,536884107]],["^15",[498,"^H",242,536884107]],["^15",[498,"^H",261,536884107]],["^15",[498,"^H",262,536884107]],["^15",[498,"^17",true,536882911]],["^15",[498,"^;","~u64ae2440-1ec0-411f-bd23-2f8acd641103",536882911]],["^15",[499,"^3","alias:: Associated Function\n\n- Method\n  Methods are [[Function]]s defined for the [[Struct]]s/ [[Enumerated Type]]s/ [[Trait Object]]s. They are defined inside a special block with a keyword ``impl``, this is for organization, and makes it easier to find out where a custom [[Data Type]] has been defined implementations/behaviors for it, kind of like C++ where we have separate header and source files and unlike C++ there's no need for definition in the [[Data Type]] itself. Since all methods are associated with a [[Data Type]], they are also called *Associated Function*s.\n  \n  Syntax: \n  ``\n  impl <T> {\n   fn someMethod(<self/&self>,<some Params>) -> <some return type> {}\n  }\n  ``\n  \n  \n  For ex.:\n  ```rust\n  struct Rect{\n  \tlength: i32,\n  \tbreadth: i32\n  }\n  \n  impl Rect {\n  \tfn area(&self) -> i32 {\n  \tself.length * self.breadth\n   } \n  }\n  fn main() {\n   let rect= Rect(2,4);\n   let area=rect.area(); //works\n  }\n  ```\n  \n  A single custom [[Data Type]], can have multiple ``impl`` blocks for it.\n- ``self``\n  Every method of a [[Struct]]/ [[Enumerated Type]]/ [[Trait Object]] can define ``self`` as the first parameter in order to access the instance values, it can choose to not have the parameter if it doesn’t need access to field instances. ``self`` is of type ``Self`` and copies the instance field values into itself, it also takes the [[Ownership]] so it is rarely used.\n  ``&self`` is the immutable [[Reference Type]] variant and ``&mut self`` is the mutable reference variant. Rust allows us to use the shorthand ``self``/``&self``/``&mut self`` without specifying the ``Self`` type.\n  \n  For ex.:\n  ```rust\n  struct ABC {}\n  \n  impl ABC {\n  \tfn yo() {}\n      fn ctor() -> Self {\n      ABC{}\n    }\n  }\n  \n  fn main(){\n   ABC::someFunc();  //to call a self-less method\n  }\n  ```\n  ``Self`` is a type that can be assigned to the impl's type, so it can be used for *Constructor*s/*Factory* Methods.\n- Methods in rust can have the same name as *fields* of the custom [[Data Type]]. \n  Rust know what we are calling by assessing if we specify the () or not.\n  \n  For ex.:\n  ```rust\n  struct X {\n  length: i32,\n  }\n  \n  impl X {\n   fn length(&self)->i32 { \n    2\n  }\n  }\n  \n  fn main() {\n   let x= X{length: 5};\n   let y= x.length(); //gets 2\n   let z = x.length; //gets 5\n  }\n  ```\n- Automatic *Referencing* and *Dereferencing*\n  For ex.:\n  ```rust\n  Struct X {\n  length: i32,\n  }\n  \n  impl X {\n   fn yo(&self) {\n   //yee\n   }\n  }\n  fn main() {\n   let x = X{ length: 5};\n   x.yo(); \n   //is the same as\n   (&x).yo();\n  }\n  ```\n  In Rust, ``x`` is an *object pointer*, and we know in langs like C++, we access methods inside them with the ``->`` [[Operator]] so like ``(*x).yo()`` or ``x->yo()``,  but rust doesn’t have the ``->`` [[Operator]], and nor does it need to be explicit specified if we want to use the immutable [[Reference Type]] (with ``&(x).yo()``), mutable ref (with ``(&mut x).yo()``), or [[Copy or Move]] of the instance (with ``(x).yo()``) as it automatically determines the right type from the parameter of the methods, like ``yo`` above takes an immutable reference, so rust knows ``x.yo()`` is equivalent to ``(&x).yo()``.\n- Calling other methods\n  \n  For ex.:\n  ```rust\n  struct A {\n      x: i32,\n  }\n  \n  impl A {\n      fn ya() {}\n  \n      fn na(&self) {}\n  \n      fn callSelf(&self) {\n          Self::ya();\n          self.na();\n      }\n  \n      fn callNoSelf() {\n          A::ya();\n          //can't call na as there's no known instance here\n      }\n  }\n  \n  fn main() {\n      let a = A { x: 2 };\n      a.callSelf();\n      A::callNoSelf();\n  }\n  ```\n-",536901625]],["^15",[499,"^18","~m1689661927311",536901624]],["^15",[499,"^Z","pages/Method.md",536882916]],["^15",[500,"^Q","Trait Objects are much like [[Generic Type]]s where we define a [[Trait]] and instead of providing a concrete type at compile-time we provide it at runtime. So rust knows at compile-time only 2 things, that it should wait for the types till runtime and at compile time just ensure that any provided types do implement the given trait. \nHowever, as we know, Rust requires a fixed size at compile time for every definition, this is why we have to make use of [[Pointer]]s. And the pointers theirselves need to know the size of the type, they can use ``dyn`` keyword which allows [[Dynamically Sized Type]]s. \nFinally we get a [[Data Type]] definition that looks like ``Box<dyn someTrait>``.\n\nFor ex.:\n```rust\nfn main() {\n /*\nlet bag = Bag {\n        stuff: vec![Box::new(1i32), Box::new(2u32)], \n    }; // //would be an error, because Box<T> for Bag resolves to i32, but we provide a u32 for the next element. \n*/\n    let bigger_bag = BigBag {\n        stuff: vec![Box::new(1i32), Box::new(2u32)],\n    }; //works\n}\n \nstruct Bag<T: Tiffin> {\n    stuff: Vec<Box<T>>,\n}\n \nstruct BigBag {\n    stuff: Vec<Box<dyn Tiffin>>,\n}\n \ntrait Tiffin {}\n \nimpl Tiffin for i32 {}\nimpl Tiffin for u32 {}\n\n```",536915417]],["^15",[500,"^O","^16",536882938]],["^15",[500,"^@",false,536882938]],["^15",[500,"^F",262,536882938]],["^15",[500,"^X",262,536882938]],["^15",[500,"^V",262,536882938]],["^15",[500,"^U",131,536915303]],["^15",[500,"^U",148,536915303]],["^15",[500,"^U",262,536915303]],["^15",[500,"^U",414,536915303]],["^15",[500,"^U",777,536915303]],["^15",[500,"^U",878,536915303]],["^15",[500,"^?",["^ "],536915417]],["^15",[500,"^H",131,536915417]],["^15",[500,"^H",148,536915417]],["^15",[500,"^H",414,536915417]],["^15",[500,"^H",777,536915417]],["^15",[500,"^H",878,536915417]],["^15",[500,"^17",true,536882938]],["^15",[500,"^;","~u64ae245c-bb96-49cb-af0e-4ab54c2f264a",536882938]],["^15",[501,"^Q","~``self``\nEvery method of a [[Struct]]/ [[Enumerated Type]]/ [[Trait Object]] can define ``self`` as the first parameter in order to access the instance values, it can choose to not have the parameter if it doesn’t need access to field instances. ``self`` is of type ``Self`` and copies the instance field values into itself, it also takes the [[Ownership]] so it is rarely used.\n``&self`` is the immutable [[Reference Type]] variant and ``&mut self`` is the mutable reference variant. Rust allows us to use the shorthand ``self``/``&self``/``&mut self`` without specifying the ``Self`` type.\n\nFor ex.:\n```rust\nstruct ABC {}\n\nimpl ABC {\n\tfn yo() {}\n    fn ctor() -> Self {\n    ABC{}\n  }\n}\n\nfn main(){\n ABC::someFunc();  //to call a self-less method\n}\n```\n``Self`` is a type that can be assigned to the impl's type, so it can be used for *Constructor*s/*Factory* Methods.",536884359]],["^15",[501,"^O","^16",536883098]],["^15",[501,"^@",false,536883098]],["^15",[501,"^F",498,536884101]],["^15",[501,"^X",497,536883098]],["^15",[501,"^V",497,536883098]],["^15",[501,"^U",242,536884203]],["^15",[501,"^U",253,536884203]],["^15",[501,"^U",255,536884203]],["^15",[501,"^U",261,536884203]],["^15",[501,"^U",262,536884203]],["^15",[501,"^U",497,536884203]],["^15",[501,"^?",["^ "],536884359]],["^15",[501,"^H",242,536884359]],["^15",[501,"^H",253,536884359]],["^15",[501,"^H",255,536884359]],["^15",[501,"^H",261,536884359]],["^15",[501,"^H",262,536884359]],["^15",[501,"^17",true,536883098]],["^15",[501,"^;","~u64ae252a-232a-43c4-8f76-6d54e695783d",536883098]],["^15",[502,"^Q","Methods in rust can have the same name as *fields* of the custom [[Data Type]]. \nRust know what we are calling by assessing if we specify the () or not.\n\nFor ex.:\n```rust\nstruct X {\nlength: i32,\n}\n\nimpl X {\n fn length(&self)->i32 { \n  2\n}\n}\n\nfn main() {\n let x= X{length: 5};\n let y= x.length(); //gets 2\n let z = x.length; //gets 5\n}\n```",536883614]],["^15",[502,"^O","^16",536883366]],["^15",[502,"^@",false,536883366]],["^15",[502,"^F",501,536884366]],["^15",[502,"^X",497,536883366]],["^15",[502,"^V",497,536883366]],["^15",[502,"^U",148,536883392]],["^15",[502,"^U",497,536883392]],["^15",[502,"^?",["^ "],536884366]],["^15",[502,"^H",148,536884366]],["^15",[502,"^17",true,536883366]],["^15",[502,"^;","~u64ae274f-c837-4e02-943e-d18f737020f4",536883366]],["^15",[503,"^Q","Automatic *Referencing* and *Dereferencing*\nFor ex.:\n```rust\nStruct X {\nlength: i32,\n}\n\nimpl X {\n fn yo(&self) {\n //yee\n }\n}\nfn main() {\n let x = X{ length: 5};\n x.yo(); \n //is the same as\n (&x).yo();\n}\n```\nIn Rust, ``x`` is an *object pointer*, and we know in langs like C++, we access methods inside them with the ``->`` [[Operator]] so like ``(*x).yo()`` or ``x->yo()``,  but rust doesn’t have the ``->`` [[Operator]], and nor does it need to be explicit specified if we want to use the immutable [[Reference Type]] (with ``&(x).yo()``), mutable ref (with ``(&mut x).yo()``), or [[Copy or Move]] of the instance (with ``(x).yo()``) as it automatically determines the right type from the parameter of the methods, like ``yo`` above takes an immutable reference, so rust knows ``x.yo()`` is equivalent to ``(&x).yo()``.",536884043]],["^15",[503,"^O","^16",536883534]],["^15",[503,"^@",false,536883534]],["^15",[503,"^F",502,536883534]],["^15",[503,"^X",497,536883534]],["^15",[503,"^V",497,536883534]],["^15",[503,"^U",206,536883905]],["^15",[503,"^U",253,536883905]],["^15",[503,"^U",256,536883905]],["^15",[503,"^U",497,536883905]],["^15",[503,"^?",["^ "],536884043]],["^15",[503,"^H",206,536884043]],["^15",[503,"^H",253,536884043]],["^15",[503,"^H",256,536884043]],["^15",[503,"^17",true,536883534]],["^15",[503,"^;","~u64ae27da-af56-41e7-bd5c-4133036ebf15",536883534]],["^15",[504,"^Q","Calling other methods\n\nFor ex.:\n```rust\nstruct A {\n    x: i32,\n}\n\nimpl A {\n    fn ya() {}\n\n    fn na(&self) {}\n\n    fn callSelf(&self) {\n        Self::ya();\n        self.na();\n    }\n\n    fn callNoSelf() {\n        A::ya();\n        //can't call na as there's no known instance here\n    }\n}\n\nfn main() {\n    let a = A { x: 2 };\n    a.callSelf();\n    A::callNoSelf();\n}\n```",536901619]],["^15",[504,"^O","^16",536884044]],["^15",[504,"^@",false,536884044]],["^15",[504,"^F",503,536884044]],["^15",[504,"^X",497,536884044]],["^15",[504,"^V",497,536884044]],["^15",[504,"^U",497,536884045]],["^15",[504,"^?",["^ "],536901619]],["^15",[504,"^17",true,536884044]],["^15",[504,"^;","~u64ae29fb-f222-44ad-b584-5a8ea255e4cb",536884044]],["^15",[505,"^Q","alias:: Associated Function",536884057]],["^15",[505,"^O","^16",536884050]],["^15",[505,"^1;",["^1:",[]],536884057]],["^15",[505,"^@",false,536884050]],["^15",[505,"^F",497,536884050]],["^15",[505,"^X",497,536884050]],["^15",[505,"^V",497,536884050]],["^15",[505,"^U",497,536884058]],["^15",[505,"^U",506,536884058]],["^15",[505,"^:",true,536884057]],["^15",[505,"^?",["^ ","^19",["^1:",["Associated Function"]]],536884057]],["^15",[505,"^J",["^14",["^19"]],536884057]],["^15",[505,"^4",["^ ","^19","Associated Function"],536884057]],["^15",[505,"^H",506,536884057]],["^15",[505,"^17",true,536884050]],["^15",[505,"^;","~u64ae2a26-d66e-4a9f-a07c-efda162a44bc",536884050]],["^15",[506,"^K",1689135662432,536884057]],["^15",[506,"^@",false,536884057]],["^15",[506,"^Y","associated function",536884057]],["^15",[506,"^11","Associated Function",536884057]],["^15",[506,"^B",1689135662432,536884057]],["^15",[509,"^Q","alias:: Enum\n\n",536908120]],["^15",[509,"^O","^16",536884370]],["^15",[509,"^1;",["^1:",[]],536908120]],["^15",[509,"^@",false,536884370]],["^15",[509,"^F",261,536884370]],["^15",[509,"^X",261,536884370]],["^15",[509,"^V",261,536884370]],["^15",[509,"^U",261,536884381]],["^15",[509,"^U",511,536884381]],["^15",[509,"^:",true,536908120]],["^15",[509,"^?",["^ ","^19",["^1:",["Enum"]]],536908120]],["^15",[509,"^J",["^19"],536908120]],["^15",[509,"^4",["^ ","^19","Enum"],536908120]],["^15",[509,"^H",511,536908120]],["^15",[509,"^17",true,536884370]],["^15",[509,"^;","~u64ae80c0-b257-4839-9c43-17c6d1cb3d98",536884370]],["^15",[510,"^3","alias:: Enum\n\n- ``enum``\n  Short for enumerations, as they allow us to enumerate the possible variants of a defined [[Data Type]]. \n  \n  Syntax:\n  ``\n  enum <name>{ \n   <type names>\n  }\n  ``\n  For ex.:\n  ```rust\n  enum Size {\n   SMALL,\n   LARGE\n  }\n  fn main() {\n   let carSize: Size= Size::LARGE;\n  }\n  ```\n  Variants of an ``enum`` are namespaced under its identifier.\n- Variant of an ``enum`` can optionally also take a [[Function]] with some parameters.\n  This makes the function create an instance of an ``enum`` with the given variant and values provided to it.\n  \n  For ex.:\n  ```rust\n  enum X {\n      Y(i32, String, i32),\n      Z,\n  }\n  \n  fn main() {\n      let x = X::Y(2, String::from(\"yo\"), 5);\n      match x {\n          X::Y(value1, string, value2) => { \n              println!(\"{}\", value1); //to access\n          }\n          _ => {\n              println!(\"Invalid variant\");\n          }\n      } \n  }\n  ```\n  We use [[Pattern Matching]] to access an ``enum``s value, because it is not guaranteed what variant of an enum is stored in a variable.\n  \n  * This function can then also have named fields as parameters.\n  For ex.:\n  ```rust\n  enum X {\n      Y(i32, String, i32),\n      Z(x: i32),\n  }\n  \n  fn main() {\n      let x = X::Z(x: 2); //to instantiate\n      match x {\n          X::Y(value1, string, value2) => {\n              println!(\"{}\", value1);\n          }\n          X::Z {x} => { //to access\n              println!(\"{}\", x);\n          }\n      } \n  }\n  ```\n  Just usual [[Pattern Matching]].\n- [[Method]]\n  Enums can have methods too. \n  Methods of an ``enum`` apply to all its variants if they use ``self``.\n  \n  For ex.:\n  ```rust\n  enum X{\n   Y\n  }\n  \n  impl X {\n   fn yo() {}\n   fn yas(&self) {}\n  }\n  \n  fn main() {\n   let z= X::Y;\n   X::yo(); //for non-instance methods\n   z.yas(); //for instance methods\n  }\n  ```\n- [[Option Type]]\n- [[Result Type]]\n- Size of an Enum\n  The size of an enum is the same as the biggest variant of it, so if an enum had a variant ``X`` and then a variant ``Y(i32)`` then the size of the enum would be the same as an ``i32``. \n  The reason is pretty simple, an enum's value can only be any 1 of its variants, so the largest variant's size is the size of the enum itself.",536908120]],["^15",[510,"^18","~m1689962492909",536908121]],["^15",[510,"^Z","pages/Enumerated Type.md",536884374]],["^15",[511,"^5",261,536908120]],["^15",[511,"^K",1689157835463,536884380]],["^15",[511,"^@",false,536884380]],["^15",[511,"^Y","enum",536884380]],["^15",[511,"^11","Enum",536884380]],["^15",[511,"^B",1689157835463,536884380]],["^15",[511,"^;","~u64c20233-adcb-481c-a4a0-1e9a85fc1773",536916346]],["^15",[512,"^Q","~``enum``\nShort for enumerations, as they allow us to enumerate the possible variants of a defined [[Data Type]]. \n\nSyntax:\n``\nenum <name>{ \n <type names>\n}\n``\nFor ex.:\n```rust\nenum Size {\n SMALL,\n LARGE\n}\nfn main() {\n let carSize: Size= Size::LARGE;\n}\n```\nVariants of an ``enum`` are namespaced under its identifier.",536884583]],["^15",[512,"^O","^16",536884382]],["^15",[512,"^@",false,536884382]],["^15",[512,"^F",509,536884382]],["^15",[512,"^X",261,536884382]],["^15",[512,"^V",261,536884382]],["^15",[512,"^U",148,536884423]],["^15",[512,"^U",261,536884423]],["^15",[512,"^H",148,536908120]],["^15",[512,"^17",true,536884382]],["^15",[512,"^;","~u64ae80cb-a8ac-4f2d-8a9a-d271b397ca9c",536884382]],["^15",[513,"^U",261,536884389]],["^15",[514,"^U",261,536884389]],["^15",[515,"^U",261,536884389]],["^15",[516,"^U",261,536884389]],["^15",[517,"^U",261,536884389]],["^15",[518,"^U",261,536884389]],["^15",[519,"^U",261,536884389]],["^15",[520,"^U",261,536884389]],["^15",[521,"^Q","Variant of an ``enum`` can optionally also take a [[Function]] with some parameters.\nThis makes the function create an instance of an ``enum`` with the given variant and values provided to it.\n\nFor ex.:\n```rust\nenum X {\n    Y(i32, String, i32),\n    Z,\n}\n\nfn main() {\n    let x = X::Y(2, String::from(\"yo\"), 5);\n    match x {\n        X::Y(value1, string, value2) => { \n            println!(\"{}\", value1); //to access\n        }\n        _ => {\n            println!(\"Invalid variant\");\n        }\n    } \n}\n```\nWe use [[Pattern Matching]] to access an ``enum``s value, because it is not guaranteed what variant of an enum is stored in a variable.\n\n* This function can then also have named fields as parameters.\nFor ex.:\n```rust\nenum X {\n    Y(i32, String, i32),\n    Z(x: i32),\n}\n\nfn main() {\n    let x = X::Z(x: 2); //to instantiate\n    match x {\n        X::Y(value1, string, value2) => {\n            println!(\"{}\", value1);\n        }\n        X::Z {x} => { //to access\n            println!(\"{}\", x);\n        }\n    } \n}\n```\nJust usual [[Pattern Matching]].",536884961]],["^15",[521,"^O","^16",536884558]],["^15",[521,"^@",false,536884558]],["^15",[521,"^F",512,536884558]],["^15",[521,"^X",261,536884558]],["^15",[521,"^V",261,536884558]],["^15",[521,"^U",130,536884789]],["^15",[521,"^U",202,536884789]],["^15",[521,"^U",261,536884789]],["^15",[521,"^H",130,536908120]],["^15",[521,"^H",202,536908120]],["^15",[521,"^17",true,536884558]],["^15",[521,"^;","~u64ae818e-5b1c-4c94-9a9e-be3265ef8f7c",536884558]],["^15",[522,"^Q","[[Option Type]]",536885447]],["^15",[522,"^O","^16",536884828]],["^15",[522,"^@",false,536884828]],["^15",[522,"^F",523,536884977]],["^15",[522,"^X",261,536884828]],["^15",[522,"^V",261,536884828]],["^15",[522,"^U",228,536885448]],["^15",[522,"^U",261,536885448]],["^15",[522,"^H",228,536908120]],["^15",[522,"^17",true,536884828]],["^15",[522,"^;","~u64aea172-25ea-46d6-a07b-f04ea610334e",536884828]],["^15",[523,"^Q","[[Method]]\nEnums can have methods too. \nMethods of an ``enum`` apply to all its variants if they use ``self``.\n\nFor ex.:\n```rust\nenum X{\n Y\n}\n\nimpl X {\n fn yo() {}\n fn yas(&self) {}\n}\n\nfn main() {\n let z= X::Y;\n X::yo(); //for non-instance methods\n z.yas(); //for instance methods\n}\n```",536885160]],["^15",[523,"^O","^16",536884962]],["^15",[523,"^@",false,536884962]],["^15",[523,"^F",521,536884962]],["^15",[523,"^X",261,536884962]],["^15",[523,"^V",261,536884962]],["^15",[523,"^U",261,536884969]],["^15",[523,"^U",497,536884969]],["^15",[523,"^H",497,536908120]],["^15",[523,"^17",true,536884962]],["^15",[523,"^;","~u64aea2a1-a75f-4c4b-860f-3ff4aa5cc15a",536884962]],["^15",[525,"^K",1689167096854,536885262]],["^15",[525,"^[",527,536885271]],["^15",[525,"^O","^16",536885266]],["^15",[525,"^@",false,536885262]],["^15",[525,"^Y","prelude",536885262]],["^15",[525,"^11","Prelude",536885262]],["^15",[525,"^B",1689234257048,536888116]],["^15",[525,"^;","~u64c20233-3387-4fc9-b993-100805016ac9",536916346]],["^15",[526,"^Q","*prelude*\nThis is a [[Crate]] (``std::prelude``) that Rust automatically automatically imports into every Rust program. It defines a lot of core [[Data Type]]s, [[Function]]s etc..",536888116]],["^15",[526,"^O","^16",536885267]],["^15",[526,"^@",false,536885267]],["^15",[526,"^F",525,536885267]],["^15",[526,"^X",525,536885267]],["^15",[526,"^V",525,536885267]],["^15",[526,"^U",130,536888117]],["^15",[526,"^U",148,536888117]],["^15",[526,"^U",525,536888117]],["^15",[526,"^U",577,536888117]],["^15",[526,"^?",["^ "],536888116]],["^15",[526,"^H",130,536888116]],["^15",[526,"^H",148,536888116]],["^15",[526,"^H",577,536888116]],["^15",[526,"^17",true,536885267]],["^15",[526,"^;","~u64aea4fb-53cb-4e45-87cd-8d58012a6638",536885267]],["^15",[527,"^3","- *prelude*\n  This is a [[Crate]] (``std::prelude``) that Rust automatically automatically imports into every Rust program. It defines a lot of core [[Data Type]]s, [[Function]]s etc..\n-\n-",536888119]],["^15",[527,"^18","~m1689234257855",536888118]],["^15",[527,"^Z","pages/Prelude.md",536885271]],["^15",[529,"^Q","",536885323]],["^15",[529,"^O","^16",536885323]],["^15",[529,"^@",false,536885323]],["^15",[529,"^F",531,536885418]],["^15",[529,"^X",525,536885323]],["^15",[529,"^V",525,536885323]],["^15",[529,"^U",525,536885324]],["^15",[529,"^?",["^ "],536885323]],["^15",[529,"^17",true,536885323]],["^15",[529,"^;","~u64aea53e-01bb-4450-a88b-32d6734a8fc6",536885323]],["^15",[530,"^K",1689167188815,536885343]],["^15",[530,"^[",591,536889187]],["^15",[530,"^O","^16",536888101]],["^15",[530,"^@",false,536885343]],["^15",[530,"^Y","module",536885343]],["^15",[530,"^11","Module",536885343]],["^15",[530,"^B",1689875758265,536905963]],["^15",[530,"^;","~u64c20233-1500-4754-b583-508694b2d4ed",536916346]],["^15",[531,"^Q","",536885418]],["^15",[531,"^O","^16",536885418]],["^15",[531,"^@",false,536885418]],["^15",[531,"^F",526,536885418]],["^15",[531,"^X",525,536885418]],["^15",[531,"^V",525,536885418]],["^15",[531,"^U",525,536885419]],["^15",[531,"^?",["^ "],536885418]],["^15",[531,"^17",true,536885418]],["^15",[531,"^;","~u64aea59d-18a7-4a6b-b338-89d42e502c18",536885418]],["^15",[532,"^Q","This is a predefined ``enum`` in Rust's [[Prelude]]. As we know, rust doesn't have the concept of *null*, the Option Enum is the closes to null we get in Rust as it simply has a variant used to represent the absence of a value.",536885455]],["^15",[532,"^O","^16",536885452]],["^15",[532,"^@",false,536885452]],["^15",[532,"^F",228,536885452]],["^15",[532,"^X",228,536885452]],["^15",[532,"^V",228,536885452]],["^15",[532,"^U",228,536885456]],["^15",[532,"^U",525,536885456]],["^15",[532,"^?",["^ "],536885452]],["^15",[532,"^H",525,536885455]],["^15",[532,"^17",true,536885452]],["^15",[532,"^;","~u64aea5e0-34a0-4d96-b9a3-9018152ea020",536885452]],["^15",[533,"^Q","It is defined like so\n```rust\nenum Option<T> {\n  None,\n  Some(T),\n}\n```\nwhere ``<T>`` is a [[Generic Type]] definition.\n\n\nFor ex.:\n```rust\nfn main() {\n let x = Option::Some(\"yo\"); //T is &str\n let y = None; //Rust allows shorthanding Some or None for the Option's variants.\n let z= match x {\n  Option::Some(value) => 2,\n  None => 5\n }\n}\n```\n\nThe benefit is, we don't need to worry if a value is *null*, because we have to use [[Pattern Matching]] to get value out of an enum and hence it is guaranteed we will only operate on Option's values if they are ``Some``.",536898404]],["^15",[533,"^O","^16",536885455]],["^15",[533,"^F",532,536885455]],["^15",[533,"^X",228,536885455]],["^15",[533,"^V",228,536885455]],["^15",[533,"^U",131,536885594]],["^15",[533,"^U",202,536885594]],["^15",[533,"^U",228,536885594]],["^15",[533,"^?",["^ "],536886578]],["^15",[533,"^H",131,536886578]],["^15",[533,"^H",202,536886578]],["^15",[533,"^17",true,536885455]],["^15",[533,"^;","~u64aea5e0-9811-4ecc-89ee-24fb42f852f3",536885455]],["^15",[534,"^3","- This is a predefined ``enum`` in Rust's [[Prelude]]. As we know, rust doesn't have the concept of *null*, the Option Enum is the closes to null we get in Rust as it simply has a variant used to represent the absence of a value.\n- It is defined like so\n  ```rust\n  enum Option<T> {\n    None,\n    Some(T),\n  }\n  ```\n  where ``<T>`` is a [[Generic Type]] definition.\n  \n  \n  For ex.:\n  ```rust\n  fn main() {\n   let x = Option::Some(\"yo\"); //T is &str\n   let y = None; //Rust allows shorthanding Some or None for the Option's variants.\n   let z= match x {\n    Option::Some(value) => 2,\n    None => 5\n   }\n  }\n  ```\n  \n  The benefit is, we don't need to worry if a value is *null*, because we have to use [[Pattern Matching]] to get value out of an enum and hence it is guaranteed we will only operate on Option's values if they are ``Some``.\n- [[Unwrap]]\n  This [[Method]] is implemented for ``Option``.",536898411]],["^15",[534,"^18","~m1689607701443",536898420]],["^15",[534,"^Z","pages/Option Type.md",536885457]],["^15",[535,"^Q","[[Unwrap]]\nThis [[Method]] is implemented for ``Option``.",536895837]],["^15",[535,"^O","^16",536885460]],["^15",[535,"^F",533,536885640]],["^15",[535,"^X",228,536885460]],["^15",[535,"^V",228,536885460]],["^15",[535,"^U",228,536895825]],["^15",[535,"^U",497,536895825]],["^15",[535,"^U",681,536895825]],["^15",[535,"^?",["^ "],536895837]],["^15",[535,"^H",497,536895837]],["^15",[535,"^H",681,536895837]],["^15",[535,"^17",true,536885460]],["^15",[535,"^;","~u64aea5e6-6c93-400c-8889-a31258067c18",536885460]],["^15",[537,"^Q","Pattern\nThey are a special syntax that allow Rust to perform matching against structures of types, both, simple and complex. Patterns allow a value to be compared against a special syntax and hence alter the flow of the program, i.e., [[Control Flow]].\n\nA pattern contains one or more of these:\n* [[Literals]]\n* [[Destructuring]] of [[Array]]s , [[Enum]]s , [[Struct]]s , or [[Tuple]]s \n* [[Variable]]s \n* Wildcards\n* *Placeholders*: ``_`` the placeholder character.\n\nFor ex.:\n```rust\n   let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n```\n\nHere pattern matching allows Destructuring of tuple ``tup`` and assign its values to the [[Variable]]s ``x``, ``y`` and ``z``.",536915497]],["^15",[537,"^O","^16",536885644]],["^15",[537,"^@",false,536885644]],["^15",[537,"^F",202,536885644]],["^15",[537,"^X",202,536885644]],["^15",[537,"^V",202,536885644]],["^15",[537,"^U",99,536887637]],["^15",[537,"^U",194,536887637]],["^15",[537,"^U",196,536887637]],["^15",[537,"^U",202,536887637]],["^15",[537,"^U",204,536887637]],["^15",[537,"^U",242,536887637]],["^15",[537,"^U",321,536887637]],["^15",[537,"^U",511,536887637]],["^15",[537,"^U",543,536887637]],["^15",[537,"^H",99,536916337]],["^15",[537,"^H",194,536916337]],["^15",[537,"^H",196,536916337]],["^15",[537,"^H",204,536916337]],["^15",[537,"^H",242,536916337]],["^15",[537,"^H",321,536916337]],["^15",[537,"^H",511,536916337]],["^15",[537,"^H",543,536916337]],["^15",[537,"^17",true,536885644]],["^15",[537,"^;","~u64aee0a1-4c04-42f5-8762-946f47413175",536885644]],["^15",[538,"^3","- Pattern\n  They are a special syntax that allow Rust to perform matching against structures of types, both, simple and complex. Patterns allow a value to be compared against a special syntax and hence alter the flow of the program, i.e., [[Control Flow]].\n  \n  A pattern contains one or more of these:\n  * [[Literals]]\n  * [[Destructuring]] of [[Array]]s , [[Enum]]s , [[Struct]]s , or [[Tuple]]s \n  * [[Variable]]s \n  * Wildcards\n  * *Placeholders*: ``_`` the placeholder character.\n  \n  For ex.:\n  ```rust\n     let tup = (500, 6.4, 1);\n  \n      let (x, y, z) = tup;\n  ```\n  \n  Here pattern matching allows Destructuring of tuple ``tup`` and assign its values to the [[Variable]]s ``x``, ``y`` and ``z``.\n- Patterns are everywhere in Rust. Even a simple [[Variable]] assignment is a pattern.\n  As we know from ``while let`` [[Loop]] and ``if-let`` [[Conditional]], ``let`` denotes a pattern and expression assignment.\n  The simple ``let <varname>= <some value>`` is actually ``let <Pattern> = <Expression>``, which is why [[Tuple]] [[Destructuring]] also works.\n- Pattern Types\n  \n  There are 2\n  \n  * *Refutable Pattern*: Patterns that can fail to match an expression.\n  For ex.:\n  ```rust\n  fn main() {\n   let x: Option<i32> = None;\n   if let Some(value) = x { //will fail to match\n    } \n  }\n  ```\n  * *Irrefutable Pattern*: Patterns that will match any value passed to the expression. Such as [[Variable]] assignment ``let <some var>=<some value>``.\n- ``match``\n  This is an advanced version of a *switch* block in other languages. It allows us to compare a value against patterns and then the pattern which matches has its block executed. This is even more powerful because Rust Compiler requires the match patterns to be exhaustive (otherwise an [[Error]]), meaning they must cover all possible values of a type. \n  Furthermore, match is an [[Expression]] so it returns a value.  \n  \n  Syntax:\n  ``\n  match <variable/value> {\n   <Pattern 1> => <some expression>,\n   <Pattern 2> => {<expression, can also use blocks>\n    },\n   ...\n  };\n  ``\n  \n  \n  For ex.:\n  ```rust\n  enum X{\n  Y(i32),\n  Z\n  }\n  \n  fn main() {\n   let x = X::Y(2);\n   let z = match X { //puts 2 in z\n    X::Y(value) => 2,\n    X::Z => {\n      2+4\n     },\n   };\n  }\n  ```\n  The patterns are evaluated from top to bottom, and the first one that matches has its expression executed. After which the match block returns the expression's return value or [[Unit Type]] if no value is being returned explicitly. \n  \n  * Each ``Pattern => Expression`` combo is called an arm, like *case* blocks for *switch* in other langs, but we don't need any ``break;`` statements since matches are [[Expression]]s, so every arm is expected to return the [[Control Flow]] back to the match.\n  \n  * Empty expression: If we desire an expression to do nothing we can simply do ``<Pattern> => ()`` or  ``<Pattern> => { }``(empty blocks return unit type) so it returns the [[Unit Type]] and does nothing.\n  \n  * Using catch-all and empty expression, we can create a *default* case of other langs, i.e., it's a pattern that matches everything and does nothing.\n  For ex.:\n  ```rust\n  fn main() {\n   let x = 2;\n   match x {\n   1=> 2,\n   _ => ()  //catch all, do nothing\n   }\n  };\n  ```\n- Patterns\n  \n  * [[Destructuring]] [[Enum]] \n  Enums in patterns have their values binded to given [[Variable]]s automatically. \n  For ex.:\n  ```rust\n  enum Yo {\n  \tA(i32),\n  \tB\n  }\n  \n  needs a match like,\n      let x= match a {\n         B => \"na\",\n         Yo::A(value) => \"ya\"\n      };\n  ```\n  \n   \n  \n  * Catch-all: We can use a variable to catch all values of a pattern, or the placeholder ``_`` character to catch all and ignore the caught value.\n  For ex.:\n  ```rust\n  fn main() {\n   let x = 2;\n   let y= match x {\n     0 => 0,\n     1 => 1+1,\n     value => value //matches all values, and puts them in the value variable\n   };\n   \n   let z= match x {\n     _ => 2, //catches all, but ignores them. If we use _ in the expression on the right, it'll be an error\n    };\n  }\n  ```\n  The placeholder character can only be used in a pattern. \n  \n  * Matching named variables\n  For ex.:\n  ```rust\n  fn main() {\n      let x = Some(5);\n      let y = 10;\n  \n      match x {\n          Some(50) => println!(\"Got 50\"),\n          Some(y) => println!(\"Matched, y = {y}\"),\n          _ => println!(\"Default case, x = {:?}\", x),\n      }\n  }\n  ```\n  \n  * Matching multiple values: Possible by using the ``|`` syntax, which is much like the ``||`` [[Operator]]. \n  \n  For ex.:\n  ```rust\n  fn main() {\n      let x = 1;\n  \n      match x {\n          1 | 2 => println!(\"one or two\"),\n          3 => println!(\"three\"),\n          _ => println!(\"anything\"),\n      }\n  }\n  \n  ```\n  \n  * Matching values within a [[Range]]: We use ``<start inclusive>..<end exclusive>`` . Can use ``=`` before end to have end inclusive.\n  For ex.:\n  ```rust\n  fn main() {\n      let x = 5;\n  \n      match x {\n          1..=5 => println!(\"one through five\"),\n          _ => println!(\"something else\"),\n      }\n  }\n  ```\n  \n  * [[Destructuring]] [[Struct]]s:\n  \n  For ex.:\n  ```rust\n  struct Point {\n      x: i32,\n      y: i32,\n  }\n  fn main() {\n      let p = Point { x: 0, y: 7 };\n  \n      match p {\n          Point { x, y: 0 } => println!(\"On the x axis at {x}\"), //matches any x, but y as 0, puts both in x and y\n          Point { x: 0, y } => println!(\"On the y axis at {y}\"),\n          Point { x, y } => {\n              println!(\"On neither axis: ({x}, {y})\");\n          }\n      }\n  }\n  ```\n  The actual syntax is ``let <struct> { x: <varname>, y: <varname> } = p;`` but we can omit varnames if they are the same.\n  \n  * [[Destructuring]] [[Struct]]s and [[Tuple]]s\n  For ex.:\n  ```rust\n    struct Point {\n      x: i32,\n      y: i32,\n  }\n   fn main() {\n      let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 }); //creates 4 variables, x, y, feet and inches.\n  }\n  ```\n  \n  * Ignoring values: We can use the placeholder character, and same for [[Variable]]s. By [[Default Linter Rule]] if a variable name starts with ``_`` it is assumed to be unused and doesn't give a warning.\n  \n  We can ignore multiple values in patterns with ``..``.\n  For ex.:\n  ```rust\n  fn main() {\n      let numbers = (2, 4, 8, 16, 32);\n  \n      match numbers {\n          (first, .., last) => { //ignores all the rest\n              println!(\"Some numbers: {first}, {last}\");\n          }\n      }\n  }\n  ```\n  \n  * *Match Guard*: Extra condition to ``match`` arms by using ``if`` [[Conditional]].\n  For ex.:\n  ```rust\n  fn main() {\n      let x = Some(5);\n      let y = 10;\n  \n      match x {\n          Some(50) => println!(\"Got 50\"),\n          Some(n) if n == y => println!(\"Matched, n = {n}\"),\n          _ => println!(\"Default case, x = {:?}\", x),\n      }\n  \n      println!(\"at the end: x = {:?}, y = {y}\", x);\n  }\n  ```\n  \n  * ``@`` Binding: The ``@`` [[Operator]] allows us to capture a value in a variable as well as test it on a pattern at the same time.\n  For ex.:\n  ```rust\n      enum Message {\n          Hello { id: i32 },\n      }\n  \n  fn main(){\n      let msg = Message::Hello { id: 5 };\n  \n      match msg {\n          Message::Hello {\n              id: id_variable @ 3..=7,\n          } => println!(\"yo\"),\n          Message::Hello { id: 10..=12 } => {\n              println!(\"na\")\n          }\n          Message::Hello { id } => println!(\"Found some other id: {}\", id),\n      }\n  }\n  ```\n-\n-\n-\n-",536919035]],["^15",[538,"^18","~m1690518415282",536919034]],["^15",[538,"^Z","pages/Pattern Matching.md",536885648]],["^15",[543,"^K",1689182667167,536885797]],["^15",[543,"^@",false,536885797]],["^15",[543,"^Y","literals",536885797]],["^15",[543,"^11","Literals",536885797]],["^15",[543,"^B",1689182667167,536885797]],["^15",[543,"^;","~u64c20232-1d9f-427a-b712-0bb17ab1d188",536916337]],["^15",[544,"^Q","~``match``\nThis is an advanced version of a *switch* block in other languages. It allows us to compare a value against patterns and then the pattern which matches has its block executed. This is even more powerful because Rust Compiler requires the match patterns to be exhaustive (otherwise an [[Error]]), meaning they must cover all possible values of a type. \nFurthermore, match is an [[Expression]] so it returns a value.  \n\nSyntax:\n``\nmatch <variable/value> {\n <Pattern 1> => <some expression>,\n <Pattern 2> => {<expression, can also use blocks>\n  },\n ...\n};\n``\n\n\nFor ex.:\n```rust\nenum X{\nY(i32),\nZ\n}\n\nfn main() {\n let x = X::Y(2);\n let z = match X { //puts 2 in z\n  X::Y(value) => 2,\n  X::Z => {\n    2+4\n   },\n };\n}\n```\nThe patterns are evaluated from top to bottom, and the first one that matches has its expression executed. After which the match block returns the expression's return value or [[Unit Type]] if no value is being returned explicitly. \n\n* Each ``Pattern => Expression`` combo is called an arm, like *case* blocks for *switch* in other langs, but we don't need any ``break;`` statements since matches are [[Expression]]s, so every arm is expected to return the [[Control Flow]] back to the match.\n\n* Empty expression: If we desire an expression to do nothing we can simply do ``<Pattern> => ()`` or  ``<Pattern> => { }``(empty blocks return unit type) so it returns the [[Unit Type]] and does nothing.\n\n* Using catch-all and empty expression, we can create a *default* case of other langs, i.e., it's a pattern that matches everything and does nothing.\nFor ex.:\n```rust\nfn main() {\n let x = 2;\n match x {\n 1=> 2,\n _ => ()  //catch all, do nothing\n }\n};\n```",536887128]],["^15",[544,"^O","^16",536885891]],["^15",[544,"^@",false,536885891]],["^15",[544,"^F",1023,536915610]],["^15",[544,"^X",202,536885891]],["^15",[544,"^V",202,536885891]],["^15",[544,"^U",129,536886594]],["^15",[544,"^U",202,536886594]],["^15",[544,"^U",208,536886594]],["^15",[544,"^U",211,536886594]],["^15",[544,"^U",321,536886594]],["^15",[544,"^H",129,536916337]],["^15",[544,"^H",208,536916337]],["^15",[544,"^H",211,536916337]],["^15",[544,"^H",321,536916337]],["^15",[544,"^17",true,536885891]],["^15",[544,"^;","~u64aee21f-5bdb-4ec5-9dda-7bd389a15b9e",536885891]],["^15",[547,"^Q","Patterns\n\n* [[Destructuring]] [[Enum]] \nEnums in patterns have their values binded to given [[Variable]]s automatically. \nFor ex.:\n```rust\nenum Yo {\n\tA(i32),\n\tB\n}\n\nneeds a match like,\n    let x= match a {\n       B => \"na\",\n       Yo::A(value) => \"ya\"\n    };\n```\n\n \n\n* Catch-all: We can use a variable to catch all values of a pattern, or the placeholder ``_`` character to catch all and ignore the caught value.\nFor ex.:\n```rust\nfn main() {\n let x = 2;\n let y= match x {\n   0 => 0,\n   1 => 1+1,\n   value => value //matches all values, and puts them in the value variable\n };\n \n let z= match x {\n   _ => 2, //catches all, but ignores them. If we use _ in the expression on the right, it'll be an error\n  };\n}\n```\nThe placeholder character can only be used in a pattern. \n\n* Matching named variables\nFor ex.:\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {y}\"),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n}\n```\n\n* Matching multiple values: Possible by using the ``|`` syntax, which is much like the ``||`` [[Operator]]. \n\nFor ex.:\n```rust\nfn main() {\n    let x = 1;\n\n    match x {\n        1 | 2 => println!(\"one or two\"),\n        3 => println!(\"three\"),\n        _ => println!(\"anything\"),\n    }\n}\n\n```\n\n* Matching values within a [[Range]]: We use ``<start inclusive>..<end exclusive>`` . Can use ``=`` before end to have end inclusive.\nFor ex.:\n```rust\nfn main() {\n    let x = 5;\n\n    match x {\n        1..=5 => println!(\"one through five\"),\n        _ => println!(\"something else\"),\n    }\n}\n```\n\n* [[Destructuring]] [[Struct]]s:\n\nFor ex.:\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {x}\"), //matches any x, but y as 0, puts both in x and y\n        Point { x: 0, y } => println!(\"On the y axis at {y}\"),\n        Point { x, y } => {\n            println!(\"On neither axis: ({x}, {y})\");\n        }\n    }\n}\n```\nThe actual syntax is ``let <struct> { x: <varname>, y: <varname> } = p;`` but we can omit varnames if they are the same.\n\n* [[Destructuring]] [[Struct]]s and [[Tuple]]s\nFor ex.:\n```rust\n  struct Point {\n    x: i32,\n    y: i32,\n}\n fn main() {\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 }); //creates 4 variables, x, y, feet and inches.\n}\n```\n\n* Ignoring values: We can use the placeholder character, and same for [[Variable]]s. By [[Default Linter Rule]] if a variable name starts with ``_`` it is assumed to be unused and doesn't give a warning.\n\nWe can ignore multiple values in patterns with ``..``.\nFor ex.:\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => { //ignores all the rest\n            println!(\"Some numbers: {first}, {last}\");\n        }\n    }\n}\n```\n\n* *Match Guard*: Extra condition to ``match`` arms by using ``if`` [[Conditional]].\nFor ex.:\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {n}\"),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {y}\", x);\n}\n```\n\n* ``@`` Binding: The ``@`` [[Operator]] allows us to capture a value in a variable as well as test it on a pattern at the same time.\nFor ex.:\n```rust\n    enum Message {\n        Hello { id: i32 },\n    }\n\nfn main(){\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } => println!(\"yo\"),\n        Message::Hello { id: 10..=12 } => {\n            println!(\"na\")\n        }\n        Message::Hello { id } => println!(\"Found some other id: {}\", id),\n    }\n}\n```",536919032]],["^15",[547,"^O","^16",536886448]],["^15",[547,"^@",false,536886448]],["^15",[547,"^F",544,536887135]],["^15",[547,"^X",202,536886448]],["^15",[547,"^V",202,536886879]],["^15",[547,"^U",99,536919033]],["^15",[547,"^U",194,536919033]],["^15",[547,"^U",202,536919033]],["^15",[547,"^U",204,536919033]],["^15",[547,"^U",206,536919033]],["^15",[547,"^U",242,536919033]],["^15",[547,"^U",316,536919033]],["^15",[547,"^U",511,536919033]],["^15",[547,"^U",1029,536919033]],["^15",[547,"^U",1087,536919033]],["^15",[547,"^?",["^ "],536919032]],["^15",[547,"^H",99,536919032]],["^15",[547,"^H",194,536919032]],["^15",[547,"^H",204,536919032]],["^15",[547,"^H",206,536919032]],["^15",[547,"^H",242,536919032]],["^15",[547,"^H",316,536919032]],["^15",[547,"^H",511,536919032]],["^15",[547,"^H",1029,536919032]],["^15",[547,"^H",1087,536919032]],["^15",[547,"^17",true,536886448]],["^15",[547,"^;","~u64aee51a-b584-40e8-8760-4b0deffe4df1",536886448]],["^15",[548,"^Q","",536886944]],["^15",[548,"^O","^16",536886944]],["^15",[548,"^@",false,536886944]],["^15",[548,"^F",1024,536916184]],["^15",[548,"^X",202,536886944]],["^15",[548,"^V",202,536886944]],["^15",[548,"^U",202,536886945]],["^15",[548,"^17",true,536886944]],["^15",[548,"^;","~u64aee7ff-56bc-450f-b546-0a9722e1defb",536886944]],["^15",[550,"^Q","",536887152]],["^15",[550,"^O","^16",536887152]],["^15",[550,"^@",false,536887152]],["^15",[550,"^F",552,536887581]],["^15",[550,"^X",316,536887152]],["^15",[550,"^V",316,536887152]],["^15",[550,"^U",316,536887153]],["^15",[550,"^?",["^ "],536887452]],["^15",[550,"^17",true,536887152]],["^15",[550,"^;","~u64aee985-843f-477f-8e93-ecdef26b38bb",536887152]],["^15",[552,"^Q","",536887581]],["^15",[552,"^O","^16",536887581]],["^15",[552,"^@",false,536887581]],["^15",[552,"^F",320,536887581]],["^15",[552,"^X",316,536887581]],["^15",[552,"^V",316,536887581]],["^15",[552,"^U",316,536887582]],["^15",[552,"^?",["^ "],536887581]],["^15",[552,"^17",true,536887581]],["^15",[552,"^;","~u64aeec09-36e3-417d-a232-945c75bd948e",536887581]],["^15",[553,"^U",202,536887597]],["^15",[554,"^U",202,536887597]],["^15",[555,"^U",202,536887597]],["^15",[556,"^U",202,536887597]],["^15",[557,"^U",202,536887597]],["^15",[558,"^U",202,536887597]],["^15",[559,"^U",202,536887597]],["^15",[560,"^U",202,536887597]],["^15",[561,"^U",202,536887597]],["^15",[562,"^U",202,536887597]],["^15",[563,"^U",202,536887597]],["^15",[564,"^U",202,536887597]],["^15",[565,"^U",202,536887597]],["^15",[566,"^12",2,536887644]],["^15",[569,"^Q","[[Module System]]",536887659]],["^15",[569,"^O","^16",536887649]],["^15",[569,"^@",false,536887649]],["^15",[569,"^F",317,536887649]],["^15",[569,"^X",28,536887649]],["^15",[569,"^V",28,536887649]],["^15",[569,"^U",28,536887660]],["^15",[569,"^U",570,536887660]],["^15",[569,"^H",570,536916343]],["^15",[569,"^17",true,536887649]],["^15",[569,"^;","~u64afa7aa-143b-44ec-8dd7-f6653ee21c0f",536887649]],["^15",[570,"^K",1689233338144,536887659]],["^15",[570,"^[",573,536887668]],["^15",[570,"^O","^16",536887663]],["^15",[570,"^@",false,536887659]],["^15",[570,"^Y","module system",536887659]],["^15",[570,"^11","Module System",536887659]],["^15",[570,"^B",1689513095178,536894035]],["^15",[570,"^;","~u64c20233-66a9-4d52-92c9-99b6275b617a",536916343]],["^15",[571,"^Q","[[Testing Framework]]",536905302]],["^15",[571,"^O","^16",536887659]],["^15",[571,"^@",false,536887659]],["^15",[571,"^F",569,536887659]],["^15",[571,"^X",28,536887659]],["^15",[571,"^V",28,536887659]],["^15",[571,"^U",28,536905303]],["^15",[571,"^U",804,536905303]],["^15",[571,"^H",804,536916343]],["^15",[571,"^17",true,536887659]],["^15",[571,"^;","~u64afa7ba-2337-43ff-8c01-a9e865994eb8",536887659]],["^15",[572,"^Q","Rust, through [[Cargo]], allows multiple files and modules for managing big programs/projects.\nRust uses these features to allow us to organize our projects,\n *Packages*: A Cargo feature that lets us build, test, and share [[Crate]]s\n[[Crate]]s: A tree of [[Crate]]s that produces a library or executable.\n[[Module]]s and [[use]]: Lets us control the organization, [[Scope]] , and privacy of *Paths*\n*Paths*: A way of naming an item, such as a [[Struct]] , [[Function]] , or [[Module]]",536888124]],["^15",[572,"^O","^16",536887664]],["^15",[572,"^@",false,536887664]],["^15",[572,"^F",570,536887664]],["^15",[572,"^X",570,536887664]],["^15",[572,"^V",570,536887664]],["^15",[572,"^U",45,536887895]],["^15",[572,"^U",89,536887895]],["^15",[572,"^U",90,536887895]],["^15",[572,"^U",130,536887895]],["^15",[572,"^U",242,536887895]],["^15",[572,"^U",530,536887895]],["^15",[572,"^U",570,536887895]],["^15",[572,"^U",577,536887895]],["^15",[572,"^?",["^ "],536888124]],["^15",[572,"^H",45,536888124]],["^15",[572,"^H",89,536888124]],["^15",[572,"^H",90,536888124]],["^15",[572,"^H",130,536888124]],["^15",[572,"^H",242,536888124]],["^15",[572,"^H",530,536888124]],["^15",[572,"^H",577,536888124]],["^15",[572,"^17",true,536887664]],["^15",[572,"^;","~u64afa7bb-0ce7-49c8-b6d1-100924390596",536887664]],["^15",[573,"^3","- Rust, through [[Cargo]], allows multiple files and modules for managing big programs/projects.\n  Rust uses these features to allow us to organize our projects,\n   *Packages*: A Cargo feature that lets us build, test, and share [[Crate]]s\n  [[Crate]]s: A tree of [[Crate]]s that produces a library or executable.\n  [[Module]]s and [[use]]: Lets us control the organization, [[Scope]] , and privacy of *Paths*\n  *Paths*: A way of naming an item, such as a [[Struct]] , [[Function]] , or [[Module]]\n- Package\n  One or more [[Crate]]s that provides a set of functionality. Every package needs a [[cargo.toml]] file to define how to build the crates, it also needs at-least 1 [[Crate]], and it can contain at-most 1 library crate but any number of binary crates.\n- Folder Structure\n  When we create a new project with using [[Cargo]]'s ``cargo new <package-name>``, cargo creates a folder ``<package-name>`` with a [[cargo.toml]] file in it and places a folder named ``src`` in it as well. \n  \n  Inside the ``src`` folder, a file ``main.rs`` is created. This file is the [[Crate]] Root of this binary crate and this binary crate is named the same as the ``<package-name>``. We can create a ``src/lib.rs`` and this file is assumed as the library crate of the package, the name of this crate is the same as the ``<package-name>`` as well. If a crate contains both ``main.rs`` and ``lib.rs`` then 2 crates are created for the package, with the same names as the ``<package-name>``. All the other binary crates can be placed in the ``src/bin`` directory, every file inside it is treated as a separate binary crate.\n  \n  For ex.:\n  ```bash\n  $ cargo new my-project\n       Created binary (application) `my-project` package\n  $ ls my-project\n  Cargo.toml\n  src\n  $ ls my-project/src\n  main.rs\n  ```\n  \n  * We can define both ``lib.rs`` and ``main.rs`` for a [[Crate]]. When our crate is used as a binary crate, the ``main.rs`` file is ran and when it is used as a library crate, ``lib.rs`` is executed. So by always having the ``lib.rs`` and defining all functionality in it, and just having ``main.rs`` call the ``lib.rs`` we make a pattern that allows our crate to be directly used as a library crate as well and allows us to have our binary crate be a client of our own library crate, which  is a better architecture as we get the same behavior as any external .\n  \n  For ex.:\n  For a ``lib.rs``,\n  \n  ```rust\n  pub fn yo() {…}\n  ```\n  \n  the ``main.rs`` would be,\n  ```rust\n  use myCrate;\n  \n  fn main() {\n  \tmyCrate::yo();\n  }\n  \n  ```\n  \n  and the [[cargo.toml]] would be,\n  ```toml\n  [package]\n  name = \"myCrate\"\n  version = \"0.1.0\"\n  edition = \"2021\"\n  ```\n  \n  All 3 steps are important. The ``lib.rs`` becomes the crate with the same name as the ``<package-name>``, hence [[Access Modifier]] rules are followed even through [[Crate]] root which is ``main.rs``. We have abstracted away the crate root’s content into a different crate hence even it must access the ``lib.rs`` like external crates would. And ``main.rs`` needs to open the path to it, the ``lib.rs`` items aren’t in ``main.rs``’ scope. \n  Lastly, the ``cargo.toml`` definition describes important metadata. Even without “edition” key, the ``main.rs`` wouldn’t be able to access the lib.rs.\n- [[Cargo]]'s compilation flow\n  \n  First the [[Crate]] Root is opened, i.e. either the ``main.rs`` and if it’s not there then ``lib.rs``. \n  Then all the [[Module]]s defined at top indicate modules to be imported. Then to look for the code of the [[Module]], \n  the compiler first checks if the line is followed by ``{…}`` instead of a semicolon, if it is then that’s assumed as the code for it, otherwise it goes to ``src/<module-name>.rs``. If this file is not found then it goes to ``src/<module-name>/mod.rs``. \n  Then, if the [[Module]]'s crate defines its own sub-modules then they are looked for inside the Module's [[Crate]]'s directory ``src/<module-name>/<sub-module-name>.rs`` or ``src/<module-name>/<sub-module-name>/mod.rs``.\n  \n  For ex.:\n  If we have the [[Module]] ``mod garden`` in our [[Crate]] Root ``backyard``, then it is looked for in ``src/garden.rs`` and ``src/garden/mod.rs``.  \n  Then, if ``garden.rs`` [[Crate]] defines a [[Module]] ``mod vegetables;`` \n  then it is looked for in ``src/garden/vegetables.rs`` and finally ``src/garden/vegetables/mod.rs``.\n  The folder structure looks like so\n  ```\n  backyard\n  ├── Cargo.lock\n  ├── Cargo.toml\n  └── src\n      ├── garden\n      │   └── vegetables.rs\n      ├── garden.rs\n      └── main.rs\n  ```\n  \n  \n  Finally from the last [[Crate]] to the first one, all the crates are compiled.\n-\n-",536894038]],["^15",[573,"^18","~m1689513095670",536894037]],["^15",[573,"^Z","pages/Module System.md",536887668]],["^15",[574,"^Q","",536889182]],["^15",[574,"^O","^16",536887684]],["^15",[574,"^@",false,536887684]],["^15",[574,"^F",595,536889676]],["^15",[574,"^X",570,536887684]],["^15",[574,"^V",570,536887684]],["^15",[574,"^U",570,536887685]],["^15",[574,"^?",["^ "],536889182]],["^15",[574,"^17",true,536887684]],["^15",[574,"^;","~u64afa7f5-da76-4576-a16b-525eefedd34a",536887684]],["^15",[577,"^K",1689233497012,536887759]],["^15",[577,"^[",581,536887903]],["^15",[577,"^O","^16",536887898]],["^15",[577,"^@",false,536887759]],["^15",[577,"^Y","crate",536887759]],["^15",[577,"^11","Crate",536887759]],["^15",[577,"^B",1689556862936,536896924]],["^15",[577,"^;","~u64c20233-26f4-4f17-b1e0-5dd4ff4d9be7",536916346]],["^15",[578,"^Q","",536888106]],["^15",[578,"^O","^16",536887770]],["^15",[578,"^@",false,536887770]],["^15",[578,"^?",["^ "],536888106]],["^15",[578,"^17",true,536887770]],["^15",[578,"^;","~u64afa86a-7f5d-4d60-8801-46f6042fccf6",536887770]],["^15",[579,"^3","-",536888109]],["^15",[579,"^18","~m1689234144425",536888108]],["^15",[579,"^Z","pages/Crates.md",536887774]],["^15",[580,"^Q","~``crate``\nIt's the smallest compiled entity in Rust. \nIt's simply a namespace that includes a project's contents which can then have [[Access Modifier]]s and the public items can be referred to by external code when the external code imports the crate holding them. \n\nLike our project's crate. When [[Cargo]] compiles our project, the root crate includes our entire project directory and when [[rustc]] compiles a file, the root crate includes only the ``.rs`` file's contents.  Both also compile all the crates being imported into our file/project, and then their imported files and so on. But our project's crate only contains our project/file's contents.\n\nFor ex.:\n``std::prelude`` is a crate that includes all the public [[Access Modifier]] contents of the [[Prelude]] project.",536888789]],["^15",[580,"^O","^16",536887899]],["^15",[580,"^@",false,536887899]],["^15",[580,"^F",577,536887899]],["^15",[580,"^X",577,536887899]],["^15",[580,"^V",577,536887899]],["^15",[580,"^U",45,536888774]],["^15",[580,"^U",50,536888774]],["^15",[580,"^U",525,536888774]],["^15",[580,"^U",577,536888774]],["^15",[580,"^U",583,536888774]],["^15",[580,"^?",["^ "],536888789]],["^15",[580,"^H",45,536888789]],["^15",[580,"^H",50,536888789]],["^15",[580,"^H",525,536888789]],["^15",[580,"^H",583,536888789]],["^15",[580,"^17",true,536887899]],["^15",[580,"^;","~u64afa975-f727-44e2-b040-91d05cc34b9d",536887899]],["^15",[581,"^3","- ``crate``\n  It's the smallest compiled entity in Rust. \n  It's simply a namespace that includes a project's contents which can then have [[Access Modifier]]s and the public items can be referred to by external code when the external code imports the crate holding them. \n  \n  Like our project's crate. When [[Cargo]] compiles our project, the root crate includes our entire project directory and when [[rustc]] compiles a file, the root crate includes only the ``.rs`` file's contents.  Both also compile all the crates being imported into our file/project, and then their imported files and so on. But our project's crate only contains our project/file's contents.\n  \n  For ex.:\n  ``std::prelude`` is a crate that includes all the public [[Access Modifier]] contents of the [[Prelude]] project.\n- A [[Package]] and a Crate are 2 different things\n  Whilst a Package contains all the crates in a project, a crate is simply a single ``.rs`` file and it may have [[Module]]s, which can then be their own ``.rs`` files. \n  So a Package is a collection of crates, and a crate is a collection of modules.\n- Crate Root\n  The source file where we start the compilation, we can then define all the various [[Crate]]s/ [[Module]]s/ [[Function]]s/ [[Struct]]s/ [[Enum]]s/ [[Trait Object]]s/ [[Method]]s and their ``impl`` blocks and so on in it.\n  [[Cargo]] looks for ``main.rs`` or ``lib.rs`` and the one it picks becomes the Crate Root. \n  When we use [[rustc]] on a file then it becomes the Crate Root.\n  \n  * We can access the crate root's contents with the ``crate`` [[Module]].\n  * All the contents of the source file, including the [[Module]]s, are bundled up and put in the ``crate`` [[Module]]. This is why it's called [[Crate]] Root, since it is the rootmost [[Module]] and is the starting point for accessing any [[Module]].\n- Binary and Library Crate\n  A Crate can only be either a binary or a library crate. \n  \n  Binary Crate: A crate that can be compiled to an executable. It needs to have a ``main`` [[Function]]. Then this crate's executable can be ran on a system.\n  \n  Library Crate : This crate doesn't compile to an executable, doesn't have a ``main`` [[Function]] and hence can't be directly used by a system. It's purpose is to bundle up a project's [[Module]]s, [[Function]]s etc. allowing them to be imported into other project's and then adding predefined functionality to those projects.\n- ``crate`` or ``<package-name>``\n  The ``crate`` is the the Crate Root or rather, it's the namespace of the crate where the compilation begins. However, when external crates are being used, then we use their ``<package-name>`` to access their contents where ``package-name`` is the name of the [[Package]]. The ``<package-name>`` namespace has all the public items in all crates of a package. \n  When our [[Package]] is used externally, Rust compiler knows ``crate`` in our crate meant our ``<package-name>``.\n  \n  For ex.:\n  If our ``<package-name>`` is  ``X`` then\n  ```rust\n  mod Y {\n   pub fn yo(){}\n  }\n  \n  fn main() {\n   X::Y::yo(); \n   //is the same as\n   crate::Y::yo();\n  }\n  ```\n-",536896926]],["^15",[581,"^18","~m1689556863181",536896925]],["^15",[581,"^Z","pages/Crate.md",536887903]],["^15",[582,"^Q","~``mod``\nA module allows us to group and organize code within a [[Crate]] for easy reusability and readability. It also puts [[Access Modifier]]s on its items, which is private by default. Module definitions need to be at the top of an ``.rs`` file.\n\nSyntax:\n``\n<access modifier> mod <name> {\n //stuff\n} \n\n//or\n<access modifier> mod <name>;\n``\n\nFor ex.:\nIn main.rs,\n```rust\nmod x { //module names must be in snake-case\n pub fn yo() {}\n}\n\nfn main() {\n crate::x::yo(); //to access it\n}\n```",536893553]],["^15",[582,"^O","^16",536888102]],["^15",[582,"^@",false,536888102]],["^15",[582,"^F",530,536888102]],["^15",[582,"^X",530,536888102]],["^15",[582,"^V",530,536888102]],["^15",[582,"^U",530,536889228]],["^15",[582,"^U",577,536889228]],["^15",[582,"^U",583,536889228]],["^15",[582,"^?",["^ "],536893553]],["^15",[582,"^H",577,536893553]],["^15",[582,"^H",583,536893553]],["^15",[582,"^17",true,536888102]],["^15",[582,"^;","~u64afaad4-ed48-48d5-b714-6b6fa4027c06",536888102]],["^15",[583,"^K",1689234570283,536888331]],["^15",[583,"^[",607,536891144]],["^15",[583,"^O","^16",536891132]],["^15",[583,"^@",false,536888331]],["^15",[583,"^Y","access modifier",536888331]],["^15",[583,"^11","Access Modifier",536888331]],["^15",[583,"^B",1689508211291,536891997]],["^15",[583,"^;","~u64c20233-70f6-42ff-a2c1-b46eaff53e10",536916346]],["^15",[584,"^Q","Package\nOne or more [[Crate]]s that provides a set of functionality. Every package needs a [[cargo.toml]] file to define how to build the crates, it also needs at-least 1 [[Crate]], and it can contain at-most 1 library crate but any number of binary crates.",536888452]],["^15",[584,"^O","^16",536888390]],["^15",[584,"^@",false,536888390]],["^15",[584,"^F",572,536888390]],["^15",[584,"^X",570,536888390]],["^15",[584,"^V",570,536888390]],["^15",[584,"^U",43,536888425]],["^15",[584,"^U",570,536888425]],["^15",[584,"^U",577,536888425]],["^15",[584,"^?",["^ "],536888452]],["^15",[584,"^H",43,536888452]],["^15",[584,"^H",577,536888452]],["^15",[584,"^17",true,536888390]],["^15",[584,"^;","~u64afad0a-e595-45c5-83f6-a2100657fac5",536888390]],["^15",[585,"^Q","Folder Structure\nWhen we create a new project with using [[Cargo]]'s ``cargo new <package-name>``, cargo creates a folder ``<package-name>`` with a [[cargo.toml]] file in it and places a folder named ``src`` in it as well. \n\nInside the ``src`` folder, a file ``main.rs`` is created. This file is the [[Crate]] Root of this binary crate and this binary crate is named the same as the ``<package-name>``. We can create a ``src/lib.rs`` and this file is assumed as the library crate of the package, the name of this crate is the same as the ``<package-name>`` as well. If a crate contains both ``main.rs`` and ``lib.rs`` then 2 crates are created for the package, with the same names as the ``<package-name>``. All the other binary crates can be placed in the ``src/bin`` directory, every file inside it is treated as a separate binary crate.\n\nFor ex.:\n```bash\n$ cargo new my-project\n     Created binary (application) `my-project` package\n$ ls my-project\nCargo.toml\nsrc\n$ ls my-project/src\nmain.rs\n```\n\n* We can define both ``lib.rs`` and ``main.rs`` for a [[Crate]]. When our crate is used as a binary crate, the ``main.rs`` file is ran and when it is used as a library crate, ``lib.rs`` is executed. So by always having the ``lib.rs`` and defining all functionality in it, and just having ``main.rs`` call the ``lib.rs`` we make a pattern that allows our crate to be directly used as a library crate as well and allows us to have our binary crate be a client of our own library crate, which  is a better architecture as we get the same behavior as any external .\n\nFor ex.:\nFor a ``lib.rs``,\n\n```rust\npub fn yo() {…}\n```\n\nthe ``main.rs`` would be,\n```rust\nuse myCrate;\n\nfn main() {\n\tmyCrate::yo();\n}\n\n```\n\nand the [[cargo.toml]] would be,\n```toml\n[package]\nname = \"myCrate\"\nversion = \"0.1.0\"\nedition = \"2021\"\n```\n\nAll 3 steps are important. The ``lib.rs`` becomes the crate with the same name as the ``<package-name>``, hence [[Access Modifier]] rules are followed even through [[Crate]] root which is ``main.rs``. We have abstracted away the crate root’s content into a different crate hence even it must access the ``lib.rs`` like external crates would. And ``main.rs`` needs to open the path to it, the ``lib.rs`` items aren’t in ``main.rs``’ scope. \nLastly, the ``cargo.toml`` definition describes important metadata. Even without “edition” key, the ``main.rs`` wouldn’t be able to access the lib.rs.",536894035]],["^15",[585,"^O","^16",536888392]],["^15",[585,"^@",false,536888392]],["^15",[585,"^F",584,536888392]],["^15",[585,"^X",570,536888392]],["^15",[585,"^V",570,536888392]],["^15",[585,"^U",43,536894036]],["^15",[585,"^U",45,536894036]],["^15",[585,"^U",570,536894036]],["^15",[585,"^U",577,536894036]],["^15",[585,"^U",583,536894036]],["^15",[585,"^?",["^ "],536894035]],["^15",[585,"^H",43,536894035]],["^15",[585,"^H",45,536894035]],["^15",[585,"^H",577,536894035]],["^15",[585,"^H",583,536894035]],["^15",[585,"^17",true,536888392]],["^15",[585,"^;","~u64afad0b-c1a5-4bda-ad88-9f2ab46219a1",536888392]],["^15",[586,"^Q","[[Cargo]]'s compilation flow\n\nFirst the [[Crate]] Root is opened, i.e. either the ``main.rs`` and if it’s not there then ``lib.rs``. \nThen all the [[Module]]s defined at top indicate modules to be imported. Then to look for the code of the [[Module]], \nthe compiler first checks if the line is followed by ``{…}`` instead of a semicolon, if it is then that’s assumed as the code for it, otherwise it goes to ``src/<module-name>.rs``. If this file is not found then it goes to ``src/<module-name>/mod.rs``. \nThen, if the [[Module]]'s crate defines its own sub-modules then they are looked for inside the Module's [[Crate]]'s directory ``src/<module-name>/<sub-module-name>.rs`` or ``src/<module-name>/<sub-module-name>/mod.rs``.\n\nFor ex.:\nIf we have the [[Module]] ``mod garden`` in our [[Crate]] Root ``backyard``, then it is looked for in ``src/garden.rs`` and ``src/garden/mod.rs``.  \nThen, if ``garden.rs`` [[Crate]] defines a [[Module]] ``mod vegetables;`` \nthen it is looked for in ``src/garden/vegetables.rs`` and finally ``src/garden/vegetables/mod.rs``.\nThe folder structure looks like so\n```\nbackyard\n├── Cargo.lock\n├── Cargo.toml\n└── src\n    ├── garden\n    │   └── vegetables.rs\n    ├── garden.rs\n    └── main.rs\n```\n\n\nFinally from the last [[Crate]] to the first one, all the crates are compiled.",536893549]],["^15",[586,"^O","^16",536888394]],["^15",[586,"^@",false,536888394]],["^15",[586,"^F",585,536888394]],["^15",[586,"^X",570,536888394]],["^15",[586,"^V",570,536888394]],["^15",[586,"^U",45,536889392]],["^15",[586,"^U",530,536889392]],["^15",[586,"^U",570,536889392]],["^15",[586,"^U",577,536889392]],["^15",[586,"^?",["^ "],536893549]],["^15",[586,"^H",45,536893549]],["^15",[586,"^H",530,536893549]],["^15",[586,"^H",577,536893549]],["^15",[586,"^17",true,536888394]],["^15",[586,"^;","~u64afad0b-6168-4bd7-9407-898801c05e5d",536888394]],["^15",[587,"^Q","Crate Root\nThe source file where we start the compilation, we can then define all the various [[Crate]]s/ [[Module]]s/ [[Function]]s/ [[Struct]]s/ [[Enum]]s/ [[Trait Object]]s/ [[Method]]s and their ``impl`` blocks and so on in it.\n[[Cargo]] looks for ``main.rs`` or ``lib.rs`` and the one it picks becomes the Crate Root. \nWhen we use [[rustc]] on a file then it becomes the Crate Root.\n\n* We can access the crate root's contents with the ``crate`` [[Module]].\n* All the contents of the source file, including the [[Module]]s, are bundled up and put in the ``crate`` [[Module]]. This is why it's called [[Crate]] Root, since it is the rootmost [[Module]] and is the starting point for accessing any [[Module]].",536891346]],["^15",[587,"^O","^16",536888456]],["^15",[587,"^@",false,536888456]],["^15",[587,"^F",706,536896866]],["^15",[587,"^X",577,536888456]],["^15",[587,"^V",577,536888456]],["^15",[587,"^U",45,536890858]],["^15",[587,"^U",50,536890858]],["^15",[587,"^U",130,536890858]],["^15",[587,"^U",242,536890858]],["^15",[587,"^U",262,536890858]],["^15",[587,"^U",497,536890858]],["^15",[587,"^U",511,536890858]],["^15",[587,"^U",530,536890858]],["^15",[587,"^U",577,536890858]],["^15",[587,"^?",["^ "],536891346]],["^15",[587,"^H",45,536891346]],["^15",[587,"^H",50,536891346]],["^15",[587,"^H",130,536891346]],["^15",[587,"^H",242,536891346]],["^15",[587,"^H",262,536891346]],["^15",[587,"^H",497,536891346]],["^15",[587,"^H",511,536891346]],["^15",[587,"^H",530,536891346]],["^15",[587,"^H",577,536891346]],["^15",[587,"^17",true,536888456]],["^15",[587,"^;","~u64afad79-85bf-4871-bc95-d121e1721fdc",536888456]],["^15",[588,"^Q","Binary and Library Crate\nA Crate can only be either a binary or a library crate. \n\nBinary Crate: A crate that can be compiled to an executable. It needs to have a ``main`` [[Function]]. Then this crate's executable can be ran on a system.\n\nLibrary Crate : This crate doesn't compile to an executable, doesn't have a ``main`` [[Function]] and hence can't be directly used by a system. It's purpose is to bundle up a project's [[Module]]s, [[Function]]s etc. allowing them to be imported into other project's and then adding predefined functionality to those projects.",536888686]],["^15",[588,"^O","^16",536888463]],["^15",[588,"^@",false,536888463]],["^15",[588,"^F",587,536890946]],["^15",[588,"^X",577,536888463]],["^15",[588,"^V",577,536888463]],["^15",[588,"^U",130,536888638]],["^15",[588,"^U",530,536888638]],["^15",[588,"^U",577,536888638]],["^15",[588,"^?",["^ "],536890946]],["^15",[588,"^H",130,536890946]],["^15",[588,"^H",530,536890946]],["^15",[588,"^17",true,536888463]],["^15",[588,"^;","~u64afad83-bd12-4482-b0ab-9c9c2ac720aa",536888463]],["^15",[591,"^3","- ``mod``\n  A module allows us to group and organize code within a [[Crate]] for easy reusability and readability. It also puts [[Access Modifier]]s on its items, which is private by default. Module definitions need to be at the top of an ``.rs`` file.\n  \n  Syntax:\n  ``\n  <access modifier> mod <name> {\n   //stuff\n  } \n  \n  //or\n  <access modifier> mod <name>;\n  ``\n  \n  For ex.:\n  In main.rs,\n  ```rust\n  mod x { //module names must be in snake-case\n   pub fn yo() {}\n  }\n  \n  fn main() {\n   crate::x::yo(); //to access it\n  }\n  ```\n- Modules can be defined right away, which is done by having a ``{ }`` block after them, if we instead have a ``;`` semicolon after the definition, then the module is looked for in the places defined in [[Module System]]. Either way, this *imports* a module into our [[Crate]] and all the module's contents with the appropriate [[Access Modifier]] can be accessed by the crate.\n- Modules can nest other modules as well.\n- Path to an item in a module\n  The path to an item in a starts from the [[Crate]] Root to the module in it, then its submodules and so on.\n  \n  For ex.:\n  For this module definition in main.rs\n  ```rust\n  mod x {\n   mod y { \n   fn yo(){}\n   }\n   pub mod z { \n   pub fn yo(){}\n   }\n  }\n  ```\n  Rust would need to get\n  ```rust\n  crate::x::z::yo();\n  ```\n  \n  ``crate`` is the [[Crate]] Root, so here it is accessing itself. \n  \n  * Absolute vs. Relative Path\n  Whilst the absolute path starts from the [[Crate]] Root, a relative path is used when the item is within this crate.\n  For ex.:\n  In ``main.rs``\n  ```rust\n  mod front_of_house {\n      pub mod hosting {\n          pub fn add_to_waitlist() {}\n      }\n  }\n  \n  pub fn eat_at_restaurant() {\n      // Absolute path\n      crate::front_of_house::hosting::add_to_waitlist();\n  \n      // Relative path\n      front_of_house::hosting::add_to_waitlist();\n  }\n  ```\n  The relative path starts from the current crate.\n  \n  * [[super]]\n  \n  \n  \n  * [[use]]\n  This keyword basically opens a namespace.\n- Modules defined in separate files\n  As defined in [[Module System]], a module can either have its definition at the time of declaration\n  ``mod <name> {...}`` or it can have a semicolon ``mod <name>;``, in which case the module's definition is looked for in some specific places. \n  This allows us to break our project down into multiple modules and hence multiple files.\n  \n  For ex.:\n  In ``main.rs`` or ``lib.rs``,\n  ```rust\n  mod modA;\n  ```\n  \n  Create ``src/modA.rs`` or ``src/modA/mod.rs`` with content\n  ```rust\n  mod modA {\n  \tpub modB{\n  \t\tpub fnA(){}\t\n   }\n  }\n  \n  pub mod modC;\n  ```\n  \n  Then create ``src/modA/modC.rs`` or ``src/modA/modC/mod.rs`` \n  ```rust\n  pub mod modC {\n   pub fnA() {}\n  }\n  ```\n  \n  While using ``mod.rs`` seems more intuitive/organized, the same filenames make it confusing for working in IDEs but to the compiler it makes no difference and we can even mix both folder structures for a project. However each module must only be declared using any one method not both.\n-",536905965]],["^15",[591,"^18","~m1689875758520",536905964]],["^15",[591,"^Z","pages/Module.md",536889187]],["^15",[592,"^U",570,536889244]],["^15",[593,"^U",570,536889262]],["^15",[594,"^U",570,536889262]],["^15",[595,"^Q","",536889680]],["^15",[595,"^O","^16",536889676]],["^15",[595,"^@",false,536889676]],["^15",[595,"^F",586,536889676]],["^15",[595,"^X",570,536889676]],["^15",[595,"^V",570,536889676]],["^15",[595,"^U",570,536889677]],["^15",[595,"^?",["^ "],536889680]],["^15",[595,"^17",true,536889676]],["^15",[595,"^;","~u64b0075b-1165-417f-9755-9d4be9c8001c",536889676]],["^15",[596,"^Q","Path to an item in a module\nThe path to an item in a starts from the [[Crate]] Root to the module in it, then its submodules and so on.\n\nFor ex.:\nFor this module definition in main.rs\n```rust\nmod x {\n mod y { \n fn yo(){}\n }\n pub mod z { \n pub fn yo(){}\n }\n}\n```\nRust would need to get\n```rust\ncrate::x::z::yo();\n```\n\n``crate`` is the [[Crate]] Root, so here it is accessing itself. \n\n* Absolute vs. Relative Path\nWhilst the absolute path starts from the [[Crate]] Root, a relative path is used when the item is within this crate.\nFor ex.:\nIn ``main.rs``\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\nThe relative path starts from the current crate.\n\n* [[super]]\n\n\n\n* [[use]]\nThis keyword basically opens a namespace.",536905963]],["^15",[596,"^O","^16",536889711]],["^15",[596,"^@",false,536889711]],["^15",[596,"^F",599,536890030]],["^15",[596,"^X",530,536889711]],["^15",[596,"^V",530,536892373]],["^15",[596,"^U",90,536905960]],["^15",[596,"^U",530,536905960]],["^15",[596,"^U",577,536905960]],["^15",[596,"^U",828,536905960]],["^15",[596,"^?",["^ "],536905963]],["^15",[596,"^H",90,536905963]],["^15",[596,"^H",577,536905963]],["^15",[596,"^H",828,536905963]],["^15",[596,"^17",true,536889711]],["^15",[596,"^;","~u64b0158f-a65c-47a0-8c79-bafbda359bf6",536889711]],["^15",[597,"^Q","Modules can be defined right away, which is done by having a ``{ }`` block after them, if we instead have a ``;`` semicolon after the definition, then the module is looked for in the places defined in [[Module System]]. Either way, this *imports* a module into our [[Crate]] and all the module's contents with the appropriate [[Access Modifier]] can be accessed by the crate.",536889968]],["^15",[597,"^O","^16",536889799]],["^15",[597,"^@",false,536889799]],["^15",[597,"^F",582,536889799]],["^15",[597,"^X",530,536889799]],["^15",[597,"^V",530,536889799]],["^15",[597,"^U",530,536889965]],["^15",[597,"^U",570,536889965]],["^15",[597,"^U",577,536889965]],["^15",[597,"^U",583,536889965]],["^15",[597,"^?",["^ "],536889968]],["^15",[597,"^H",570,536889968]],["^15",[597,"^H",577,536889968]],["^15",[597,"^H",583,536889968]],["^15",[597,"^17",true,536889799]],["^15",[597,"^;","~u64b01688-d835-4573-a7e9-1f32ffab2409",536889799]],["^15",[599,"^Q","Modules can nest other modules as well.",536890034]],["^15",[599,"^O","^16",536890030]],["^15",[599,"^@",false,536890030]],["^15",[599,"^F",597,536890030]],["^15",[599,"^X",530,536890030]],["^15",[599,"^V",530,536890030]],["^15",[599,"^U",530,536890031]],["^15",[599,"^?",["^ "],536890034]],["^15",[599,"^17",true,536890030]],["^15",[599,"^;","~u64b01818-e8cc-4306-b754-c507c114978c",536890030]],["^15",[600,"^Q","Modules defined in separate files\nAs defined in [[Module System]], a module can either have its definition at the time of declaration\n``mod <name> {...}`` or it can have a semicolon ``mod <name>;``, in which case the module's definition is looked for in some specific places. \nThis allows us to break our project down into multiple modules and hence multiple files.\n\nFor ex.:\nIn ``main.rs`` or ``lib.rs``,\n```rust\nmod modA;\n```\n\nCreate ``src/modA.rs`` or ``src/modA/mod.rs`` with content\n```rust\nmod modA {\n\tpub modB{\n\t\tpub fnA(){}\t\n }\n}\n\npub mod modC;\n```\n\nThen create ``src/modA/modC.rs`` or ``src/modA/modC/mod.rs`` \n```rust\npub mod modC {\n pub fnA() {}\n}\n```\n\nWhile using ``mod.rs`` seems more intuitive/organized, the same filenames make it confusing for working in IDEs but to the compiler it makes no difference and we can even mix both folder structures for a project. However each module must only be declared using any one method not both.",536893929]],["^15",[600,"^O","^16",536890191]],["^15",[600,"^@",false,536890191]],["^15",[600,"^F",596,536892373]],["^15",[600,"^X",530,536890191]],["^15",[600,"^V",530,536890191]],["^15",[600,"^U",530,536893578]],["^15",[600,"^U",570,536893578]],["^15",[600,"^?",["^ "],536893929]],["^15",[600,"^H",570,536893929]],["^15",[600,"^17",true,536890191]],["^15",[600,"^;","~u64b01924-a4ae-402f-acff-bb3d07764a2f",536890191]],["^15",[602,"^Q","~``crate`` or ``<package-name>``\nThe ``crate`` is the the Crate Root or rather, it's the namespace of the crate where the compilation begins. However, when external crates are being used, then we use their ``<package-name>`` to access their contents where ``package-name`` is the name of the [[Package]]. The ``<package-name>`` namespace has all the public items in all crates of a package. \nWhen our [[Package]] is used externally, Rust compiler knows ``crate`` in our crate meant our ``<package-name>``.\n\nFor ex.:\nIf our ``<package-name>`` is  ``X`` then\n```rust\nmod Y {\n pub fn yo(){}\n}\n\nfn main() {\n X::Y::yo(); \n //is the same as\n crate::Y::yo();\n}\n```",536896863]],["^15",[602,"^O","^16",536890949]],["^15",[602,"^@",false,536890949]],["^15",[602,"^F",588,536890949]],["^15",[602,"^X",577,536890949]],["^15",[602,"^V",577,536890949]],["^15",[602,"^U",577,536896821]],["^15",[602,"^U",704,536896821]],["^15",[602,"^?",["^ "],536896863]],["^15",[602,"^H",704,536896863]],["^15",[602,"^17",true,536890949]],["^15",[602,"^;","~u64b0221d-10fa-4227-936c-3fc1c280cb1a",536890949]],["^15",[603,"^12",2,536891100]],["^15",[606,"^Q","[[Module]]s theirselves, and items within them are *private* by default, which in Rust means, that parent modules can't access these modules or their items. We use the ``pub`` keyword to turn them to *public* and hence allow external modules to access them.\nThis isn't just true for modules, but all items, [[Struct]]s/ [[Function]]s etc. either outside a [[Module]] or inside, in a [[Crate]]. Items in the open in a crate, are available directly from the crate's namespace.\n\nFor ex.:\n```rust\nmod x{\n pub mod y {\n  pub fn yo(){}\n }\n}\n\nfn main() {\n crate::x::y::yo(); //works\n}\n```\n* The only exception to the access modifiers are the top-level modules in a [[Crate]] Root, they can be accessed by the rest of the [[Crate]] Root's contents even if they are not public and the top-level modules are submodule to the [[Crate]] Root ``crate`` Module/the ``<crate-name>`` Module.\n \n* Even if a module is made *public*, its items must be made explicitly *public* to be accessible.\n\n* Parent modules can't access child modules and/or their contents if they are not public, but the child modules can access the sibling modules and items despite the access modifiers. Similarly, the items inside the modules can access each other if they are inside the same module without getting affected by the [[Access Modifier]]s.\nFor ex.:\n```rust\nmod x {\n    pub mod y {\n        pub fn ayo() {\n            super::yo();\n        }\n    }\n    fn yo() {}\n\n    mod z {\n        pub fn a() {}\n    }\n\n    mod k {\n        pub fn b() {\n            crate::x::z::a();\n        }\n    }\n\n    pub mod m {\n        pub fn c() {\n            crate::x::k::b();\n        }\n    }\n}\n\nfn main() {\n    crate::x::y::ayo();\n    crate::x::m::c();\n  \t//works\n  \t//but crate::x::z::a(); won't work \n} \n\n```",536891870]],["^15",[606,"^O","^16",536891133]],["^15",[606,"^@",false,536891133]],["^15",[606,"^F",583,536891133]],["^15",[606,"^X",583,536891133]],["^15",[606,"^V",583,536891133]],["^15",[606,"^U",130,536891174]],["^15",[606,"^U",242,536891174]],["^15",[606,"^U",530,536891174]],["^15",[606,"^U",577,536891174]],["^15",[606,"^U",583,536891174]],["^15",[606,"^?",["^ "],536891870]],["^15",[606,"^H",130,536891870]],["^15",[606,"^H",242,536891870]],["^15",[606,"^H",530,536891870]],["^15",[606,"^H",577,536891870]],["^15",[606,"^H",583,536891870]],["^15",[606,"^17",true,536891133]],["^15",[606,"^;","~u64b308a6-346c-4aaf-a58e-63125926a611",536891133]],["^15",[607,"^3","- [[Module]]s theirselves, and items within them are *private* by default, which in Rust means, that parent modules can't access these modules or their items. We use the ``pub`` keyword to turn them to *public* and hence allow external modules to access them.\n  This isn't just true for modules, but all items, [[Struct]]s/ [[Function]]s etc. either outside a [[Module]] or inside, in a [[Crate]]. Items in the open in a crate, are available directly from the crate's namespace.\n  \n  For ex.:\n  ```rust\n  mod x{\n   pub mod y {\n    pub fn yo(){}\n   }\n  }\n  \n  fn main() {\n   crate::x::y::yo(); //works\n  }\n  ```\n  * The only exception to the access modifiers are the top-level modules in a [[Crate]] Root, they can be accessed by the rest of the [[Crate]] Root's contents even if they are not public and the top-level modules are submodule to the [[Crate]] Root ``crate`` Module/the ``<crate-name>`` Module.\n   \n  * Even if a module is made *public*, its items must be made explicitly *public* to be accessible.\n  \n  * Parent modules can't access child modules and/or their contents if they are not public, but the child modules can access the sibling modules and items despite the access modifiers. Similarly, the items inside the modules can access each other if they are inside the same module without getting affected by the [[Access Modifier]]s.\n  For ex.:\n  ```rust\n  mod x {\n      pub mod y {\n          pub fn ayo() {\n              super::yo();\n          }\n      }\n      fn yo() {}\n  \n      mod z {\n          pub fn a() {}\n      }\n  \n      mod k {\n          pub fn b() {\n              crate::x::z::a();\n          }\n      }\n  \n      pub mod m {\n          pub fn c() {\n              crate::x::k::b();\n          }\n      }\n  }\n  \n  fn main() {\n      crate::x::y::ayo();\n      crate::x::m::c();\n    \t//works\n    \t//but crate::x::z::a(); won't work \n  } \n  \n  ```\n- All the items just need a ``pub`` before their definition to be made public.\n  \n  * [[Struct]] fields and [[Method]]s are private unless explicitly made public with pub. \n  For ex.:\n  ```rust\n  struct X {\n   pub Y:i32,\n  }\n  ```\n  \n  * For [[Enum]]s , we just need to make the enum definition ``pub <enum-name>`` to make all its fields and [[Method]]s public.\n-",536892003]],["^15",[607,"^18","~m1689508230740",536892002]],["^15",[607,"^Z","pages/Access Modifier.md",536891144]],["^15",[608,"^Q","",536891511]],["^15",[608,"^O","^16",536891511]],["^15",[608,"^@",false,536891511]],["^15",[608,"^F",602,536891511]],["^15",[608,"^X",577,536891511]],["^15",[608,"^V",577,536891511]],["^15",[608,"^U",577,536891512]],["^15",[608,"^?",["^ "],536891511]],["^15",[608,"^17",true,536891511]],["^15",[608,"^;","~u64b30b30-1866-4c3b-896f-72814d7b08d5",536891511]],["^15",[609,"^12",2,536891519]],["^15",[611,"^Q","All the items just need a ``pub`` before their definition to be made public.\n\n* [[Struct]] fields and [[Method]]s are private unless explicitly made public with pub. \nFor ex.:\n```rust\nstruct X {\n pub Y:i32,\n}\n```\n\n* For [[Enum]]s , we just need to make the enum definition ``pub <enum-name>`` to make all its fields and [[Method]]s public.",536891997]],["^15",[611,"^O","^16",536891873]],["^15",[611,"^@",false,536891873]],["^15",[611,"^F",606,536891873]],["^15",[611,"^X",583,536891873]],["^15",[611,"^V",583,536891873]],["^15",[611,"^U",242,536891961]],["^15",[611,"^U",497,536891961]],["^15",[611,"^U",511,536891961]],["^15",[611,"^U",583,536891961]],["^15",[611,"^?",["^ "],536891997]],["^15",[611,"^H",242,536891997]],["^15",[611,"^H",497,536891997]],["^15",[611,"^H",511,536891997]],["^15",[611,"^17",true,536891873]],["^15",[611,"^;","~u64b3d909-db29-4d99-8186-7d1e2d33a764",536891873]],["^15",[612,"^Q","",536892000]],["^15",[612,"^O","^16",536892000]],["^15",[612,"^@",false,536892000]],["^15",[612,"^F",611,536892000]],["^15",[612,"^X",583,536892000]],["^15",[612,"^V",583,536892000]],["^15",[612,"^U",583,536892001]],["^15",[612,"^?",["^ "],536892000]],["^15",[612,"^17",true,536892000]],["^15",[612,"^;","~u64b3d986-9d57-4014-becc-7b71c13da447",536892000]],["^15",[613,"^12",2,536892274]],["^15",[614,"^12",2,536892278]],["^15",[615,"^Q","It's idiomatic in Rust to use ``use`` to only open up till the [[Module]]s and not the specific items, as it allows identifying if the item is in the current module or is present in some external module for maintainers. \nBut items in the [[Standard Library]] library, it is idiomatic to specify the full path to an item.",536892610]],["^15",[615,"^O","^16",536892505]],["^15",[615,"^@",false,536892505]],["^15",[615,"^F",91,536892505]],["^15",[615,"^X",90,536892505]],["^15",[615,"^V",90,536892505]],["^15",[615,"^U",90,536892592]],["^15",[615,"^U",93,536892592]],["^15",[615,"^U",530,536892592]],["^15",[615,"^?",["^ "],536892610]],["^15",[615,"^H",93,536892610]],["^15",[615,"^H",530,536892610]],["^15",[615,"^17",true,536892505]],["^15",[615,"^;","~u64b3de8c-ec44-4432-8fea-8aa0b0eacd06",536892505]],["^15",[616,"^Q","~``use`` does not import anything. It simply opens a namespace. \nThe actual import is only made when a [[Module]] is defined at the top of a file.\n\n* When we define external packages to the [[cargo.toml]], and compile with [[Cargo]], the external crates are already imported in the [[Prelude]]. So we can directly use ``use`` without defining the [[Module]]s.\nFor ex.:\nFor a cargo.toml\n```toml\n...\n[dependencies]\nrand = \"0.9.0\"\n```\n\nWe can use a ``main.rs`` like so\n```rust\nuse std::io;\nuse rand::Rng; //works\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n}\n```",536893427]],["^15",[616,"^O","^16",536892610]],["^15",[616,"^@",false,536892610]],["^15",[616,"^F",615,536892610]],["^15",[616,"^X",90,536892610]],["^15",[616,"^V",90,536892610]],["^15",[616,"^U",43,536893316]],["^15",[616,"^U",45,536893316]],["^15",[616,"^U",90,536893316]],["^15",[616,"^U",525,536893316]],["^15",[616,"^U",530,536893316]],["^15",[616,"^?",["^ "],536893427]],["^15",[616,"^H",43,536893427]],["^15",[616,"^H",45,536893427]],["^15",[616,"^H",525,536893427]],["^15",[616,"^H",530,536893427]],["^15",[616,"^17",true,536892610]],["^15",[616,"^;","~u64b3e06c-3909-47c5-9b86-ab9497a3d507",536892610]],["^15",[617,"^Q","~``as``\nWe can give an alias to the item brought to the current namespace by this keyword.\n\nFor ex.:\n```rust\nuse x::y::z as K;\n\n//and use K wherever z would have been used.\n```",536892790]],["^15",[617,"^O","^16",536892658]],["^15",[617,"^@",false,536892658]],["^15",[617,"^F",616,536892658]],["^15",[617,"^X",90,536892658]],["^15",[617,"^V",90,536892658]],["^15",[617,"^U",90,536892659]],["^15",[617,"^?",["^ "],536892790]],["^15",[617,"^17",true,536892658]],["^15",[617,"^;","~u64b3e0b7-9799-4784-a6e6-4578731c76b1",536892658]],["^15",[618,"^Q","Re-exporting\nThe ``pub`` [[Access Modifier]] can also be applied to ``use``.\n\nBy default, when ``use`` is used in a [[Scope]] it works as if it only opens the namespace to an item as *private*. But by using ``pub`` to ``use`` we make the item *public*.\nThis effectively allows external [[Crate]]s/ [[Module]]s to also have a direct path to an item as if the item was in this scope. \nFor ex.:\n```rust \nmod x {\n  pub mod y {}\n}\n\nuse crate::x::y; \n//makes y available here, it is like we defined y here \n// mod y { }\n\nmod n {\n pub mod k {\n\n  }\n}\n\npub use crate::n::k;\n// however this is like we defined pub k here and not just k\n// pub mod k {}\n```\n\nA better example:\n```rust\npub mod modA {\n    pub fn fnA() {}\n}\npub mod modB {\n    pub use crate::modA;\n \n    pub fn fnB() {\n        modA::fnA();\n    }\n}\n \nmod modC {\n    use crate::modB;\n    pub fn fnC() {\n        modB::modA::fnA(); //works, as if modA is defined inside modB. It won't work if we hadn't used pub in pub use crate::modA;\n    }\n}\n\n```",536893249]],["^15",[618,"^O","^16",536892793]],["^15",[618,"^@",false,536892793]],["^15",[618,"^F",617,536892793]],["^15",[618,"^X",90,536892793]],["^15",[618,"^V",90,536892793]],["^15",[618,"^U",89,536893140]],["^15",[618,"^U",90,536893140]],["^15",[618,"^U",530,536893140]],["^15",[618,"^U",577,536893140]],["^15",[618,"^U",583,536893140]],["^15",[618,"^?",["^ "],536893249]],["^15",[618,"^H",89,536893249]],["^15",[618,"^H",530,536893249]],["^15",[618,"^H",577,536893249]],["^15",[618,"^H",583,536893249]],["^15",[618,"^17",true,536892793]],["^15",[618,"^;","~u64b3e1aa-feec-44b9-8bc1-e295714955b3",536892793]],["^15",[619,"^Q","Glob [[Operator]]\nUsed to open all items in an item.\n```rust\nuse crate::x::*;\n\n//opens all the public items in x in scope. Generally used in testing as in production projects this pollutes the scope.\n\n```",536893546]],["^15",[619,"^O","^16",536893173]],["^15",[619,"^@",false,536893173]],["^15",[619,"^F",620,536893430]],["^15",[619,"^X",90,536893173]],["^15",[619,"^V",90,536893173]],["^15",[619,"^U",90,536893519]],["^15",[619,"^U",206,536893519]],["^15",[619,"^?",["^ "],536893546]],["^15",[619,"^H",206,536893546]],["^15",[619,"^17",true,536893173]],["^15",[619,"^;","~u64b3e2ec-bb8c-433b-a638-29edd361ed6a",536893173]],["^15",[620,"^Q","Nested Paths\nUsing ‘use’ for each item in an item can be tedious, so we can use a single ‘use’ to open multiple items. \nFor ex.:\n```rust\nuse crate::x::{y, z, m::n}; //opens y, z and n from m\n\n//We can also nest the base path if we wish to open it too,\n//use crate::x::{self, m::n}; opens crate::x; and crate::m::n;\n\n```",536893503]],["^15",[620,"^O","^16",536893252]],["^15",[620,"^@",false,536893252]],["^15",[620,"^F",618,536893252]],["^15",[620,"^X",90,536893252]],["^15",[620,"^V",90,536893252]],["^15",[620,"^U",90,536893253]],["^15",[620,"^?",["^ "],536893503]],["^15",[620,"^17",true,536893252]],["^15",[620,"^;","~u64b3e34b-cecb-4e8c-a9ce-d6fce23d3066",536893252]],["^15",[621,"^U",90,536893431]],["^15",[622,"^U",90,536893431]],["^15",[623,"^U",90,536893431]],["^15",[624,"^U",90,536893431]],["^15",[625,"^U",90,536893431]],["^15",[626,"^U",90,536893431]],["^15",[627,"^U",90,536893431]],["^15",[629,"^U",530,536893668]],["^15",[630,"^U",530,536893668]],["^15",[631,"^U",530,536893668]],["^15",[632,"^U",530,536893668]],["^15",[633,"^U",530,536893668]],["^15",[634,"^U",530,536893668]],["^15",[635,"^U",530,536893668]],["^15",[636,"^U",530,536893668]],["^15",[637,"^U",530,536893668]],["^15",[638,"^U",530,536893668]],["^15",[639,"^U",530,536893668]],["^15",[640,"^U",530,536893668]],["^15",[641,"^U",530,536893668]],["^15",[642,"^U",530,536893668]],["^15",[643,"^U",530,536893668]],["^15",[644,"^U",530,536893668]],["^15",[645,"^U",530,536893668]],["^15",[646,"^U",530,536893668]],["^15",[647,"^U",530,536893668]],["^15",[648,"^U",530,536893668]],["^15",[649,"^U",530,536893668]],["^15",[650,"^U",530,536893668]],["^15",[651,"^U",530,536893668]],["^15",[652,"^U",530,536893668]],["^15",[653,"^U",530,536893668]],["^15",[654,"^U",530,536893668]],["^15",[655,"^U",530,536893668]],["^15",[656,"^U",530,536893668]],["^15",[657,"^U",530,536893668]],["^15",[658,"^U",530,536893668]],["^15",[659,"^U",530,536893668]],["^15",[660,"^U",530,536893668]],["^15",[661,"^Q","",536893925]],["^15",[661,"^O","^16",536893925]],["^15",[661,"^@",false,536893925]],["^15",[661,"^F",600,536893925]],["^15",[661,"^X",530,536893925]],["^15",[661,"^V",530,536893925]],["^15",[661,"^U",530,536893926]],["^15",[661,"^?",["^ "],536893925]],["^15",[661,"^17",true,536893925]],["^15",[661,"^;","~u64b3e822-a65b-47db-8ec1-227bb784d134",536893925]],["^15",[662,"^T","~:recent/search",536894112]],["^15",[662,"^1<",["^14",["library","cargo new --lib","Cast","Never type","Opera","turbofish","Pinn","oper","std::ops","pointer"]],536926175]],["^15",[663,"^Q","",536894402]],["^15",[663,"^O","^16",536894402]],["^15",[663,"^@",false,536894402]],["^15",[663,"^F",665,536895264]],["^15",[663,"^X",118,536894402]],["^15",[663,"^V",118,536894402]],["^15",[663,"^U",118,536894403]],["^15",[663,"^?",["^ "],536894402]],["^15",[663,"^17",true,536894402]],["^15",[663,"^;","~u64b3f796-4ea6-4a73-93ac-a80bc5848b6f",536894402]],["^15",[664,"^Q","Indexing\nInteger indices to access characters (not [[Char]]) in a string in Rust isn't valid. This is because each character is UTF-8 encoded. \nA ``String`` is a wrapper over ``Vec<u8>``, but UTF-8 requires 1 to 4 bytes (4*8 = 32 bits) per character, this variable size is by UTF-8 spec. This means it is not sure if a given index is a single character or a part of a multi-byte character and hence accessing ``String`` by index is not guaranteed to return the right character. \nFor ex.:\n```rust\nlet hello = \"Здравствуйте\";\nlet answer = &hello[0]; //is an error\n```\nThis doesn't compile in Rust as rust avoids such errors and here the error would be correct, as we are trying to get the first character, which we would expect would be the Cyrillic letter ``Ze`` and not Arabic Number ``3``, it takes 2 bytes according to UTF-8 and hence both index 0 and 1 make up the character ``Ze``. \n\nWe can use ``&hello[0..2]`` (end exclusive) and that would work as string [[Slice]]s are allowed anyway. But String [[Slice]]s are risky, if the start or end index of a string slice bisects a character, it [[Panic]]s. \n\nWe can see why [[Char]] isn't used to represent characters in ``String`` as string slice from 0 to 1 above would return a string with the right character, which has taken 2 bytes and Rust can't know if the string slice from 0 to 1 is a single character or it is a string.\n\n* There are 3 ways Rust sees characters in String. \nFor “नमस्ते”,\n\nIt’s length is 18 in bytes and this is how it looks as a byte-array,\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]\n \nRust sees chars as Unicode Scalar Values, basically like this \n['न', 'म', 'स', '्', 'त', 'े']\nThe 4th and 6th letter here are called *diacritics* as they don’t make sense on their own. \n\nLastly, here’s how we interpret these letters,\n[\"न\", \"म\", \"स्\", \"ते\"]\nThese are the *Grapheme Clusters* of the word Namaste.\nA grapheme cluster is a more accurate name of what we call a letter in English. \n\nThis is why indexing is not done in Rust. This is also why, [[Slice]] operations are risky, for ex.:\n```rust\nlet hello = String::from(\"Здравствуйте\");\n//hello[0..1]; //will cause the program to panic as the first byte is a part of 2 to make up a Unicode Scalar value, so \nhello[0..2] //works\n```",536895406]],["^15",[664,"^O","^16",536894679]],["^15",[664,"^@",false,536894679]],["^15",[664,"^F",281,536894679]],["^15",[664,"^X",118,536894679]],["^15",[664,"^V",118,536894679]],["^15",[664,"^U",118,536895405]],["^15",[664,"^U",183,536895405]],["^15",[664,"^U",219,536895405]],["^15",[664,"^U",274,536895405]],["^15",[664,"^?",["^ "],536895406]],["^15",[664,"^H",183,536895406]],["^15",[664,"^H",219,536895406]],["^15",[664,"^H",274,536895406]],["^15",[664,"^17",true,536894679]],["^15",[664,"^;","~u64b3f942-bb52-4cc9-b5b1-91e8186e3d5c",536894679]],["^15",[665,"^Q","",536895264]],["^15",[665,"^O","^16",536895264]],["^15",[665,"^@",false,536895264]],["^15",[665,"^F",667,536895434]],["^15",[665,"^X",118,536895264]],["^15",[665,"^V",118,536895264]],["^15",[665,"^U",118,536895265]],["^15",[665,"^?",["^ "],536895264]],["^15",[665,"^17",true,536895264]],["^15",[665,"^;","~u64b40022-7b20-4dbc-afb3-089d87c40bf4",536895264]],["^15",[666,"^Q","",536895449]],["^15",[666,"^O","^16",536895347]],["^15",[666,"^@",false,536895347]],["^15",[666,"^F",664,536895347]],["^15",[666,"^X",118,536895347]],["^15",[666,"^V",118,536895347]],["^15",[666,"^U",118,536895348]],["^15",[666,"^?",["^ "],536895449]],["^15",[666,"^17",true,536895347]],["^15",[666,"^;","~u64b4037a-63bc-4f7b-bbbe-e089bbb203a9",536895347]],["^15",[667,"^Q","Raw string\nGet a string as defined, we use ``\"\\ <string, can be multiple lines> \";``\n\nFor ex.:\n```rust\nlet contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nDuct tape.\";\n\n```\nor use ``r#\" <string> \"#``\nFor ex.:\n```rust\nlet abc= r#\"my string\"#;\n```",536926309]],["^15",[667,"^O","^16",536895432]],["^15",[667,"^@",false,536895432]],["^15",[667,"^F",666,536895432]],["^15",[667,"^X",118,536895432]],["^15",[667,"^V",118,536895432]],["^15",[667,"^U",118,536926277]],["^15",[667,"^?",["^ "],536926309]],["^15",[667,"^17",true,536895432]],["^15",[667,"^;","~u64b40431-e8ce-42bb-9799-912b930c409f",536895432]],["^15",[668,"^U",118,536895435]],["^15",[669,"^U",118,536895435]],["^15",[670,"^U",118,536895435]],["^15",[671,"^U",118,536895435]],["^15",[672,"^U",118,536895435]],["^15",[673,"^U",118,536895435]],["^15",[674,"^U",118,536895435]],["^15",[675,"^U",118,536895435]],["^15",[676,"^Q","[[HashMap]]",536895480]],["^15",[676,"^O","^16",536895476]],["^15",[676,"^@",false,536895476]],["^15",[676,"^F",265,536895476]],["^15",[676,"^X",231,536895476]],["^15",[676,"^V",231,536895476]],["^15",[676,"^U",231,536895481]],["^15",[676,"^U",677,536895481]],["^15",[676,"^?",["^ "],536895480]],["^15",[676,"^H",677,536895480]],["^15",[676,"^17",true,536895476]],["^15",[676,"^;","~u64b404c4-80ad-4377-afca-44c1639b402f",536895476]],["^15",[677,"^K",1689519304403,536895480]],["^15",[677,"^[",679,536895489]],["^15",[677,"^O","^16",536895484]],["^15",[677,"^@",false,536895480]],["^15",[677,"^Y","hashmap",536895480]],["^15",[677,"^11","HashMap",536895480]],["^15",[677,"^B",1689520761982,536896256]],["^15",[677,"^;","~u64b404c8-a2f5-4ad1-a647-1cae898ecca1",536895480]],["^15",[678,"^Q","~``HashMap<K,V>``\nDefined in the [[Standard Library]], this [[Struct]] provides an implementation of a hashmap, or hashtable etc. from other languages where the Key is *hashed* and stored and the value is also stored with it. The benefit of this [[Data Structure]] is efficient search of the key.\n\nFor ex.:\n```rust\n  use std::collections::HashMap;\n\nfn main() {\n     let mut scores = HashMap::new();\n    scores.insert(String::from(\"Blue\"), 10);\n   let team_name= String::from(\"Blue\");\n    let score = scores.get(&team_name).copied().unwrap_or(0);\n}\n```\n\nHere ``.copied()`` is a [[Method]] on the [[Option Type]] which takes ``Option<&V>`` and returns an ``Option<V>`` by [[Copy or Move]]ing its value and finally [[Unwrap]] unwraps the ``Option`` and returns a 0 if it is ``None``.",536895753]],["^15",[678,"^O","^16",536895485]],["^15",[678,"^@",false,536895485]],["^15",[678,"^F",677,536895485]],["^15",[678,"^X",677,536895485]],["^15",[678,"^V",677,536895485]],["^15",[678,"^U",93,536895729]],["^15",[678,"^U",228,536895729]],["^15",[678,"^U",242,536895729]],["^15",[678,"^U",256,536895729]],["^15",[678,"^U",497,536895729]],["^15",[678,"^U",677,536895729]],["^15",[678,"^U",680,536895729]],["^15",[678,"^U",681,536895729]],["^15",[678,"^?",["^ "],536895753]],["^15",[678,"^H",93,536895753]],["^15",[678,"^H",228,536895753]],["^15",[678,"^H",242,536895753]],["^15",[678,"^H",256,536895753]],["^15",[678,"^H",497,536895753]],["^15",[678,"^H",680,536895753]],["^15",[678,"^H",681,536895753]],["^15",[678,"^17",true,536895485]],["^15",[678,"^;","~u64b404ca-40e6-4e32-bfe2-a5d6ca1d1e18",536895485]],["^15",[679,"^3","- ``HashMap<K,V>``\n  Defined in the [[Standard Library]], this [[Struct]] provides an implementation of a hashmap, or hashtable etc. from other languages where the Key is *hashed* and stored and the value is also stored with it. The benefit of this [[Data Structure]] is efficient search of the key.\n  \n  For ex.:\n  ```rust\n    use std::collections::HashMap;\n  \n  fn main() {\n       let mut scores = HashMap::new();\n      scores.insert(String::from(\"Blue\"), 10);\n     let team_name= String::from(\"Blue\");\n      let score = scores.get(&team_name).copied().unwrap_or(0);\n  }\n  ```\n  \n  Here ``.copied()`` is a [[Method]] on the [[Option Type]] which takes ``Option<&V>`` and returns an ``Option<V>`` by [[Copy or Move]]ing its value and finally [[Unwrap]] unwraps the ``Option`` and returns a 0 if it is ``None``.\n- Getting/Setting values in the HashMap follows the [[Ownership]] rules, this is why it is recommended to use [[Reference Type]]s.\n- Inserting\n  If a key exists then its value is overwritten. If  we want to check before inserting we can use the ``.entry`` method,\n  For ex.:\n      ```rust\n  let mut scores = HashMap::new();\n  scores.insert(String::from(\"Blue\"), 10);\n   let insertedValue= scores.entry(String::from(\"Yellow\")).or_insert(50);\n  \n  ```\n  Here ``.entry()`` returns an [[Enum]] ``Entry`` which defines if the key exists or not. The Entry enum also defines a few [[Method]]s and one of them is ``.or_insert(<V>)``, which inserts the key and the value if the key doesn’t exist otherwise does nothing. Either way, ``.or_insert`` returns a mutable [[Reference Type]] of the value to the key.\n- Some other methods\n  For ex.:\n  ```rust\n  use std::collections::HashMap;\n   \n  let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\n  let initial_scores = vec![10, 50];\n   \n  let mut scores: HashMap<_, _> =\n  teams.into_iter().zip(initial_scores.into_iter()).collect();\n  ```\n  ``.zip`` takes 2 [[Iterator]]s and pairs each value at the same index of them into a [[Tuple]] and ``.collect`` collects the tuples and then returns a required type which is HashMap here. Since collect needs a type to know what to return to, and HashMap needs types to define K and V, Rust allows us to use ``_`` the Placeholder type [[Operator]] for the [[Generic Type]]s. Then it infers the correct types.\n-",536898409]],["^15",[679,"^18","~m1689607701440",536898416]],["^15",[679,"^Z","pages/HashMap.md",536895489]],["^15",[680,"^K",1689519491664,536895581]],["^15",[680,"^@",false,536895581]],["^15",[680,"^Y","data structure",536895581]],["^15",[680,"^11","Data Structure",536895581]],["^15",[680,"^B",1689519491664,536895581]],["^15",[680,"^;","~u64b40583-c1d2-49c2-a017-79677b8cb801",536895581]],["^15",[681,"^K",1689519720944,536895728]],["^15",[681,"^[",683,536895761]],["^15",[681,"^O","^16",536895756]],["^15",[681,"^@",false,536895728]],["^15",[681,"^Y","unwrap",536895728]],["^15",[681,"^11","Unwrap",536895728]],["^15",[681,"^B",1689557702961,536897440]],["^15",[681,"^;","~u64bbdc0c-5abf-43bc-99ba-4b8f44cae5e7",536908100]],["^15",[682,"^Q","~``<T obj>.unwrap()`` or ``<Tobj>.unwrap_or(<V>)``\nWorks when T is [[Option Type]] or [[Result Type]].\nThere are other ``unwrap`` [[Method]]s too.",536897309]],["^15",[682,"^O","^16",536895757]],["^15",[682,"^@",false,536895757]],["^15",[682,"^F",681,536895757]],["^15",[682,"^X",681,536895757]],["^15",[682,"^V",681,536895757]],["^15",[682,"^U",228,536897310]],["^15",[682,"^U",497,536897310]],["^15",[682,"^U",681,536897310]],["^15",[682,"^U",687,536897310]],["^15",[682,"^?",["^ "],536897309]],["^15",[682,"^H",228,536897309]],["^15",[682,"^H",497,536897309]],["^15",[682,"^H",687,536897309]],["^15",[682,"^17",true,536895757]],["^15",[682,"^;","~u64b40686-737f-4edd-9791-dbcaa0bd40cd",536895757]],["^15",[683,"^3","- ``<T obj>.unwrap()`` or ``<Tobj>.unwrap_or(<V>)``\n  Works when T is [[Option Type]] or [[Result Type]].\n  There are other ``unwrap`` [[Method]]s too.\n- ``.unwrap()``\n  if the value is an ``Ok``/``Some`` it doesn't do anything. If it is ``Err``/``None`` then it [[Panic]]s.\n- ``.unwrap_or(<V value>)``\n  if the value is an ``Ok``/Some it doesn't do anything. If it is ``Err``/``Some`` then it returns the given value.\n- ``.unwrap_or_else(<closure>)`` \n  Takes a [[Closure]], runs it and returns its value if ``Err``/``None``.",536897442]],["^15",[683,"^18","~m1689557703500",536897441]],["^15",[683,"^Z","pages/Unwrap.md",536895761]],["^15",[684,"^Q","Getting/Setting values in the HashMap follows the [[Ownership]] rules, this is why it is recommended to use [[Reference Type]]s.",536895864]],["^15",[684,"^O","^16",536895849]],["^15",[684,"^@",false,536895849]],["^15",[684,"^F",678,536895849]],["^15",[684,"^X",677,536895849]],["^15",[684,"^V",677,536895849]],["^15",[684,"^U",253,536895861]],["^15",[684,"^U",255,536895861]],["^15",[684,"^U",677,536895861]],["^15",[684,"^?",["^ "],536895864]],["^15",[684,"^H",253,536895864]],["^15",[684,"^H",255,536895864]],["^15",[684,"^17",true,536895849]],["^15",[684,"^;","~u64b406fd-2b3c-4592-a55d-e8b8f5e20b06",536895849]],["^15",[685,"^Q","Inserting\nIf a key exists then its value is overwritten. If  we want to check before inserting we can use the ``.entry`` method,\nFor ex.:\n    ```rust\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\n let insertedValue= scores.entry(String::from(\"Yellow\")).or_insert(50);\n\n```\nHere ``.entry()`` returns an [[Enum]] ``Entry`` which defines if the key exists or not. The Entry enum also defines a few [[Method]]s and one of them is ``.or_insert(<V>)``, which inserts the key and the value if the key doesn’t exist otherwise does nothing. Either way, ``.or_insert`` returns a mutable [[Reference Type]] of the value to the key.",536895953]],["^15",[685,"^O","^16",536895868]],["^15",[685,"^@",false,536895868]],["^15",[685,"^F",684,536895868]],["^15",[685,"^X",677,536895868]],["^15",[685,"^V",677,536895868]],["^15",[685,"^U",253,536895950]],["^15",[685,"^U",497,536895950]],["^15",[685,"^U",511,536895950]],["^15",[685,"^U",677,536895950]],["^15",[685,"^?",["^ "],536895953]],["^15",[685,"^H",253,536895953]],["^15",[685,"^H",497,536895953]],["^15",[685,"^H",511,536895953]],["^15",[685,"^17",true,536895868]],["^15",[685,"^;","~u64b4073d-c8d2-4d5d-bf73-975ff9b65d3d",536895868]],["^15",[686,"^Q","Some other methods\nFor ex.:\n```rust\nuse std::collections::HashMap;\n \nlet teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\nlet initial_scores = vec![10, 50];\n \nlet mut scores: HashMap<_, _> =\nteams.into_iter().zip(initial_scores.into_iter()).collect();\n```\n``.zip`` takes 2 [[Iterator]]s and pairs each value at the same index of them into a [[Tuple]] and ``.collect`` collects the tuples and then returns a required type which is HashMap here. Since collect needs a type to know what to return to, and HashMap needs types to define K and V, Rust allows us to use ``_`` the Placeholder type [[Operator]] for the [[Generic Type]]s. Then it infers the correct types.",536898404]],["^15",[686,"^O","^16",536895956]],["^15",[686,"^@",false,536895956]],["^15",[686,"^F",685,536895956]],["^15",[686,"^X",677,536895956]],["^15",[686,"^V",677,536895956]],["^15",[686,"^U",131,536896244]],["^15",[686,"^U",194,536896244]],["^15",[686,"^U",206,536896244]],["^15",[686,"^U",677,536896244]],["^15",[686,"^U",692,536896244]],["^15",[686,"^?",["^ "],536896256]],["^15",[686,"^H",131,536896256]],["^15",[686,"^H",194,536896256]],["^15",[686,"^H",206,536896256]],["^15",[686,"^H",692,536896256]],["^15",[686,"^17",true,536895956]],["^15",[686,"^;","~u64b4081e-5585-46d8-8f56-92e86ecc456a",536895956]],["^15",[687,"^K",1689520240658,536895963]],["^15",[687,"^[",698,536896470]],["^15",[687,"^O","^16",536896465]],["^15",[687,"^@",false,536895963]],["^15",[687,"^Y","result type",536895963]],["^15",[687,"^11","Result Type",536895963]],["^15",[687,"^B",1689557897101,536897546]],["^15",[687,"^;","~u64bbdc0c-3426-4fec-8a55-f830df387753",536908120]],["^15",[688,"^U",681,536896080]],["^15",[689,"^U",681,536896088]],["^15",[691,"^Q","",536896135]],["^15",[691,"^O","^16",536896135]],["^15",[691,"^@",false,536896135]],["^15",[691,"^F",686,536896135]],["^15",[691,"^X",677,536896135]],["^15",[691,"^V",677,536896135]],["^15",[691,"^U",677,536896136]],["^15",[691,"^?",["^ "],536896135]],["^15",[691,"^17",true,536896135]],["^15",[691,"^;","~u64b409a0-bffe-4898-a690-683008f2ad2a",536896135]],["^15",[692,"^K",1689520609030,536896187]],["^15",[692,"^[",893,536908104]],["^15",[692,"^@",false,536896187]],["^15",[692,"^Y","iterator",536896187]],["^15",[692,"^11","Iterator",536896187]],["^15",[692,"^B",1689520609030,536896187]],["^15",[692,"^;","~u64c20233-d012-42e9-b205-9d40d3a38580",536916343]],["^15",[693,"^12",2,536896260]],["^15",[696,"^3","- Rust divides errors into 2 categories, *Recoverable* and *Non-Recoverable* Errors. \n  Simple errors like File not Found can be handled as their failing is expected so they are recoverable errors and are represented with the [[Result Type]], but errors such as accessing an invalid index in an [[Array]] is not expected so it is a type of non-recoverable error, these are triggered through the ``panic!`` [[Macro]].\n- [[Panic]]\n- The [[Result Type]] gets an Error [[Struct]] object when error .\n- Different error types in Rust are represented through a different variant of the ``ErrorKind`` [[Enum]]\n  So we can use ``<error obj>.kind()`` to get the kind and compare it.\n  \n  For ex.:\n  ```rust\n  use std::fs::File;\n  use std::io::ErrorKind;\n   \n  fn main() {\n      let f = File::open(\"hello.txt\");\n   \n      let f = match f {\n          Ok(file) => file,\n          Err(error) => match error.kind() {\n              ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                  Ok(fc) => fc,\n                  Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n              },\n              other_error => {\n                  panic!(\"Problem opening the file: {:?}\", other_error)\n              }\n          },\n      };\n  }\n  \n  ```\n  \n  We can also use [[Closure]]s and [[Unwrap]] to do the same\n  For ex.:\n  ```rust\n  use std::fs::File;\n  use std::io::ErrorKind;\n   \n  fn main() {\n      let f = File::open(\"hello.txt\").unwrap_or_else(|error| {\n          if error.kind() == ErrorKind::NotFound {\n              File::create(\"hello.txt\").unwrap_or_else(|error| {\n                  panic!(\"Problem creating the file: {:?}\", error);\n              })\n          } else {\n              panic!(\"Problem opening the file: {:?}\", error);\n          }\n      });\n  }\n  ```\n  \n  However, the error's type itself will be different. Like ``io::Error`` is a [[Struct]] that contains all the ``io`` errors.\n- Turning Result to panic\n  Using [[Unwrap]] we can get just the value into a variable, as on ``unwrap`` it will panic/return some custom value.\n- ``.expect(\"<string>\")``\n  [[Result Type]] also has this [[Method]] which prints the given message and aborts if ``Err``.\n- Propagating Errors\n  We can use [[Pattern Matching]] on a [[Result Type]] and return a [[Result Type]] again, this essentially *re-throws* or propagates the error back. \n  The ``?`` [[Operator]] is a shorthand for Returning an ``Err``, i.e., it returns an ``Err`` if Err is found and [[Copy or Move]]s the error object. If there's no Err then it does nothing.\n  \n  For ex.:\n  ```rust\n  fn yo()  -> Result<io::File, io::Error>{\n  \t let x =  File::open(\"hello.txt\");\n  return match x{\n          Ok(s) => Ok(s),\n          Err(e) => Err(e),\n      }\n   \n  }\n  //is the same as\n  fn yo2() -> Result<io::File, io::Error>{\n  let x = File::open(\"hello.txt\")?; //Returns an Ok into x, if there's an Err it returns the Err with its value immediately from the function\n  \n  Ok(x) //returns an Ok(x) \n  }\n  ```\n  \n  * ``?`` vs. [[Pattern Matching]]\n  A difference between these 2 is, ``?`` tries to coerce one error type into another. It does so by seeing what the expected return type of the current [[Function]]'s Result is then seeing if the error object has that type or its type has the ``From``[[Trait]] defined which converts the current error type into the return error type. If it is, then it calls the ``from`` [[Method]] of this [[Trait]] and does so.\n  \n  * This [[Operator]] can also be used with the [[Option Type]]\n  For ex.:\n  ```rust\n  fn last_char_of_first_line(text: &str) -> Option<char> {\n      text.lines().next()?.chars().last()\n  }\n  ```\n  If there's a ``None``, return None otherwise continue.\n- Main's return type\n  The ``fn main`` [[Function]] returns the [[Unit Type]] by default, but it can also return a [[Result Type]]. For ex.:\n  ```rust\n  use std::error::Error;\n  use std::fs::File;\n   \n  fn main() -> Result<(), Box<dyn Error>> {\n      let f = File::open(\"hello.txt\")?;\n   \n      Ok(())\n  }\n  ```\n  ``Box<dyn Error>`` is a [[Trait Object]], here it means return any type of Error object. This main [[Function]] returns a 0 to the OS if Ok() and another value otherwise, the value returned is defined by the ``ExitCode`` of the ``Termination`` [[Trait]] of the Error's type.\n-\n-",536906338]],["^15",[696,"^18","~m1689878663237",536906337]],["^15",[696,"^Z","pages/Error.md",536896271]],["^15",[697,"^Q","~``Result<T,E>`` \nAn [[Enum]] which is defined in the [[Prelude]] like so\n\n```rust\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\nIt works much like the [[Option Type]] but it is meant to be used with [[Error]]s to represent Recoverable Errors.\n\nFor ex.:\n```rust\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => panic!(\"Problem opening the file: {:?}\", error),\n    };\n}\n```",536897105]],["^15",[697,"^O","^16",536896466]],["^15",[697,"^@",false,536896466]],["^15",[697,"^F",687,536896466]],["^15",[697,"^X",687,536896466]],["^15",[697,"^V",687,536896466]],["^15",[697,"^U",129,536897080]],["^15",[697,"^U",228,536897080]],["^15",[697,"^U",511,536897080]],["^15",[697,"^U",525,536897080]],["^15",[697,"^U",687,536897080]],["^15",[697,"^?",["^ "],536897105]],["^15",[697,"^H",129,536897105]],["^15",[697,"^H",228,536897105]],["^15",[697,"^H",511,536897105]],["^15",[697,"^H",525,536897105]],["^15",[697,"^17",true,536896466]],["^15",[697,"^;","~u64b49471-9709-4465-96c5-129bbd53b1ed",536896466]],["^15",[698,"^3","- ``Result<T,E>`` \n  An [[Enum]] which is defined in the [[Prelude]] like so\n  \n  ```rust\n  enum Result<T, E> {\n      Ok(T),\n      Err(E),\n  }\n  ```\n  It works much like the [[Option Type]] but it is meant to be used with [[Error]]s to represent Recoverable Errors.\n  \n  For ex.:\n  ```rust\n  use std::fs::File;\n  \n  fn main() {\n      let greeting_file_result = File::open(\"hello.txt\");\n  \n      let greeting_file = match greeting_file_result {\n          Ok(file) => file,\n          Err(error) => panic!(\"Problem opening the file: {:?}\", error),\n      };\n  }\n  ```\n- Just like the [[Option Type]], the keyword ``Ok`` and ``Err`` are available as-is as well.\n-\n-",536897549]],["^15",[698,"^18","~m1689557897594",536897548]],["^15",[698,"^Z","pages/Result Type.md",536896470]],["^15",[699,"^Q","[[Panic]]",536896552]],["^15",[699,"^O","^16",536896489]],["^15",[699,"^@",false,536896489]],["^15",[699,"^F",333,536896489]],["^15",[699,"^X",129,536896489]],["^15",[699,"^V",129,536896489]],["^15",[699,"^U",129,536896537]],["^15",[699,"^U",219,536896537]],["^15",[699,"^?",["^ "],536896552]],["^15",[699,"^H",219,536896552]],["^15",[699,"^17",true,536896489]],["^15",[699,"^;","~u64b494cb-bb1b-43a9-bf5c-30f00fc45bd7",536896489]],["^15",[700,"^Q","Print and debug\n``print!()`` is a [[macro_rules!]] macro that prints text to stdout.\n``println!()`` is its newline ending variant. \nFor ex.:\n```rust\nprinln!(\"{} yoo {}\",2,4); \n```\nHere the given string is printed and all ``{ }`` in it indicate scalar/printable [[Data Type]]s which are provided as variable number of args to the macro.\n\n* Output Format:\nWe can specify output formats inside the ``{ }``.\n\n* Debug Printing:\nIf we use ``{:?}``  then it prints the given object in debug mode, but requires the [[Data Type]] to implement the ``Debug`` [[Trait]], this is a derivable trait.\n\nFor ex.:\n```rust\n#[derive(Debug)]\nstruct X {}\n\nfn main() {\nlet x = X{};\nprintln!(\"{:?}\", X);\n//and it will debug print it. \n\nprintln!(\"{:#?}\", x); //debug prints the instance.\n```\n\nAlternatively, we can instead use ``dbg!(<value>)``. This macro returns the [[Ownership]] of expressions so having it there or not there is the same thing to Rust.\nFor ex.:\n```rust\nlet a=dbg!(2*4); //a will be 8 and it will print 2 * 4 = 8\n```\n``dbg!`` prints to stderr.\n\n* ``eprintln!(...)``: Just like dbg!, prints stuff to stderr.",536921049]],["^15",[700,"^O","^16",536896533]],["^15",[700,"^@",false,536896533]],["^15",[700,"^F",1116,536920108]],["^15",[700,"^X",246,536896533]],["^15",[700,"^V",246,536896533]],["^15",[700,"^U",148,536921046]],["^15",[700,"^U",246,536921046]],["^15",[700,"^U",255,536921046]],["^15",[700,"^U",414,536921046]],["^15",[700,"^U",1120,536921046]],["^15",[700,"^?",["^ "],536921049]],["^15",[700,"^H",148,536921049]],["^15",[700,"^H",255,536921049]],["^15",[700,"^H",414,536921049]],["^15",[700,"^H",1120,536921049]],["^15",[700,"^17",true,536896533]],["^15",[700,"^;","~u64b4950e-470d-494c-9018-070c2ce3b31d",536896533]],["^15",[701,"^Q","~``panic!``\nThis macro immediately signals the system there has been an unrecoverable error and hence the program stops right there.\nSyntax: ``panic!(\"<string>\")``\n\nFor ex.:\n```rust\nfn main() {\n panic!(\"crash and burn\"); //panics\n} \n```",536896967]],["^15",[701,"^O","^16",536896556]],["^15",[701,"^@",false,536896556]],["^15",[701,"^F",219,536896556]],["^15",[701,"^X",219,536896556]],["^15",[701,"^V",219,536896556]],["^15",[701,"^U",219,536896557]],["^15",[701,"^?",["^ "],536896967]],["^15",[701,"^17",true,536896556]],["^15",[701,"^;","~u64b4952d-86ca-460f-b432-ac37cde13b43",536896556]],["^15",[702,"^3","- ``panic!``\n  This macro immediately signals the system there has been an unrecoverable error and hence the program stops right there.\n  Syntax: ``panic!(\"<string>\")``\n  \n  For ex.:\n  ```rust\n  fn main() {\n   panic!(\"crash and burn\"); //panics\n  } \n  ```\n- Unwinding and Aborting on Panic\n  When a program panics, the call-stack is *unwinded*, i.e. Rust's runtime requires the program to walk back its call-stack, then it has to clean up all the resources used in each [[Function]] and finally exit. This is a time-taking task and it also increases the size of the Rust binary/Executable. \n  \n  However, we can avoid it and let the OS clean-up all the resources instead, which is a less cleaner solution but allows quicker exit and smaller binary size. This is called `Aborting on Panic`.\n  We can enable it for our [[Package]] by configuring the [[cargo.toml]] like so\n  ```toml\n  [profile.release]\n  panic = 'abort'\n  ```\n  This applies AOP on the release builds.\n- Backtrace\n  It's possible that our code itself doesn't cause a panic directly, such as if we use a [[Vector]] and access an invalid index it panics in the Vector's files and not in our code. This is not shown by the normal stacktrace printed by the panic [[Macro]].\n  To see a detailed backtrace, we need the system environment over the Rust app to have the environment variable ``RUST_BACKTRACE`` set to any value other than 0. \n  Although this only works in debug builds where the debug symbols are loaded.\n-",536897066]],["^15",[702,"^18","~m1689557115351",536897065]],["^15",[702,"^Z","pages/Panic.md",536896560]],["^15",[703,"^Q","Unwinding and Aborting on Panic\nWhen a program panics, the call-stack is *unwinded*, i.e. Rust's runtime requires the program to walk back its call-stack, then it has to clean up all the resources used in each [[Function]] and finally exit. This is a time-taking task and it also increases the size of the Rust binary/Executable. \n\nHowever, we can avoid it and let the OS clean-up all the resources instead, which is a less cleaner solution but allows quicker exit and smaller binary size. This is called `Aborting on Panic`.\nWe can enable it for our [[Package]] by configuring the [[cargo.toml]] like so\n```toml\n[profile.release]\npanic = 'abort'\n```\nThis applies AOP on the release builds.",536896794]],["^15",[703,"^O","^16",536896563]],["^15",[703,"^@",false,536896563]],["^15",[703,"^F",701,536896563]],["^15",[703,"^X",219,536896563]],["^15",[703,"^V",219,536896563]],["^15",[703,"^U",43,536896766]],["^15",[703,"^U",130,536896766]],["^15",[703,"^U",219,536896766]],["^15",[703,"^U",704,536896766]],["^15",[703,"^?",["^ "],536896794]],["^15",[703,"^H",43,536896794]],["^15",[703,"^H",130,536896794]],["^15",[703,"^H",704,536896794]],["^15",[703,"^17",true,536896563]],["^15",[703,"^;","~u64b49536-293a-481f-9237-479d3a63eb85",536896563]],["^15",[704,"^K",1689556520336,536896758]],["^15",[704,"^O","^16",536896799]],["^15",[704,"^@",false,536896758]],["^15",[704,"^Y","package",536896758]],["^15",[704,"^11","Package",536896758]],["^15",[704,"^B",1689556520336,536896758]],["^15",[704,"^;","~u64bbdc0c-7719-4674-9fac-35ee37e20fee",536908111]],["^15",[705,"^Q","",536896800]],["^15",[705,"^O","^16",536896800]],["^15",[705,"^@",false,536896800]],["^15",[705,"^F",704,536896800]],["^15",[705,"^X",704,536896800]],["^15",[705,"^V",704,536896800]],["^15",[705,"^U",704,536896801]],["^15",[705,"^?",["^ "],536896800]],["^15",[705,"^17",true,536896800]],["^15",[705,"^;","~u64b4965b-3a7c-41fe-8660-6d02d84e0359",536896800]],["^15",[706,"^Q","A [[Package]] and a Crate are 2 different things\nWhilst a Package contains all the crates in a project, a crate is simply a single ``.rs`` file and it may have [[Module]]s, which can then be their own ``.rs`` files. \nSo a Package is a collection of crates, and a crate is a collection of modules.",536896924]],["^15",[706,"^O","^16",536896866]],["^15",[706,"^@",false,536896866]],["^15",[706,"^F",580,536896866]],["^15",[706,"^X",577,536896866]],["^15",[706,"^V",577,536896866]],["^15",[706,"^U",530,536896902]],["^15",[706,"^U",577,536896902]],["^15",[706,"^U",704,536896902]],["^15",[706,"^?",["^ "],536896924]],["^15",[706,"^H",530,536896924]],["^15",[706,"^H",704,536896924]],["^15",[706,"^17",true,536896866]],["^15",[706,"^;","~u64b4971a-3e65-455f-a5d0-98f8051336a3",536896866]],["^15",[707,"^Q","Backtrace\nIt's possible that our code itself doesn't cause a panic directly, such as if we use a [[Vector]] and access an invalid index it panics in the Vector's files and not in our code. This is not shown by the normal stacktrace printed by the panic [[Macro]].\nTo see a detailed backtrace, we need the system environment over the Rust app to have the environment variable ``RUST_BACKTRACE`` set to any value other than 0. \nAlthough this only works in debug builds where the debug symbols are loaded.",536897064]],["^15",[707,"^O","^16",536896970]],["^15",[707,"^@",false,536896970]],["^15",[707,"^F",703,536896970]],["^15",[707,"^X",219,536896970]],["^15",[707,"^V",219,536896970]],["^15",[707,"^U",219,536897015]],["^15",[707,"^U",238,536897015]],["^15",[707,"^U",246,536897015]],["^15",[707,"^?",["^ "],536897064]],["^15",[707,"^H",238,536897064]],["^15",[707,"^H",246,536897064]],["^15",[707,"^17",true,536896970]],["^15",[707,"^;","~u64b497ed-21f0-4519-8ea6-22bd098637d9",536896970]],["^15",[708,"^Q","",536897060]],["^15",[708,"^O","^16",536897060]],["^15",[708,"^@",false,536897060]],["^15",[708,"^F",707,536897060]],["^15",[708,"^X",219,536897060]],["^15",[708,"^V",219,536897060]],["^15",[708,"^U",219,536897061]],["^15",[708,"^?",["^ "],536897060]],["^15",[708,"^17",true,536897060]],["^15",[708,"^;","~u64b49860-3094-4a81-a80c-fde516a44e1d",536897060]],["^15",[709,"^Q","",536897095]],["^15",[709,"^O","^16",536897095]],["^15",[709,"^@",false,536897095]],["^15",[709,"^F",721,536897546]],["^15",[709,"^X",687,536897095]],["^15",[709,"^V",687,536897095]],["^15",[709,"^U",687,536897096]],["^15",[709,"^?",["^ "],536897095]],["^15",[709,"^17",true,536897095]],["^15",[709,"^;","~u64b498b7-76cd-4031-9c6e-683c4a2c8322",536897095]],["^15",[710,"^Q","Just like the [[Option Type]], the keyword ``Ok`` and ``Err`` are available as-is as well.",536897546]],["^15",[710,"^O","^16",536897108]],["^15",[710,"^@",false,536897108]],["^15",[710,"^F",697,536897108]],["^15",[710,"^X",687,536897108]],["^15",[710,"^V",687,536897108]],["^15",[710,"^U",228,536897525]],["^15",[710,"^U",687,536897525]],["^15",[710,"^?",["^ "],536897546]],["^15",[710,"^H",228,536897546]],["^15",[710,"^17",true,536897108]],["^15",[710,"^;","~u64b498ee-ec81-44bc-a570-584414a67158",536897108]],["^15",[711,"^Q","Different error types in Rust are represented through a different variant of the ``ErrorKind`` [[Enum]]\nSo we can use ``<error obj>.kind()`` to get the kind and compare it.\n\nFor ex.:\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n \nfn main() {\n    let f = File::open(\"hello.txt\");\n \n    let f = match f {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error => {\n                panic!(\"Problem opening the file: {:?}\", other_error)\n            }\n        },\n    };\n}\n\n```\n\nWe can also use [[Closure]]s and [[Unwrap]] to do the same\nFor ex.:\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n \nfn main() {\n    let f = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problem creating the file: {:?}\", error);\n            })\n        } else {\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    });\n}\n```\n\nHowever, the error's type itself will be different. Like ``io::Error`` is a [[Struct]] that contains all the ``io`` errors.",536897674]],["^15",[711,"^O","^16",536897123]],["^15",[711,"^@",false,536897123]],["^15",[711,"^F",712,536897158]],["^15",[711,"^X",129,536897123]],["^15",[711,"^V",129,536897123]],["^15",[711,"^U",129,536897668]],["^15",[711,"^U",242,536897668]],["^15",[711,"^U",511,536897668]],["^15",[711,"^U",681,536897668]],["^15",[711,"^U",714,536897668]],["^15",[711,"^?",["^ "],536897674]],["^15",[711,"^H",242,536897674]],["^15",[711,"^H",511,536897674]],["^15",[711,"^H",681,536897674]],["^15",[711,"^H",714,536897674]],["^15",[711,"^17",true,536897123]],["^15",[711,"^;","~u64b4990f-4928-4a68-bd2e-0bff9a44cd62",536897123]],["^15",[712,"^Q","The [[Result Type]] gets an Error [[Struct]] object when error .",536897188]],["^15",[712,"^O","^16",536897158]],["^15",[712,"^@",false,536897158]],["^15",[712,"^F",699,536897158]],["^15",[712,"^X",129,536897158]],["^15",[712,"^V",129,536897158]],["^15",[712,"^U",129,536897176]],["^15",[712,"^U",242,536897176]],["^15",[712,"^U",687,536897176]],["^15",[712,"^?",["^ "],536897188]],["^15",[712,"^H",242,536897188]],["^15",[712,"^H",687,536897188]],["^15",[712,"^17",true,536897158]],["^15",[712,"^;","~u64b4993b-ba49-4f96-b102-65587a8a50ca",536897158]],["^15",[713,"^Q","Turning Result to panic\nUsing [[Unwrap]] we can get just the value into a variable, as on ``unwrap`` it will panic/return some custom value.",536897459]],["^15",[713,"^O","^16",536897200]],["^15",[713,"^@",false,536897200]],["^15",[713,"^F",711,536897200]],["^15",[713,"^X",129,536897200]],["^15",[713,"^V",129,536897200]],["^15",[713,"^U",129,536897444]],["^15",[713,"^U",681,536897444]],["^15",[713,"^?",["^ "],536897459]],["^15",[713,"^H",681,536897459]],["^15",[713,"^17",true,536897200]],["^15",[713,"^;","~u64b49978-4ef4-4ed1-92c3-cf183e78d17b",536897200]],["^15",[714,"^K",1689557416897,536897204]],["^15",[714,"^[",883,536908100]],["^15",[714,"^@",false,536897204]],["^15",[714,"^Y","closure",536897204]],["^15",[714,"^11","Closure",536897204]],["^15",[714,"^B",1690519415158,536919454]],["^15",[714,"^;","~u64c20233-9388-4488-8360-8121e70d7236",536916343]],["^15",[716,"^Q","~``.unwrap_or(<V value>)``\nif the value is an ``Ok``/Some it doesn't do anything. If it is ``Err``/``Some`` then it returns the given value.",536897440]],["^15",[716,"^O","^16",536897250]],["^15",[716,"^@",false,536897250]],["^15",[716,"^F",718,536897400]],["^15",[716,"^X",681,536897250]],["^15",[716,"^V",681,536897250]],["^15",[716,"^U",681,536897407]],["^15",[716,"^?",["^ "],536897440]],["^15",[716,"^17",true,536897250]],["^15",[716,"^;","~u64b499fe-5d79-481e-8c73-ebc56f9abd6f",536897250]],["^15",[717,"^Q","~``.unwrap_or_else(<closure>)`` \nTakes a [[Closure]], runs it and returns its value if ``Err``/``None``.",536897437]],["^15",[717,"^O","^16",536897290]],["^15",[717,"^@",false,536897290]],["^15",[717,"^F",716,536897290]],["^15",[717,"^X",681,536897290]],["^15",[717,"^V",681,536897290]],["^15",[717,"^U",681,536897341]],["^15",[717,"^U",714,536897341]],["^15",[717,"^?",["^ "],536897437]],["^15",[717,"^H",714,536897437]],["^15",[717,"^17",true,536897290]],["^15",[717,"^;","~u64b49a37-6f7f-4e45-bb0a-41ba9f69b32d",536897290]],["^15",[718,"^Q","~``.unwrap()``\nif the value is an ``Ok``/``Some`` it doesn't do anything. If it is ``Err``/``None`` then it [[Panic]]s.",536897428]],["^15",[718,"^O","^16",536897363]],["^15",[718,"^@",false,536897363]],["^15",[718,"^F",682,536897363]],["^15",[718,"^X",681,536897363]],["^15",[718,"^V",681,536897363]],["^15",[718,"^U",219,536897375]],["^15",[718,"^U",681,536897375]],["^15",[718,"^?",["^ "],536897428]],["^15",[718,"^H",219,536897428]],["^15",[718,"^17",true,536897363]],["^15",[718,"^;","~u64b49a7c-24f1-4381-8b47-c6b440208178",536897363]],["^15",[719,"^Q","~``.expect(\"<string>\")``\n[[Result Type]] also has this [[Method]] which prints the given message and aborts if ``Err``.",536897519]],["^15",[719,"^O","^16",536897459]],["^15",[719,"^@",false,536897459]],["^15",[719,"^F",713,536897459]],["^15",[719,"^X",129,536897459]],["^15",[719,"^V",129,536897459]],["^15",[719,"^U",129,536897504]],["^15",[719,"^U",497,536897504]],["^15",[719,"^U",687,536897504]],["^15",[719,"^?",["^ "],536897519]],["^15",[719,"^H",497,536897519]],["^15",[719,"^H",687,536897519]],["^15",[719,"^17",true,536897459]],["^15",[719,"^;","~u64b49b0c-adff-486c-b0fa-5a65ce9ce74b",536897459]],["^15",[720,"^Q","Propagating Errors\nWe can use [[Pattern Matching]] on a [[Result Type]] and return a [[Result Type]] again, this essentially *re-throws* or propagates the error back. \nThe ``?`` [[Operator]] is a shorthand for Returning an ``Err``, i.e., it returns an ``Err`` if Err is found and [[Copy or Move]]s the error object. If there's no Err then it does nothing.\n\nFor ex.:\n```rust\nfn yo()  -> Result<io::File, io::Error>{\n\t let x =  File::open(\"hello.txt\");\nreturn match x{\n        Ok(s) => Ok(s),\n        Err(e) => Err(e),\n    }\n \n}\n//is the same as\nfn yo2() -> Result<io::File, io::Error>{\nlet x = File::open(\"hello.txt\")?; //Returns an Ok into x, if there's an Err it returns the Err with its value immediately from the function\n\nOk(x) //returns an Ok(x) \n}\n```\n\n* ``?`` vs. [[Pattern Matching]]\nA difference between these 2 is, ``?`` tries to coerce one error type into another. It does so by seeing what the expected return type of the current [[Function]]'s Result is then seeing if the error object has that type or its type has the ``From``[[Trait]] defined which converts the current error type into the return error type. If it is, then it calls the ``from`` [[Method]] of this [[Trait]] and does so.\n\n* This [[Operator]] can also be used with the [[Option Type]]\nFor ex.:\n```rust\nfn last_char_of_first_line(text: &str) -> Option<char> {\n    text.lines().next()?.chars().last()\n}\n```\nIf there's a ``None``, return None otherwise continue.",536898211]],["^15",[720,"^O","^16",536897519]],["^15",[720,"^@",false,536897519]],["^15",[720,"^F",719,536897519]],["^15",[720,"^X",129,536897519]],["^15",[720,"^V",129,536897519]],["^15",[720,"^U",129,536898162]],["^15",[720,"^U",130,536898162]],["^15",[720,"^U",202,536898162]],["^15",[720,"^U",206,536898162]],["^15",[720,"^U",228,536898162]],["^15",[720,"^U",256,536898162]],["^15",[720,"^U",414,536898162]],["^15",[720,"^U",497,536898162]],["^15",[720,"^U",687,536898162]],["^15",[720,"^?",["^ "],536898211]],["^15",[720,"^H",130,536898211]],["^15",[720,"^H",202,536898211]],["^15",[720,"^H",206,536898211]],["^15",[720,"^H",228,536898211]],["^15",[720,"^H",256,536898211]],["^15",[720,"^H",414,536898211]],["^15",[720,"^H",497,536898211]],["^15",[720,"^H",687,536898211]],["^15",[720,"^17",true,536897519]],["^15",[720,"^;","~u64b49b4b-ada5-40bc-8907-524761bfc53c",536897519]],["^15",[721,"^Q","",536897546]],["^15",[721,"^O","^16",536897546]],["^15",[721,"^@",false,536897546]],["^15",[721,"^F",710,536897546]],["^15",[721,"^X",687,536897546]],["^15",[721,"^V",687,536897546]],["^15",[721,"^U",687,536897547]],["^15",[721,"^?",["^ "],536897546]],["^15",[721,"^17",true,536897546]],["^15",[721,"^;","~u64b49b89-9d8a-4330-814b-fa57bcfbe568",536897546]],["^15",[722,"^Q","",536898146]],["^15",[722,"^O","^16",536898146]],["^15",[722,"^@",false,536898146]],["^15",[722,"^F",728,536898397]],["^15",[722,"^X",129,536898146]],["^15",[722,"^V",129,536898146]],["^15",[722,"^U",129,536898147]],["^15",[722,"^?",["^ "],536898146]],["^15",[722,"^17",true,536898146]],["^15",[722,"^;","~u64b49e91-617b-4789-aab8-423487341b75",536898146]],["^15",[723,"^U",129,536898167]],["^15",[724,"^U",129,536898167]],["^15",[725,"^U",129,536898167]],["^15",[726,"^Q","Main's return type\nThe ``fn main`` [[Function]] returns the [[Unit Type]] by default, but it can also return a [[Result Type]]. For ex.:\n```rust\nuse std::error::Error;\nuse std::fs::File;\n \nfn main() -> Result<(), Box<dyn Error>> {\n    let f = File::open(\"hello.txt\")?;\n \n    Ok(())\n}\n```\n``Box<dyn Error>`` is a [[Trait Object]], here it means return any type of Error object. This main [[Function]] returns a 0 to the OS if Ok() and another value otherwise, the value returned is defined by the ``ExitCode`` of the ``Termination`` [[Trait]] of the Error's type.",536906335]],["^15",[726,"^O","^16",536898211]],["^15",[726,"^@",false,536898211]],["^15",[726,"^F",720,536898211]],["^15",[726,"^X",129,536898211]],["^15",[726,"^V",129,536898211]],["^15",[726,"^U",129,536906336]],["^15",[726,"^U",130,536906336]],["^15",[726,"^U",211,536906336]],["^15",[726,"^U",262,536906336]],["^15",[726,"^U",414,536906336]],["^15",[726,"^U",687,536906336]],["^15",[726,"^?",["^ "],536906335]],["^15",[726,"^H",130,536906335]],["^15",[726,"^H",211,536906335]],["^15",[726,"^H",262,536906335]],["^15",[726,"^H",414,536906335]],["^15",[726,"^H",687,536906335]],["^15",[726,"^17",true,536898211]],["^15",[726,"^;","~u64b49edd-2af4-4ee7-a8bf-8ba90dc0409a",536898211]],["^15",[728,"^Q","",536898397]],["^15",[728,"^O","^16",536898397]],["^15",[728,"^@",false,536898397]],["^15",[728,"^F",726,536898397]],["^15",[728,"^X",129,536898397]],["^15",[728,"^V",129,536898397]],["^15",[728,"^U",129,536898398]],["^15",[728,"^?",["^ "],536898397]],["^15",[728,"^17",true,536898397]],["^15",[728,"^;","~u64b49fc9-f538-45f0-9ca4-8529618319db",536898397]],["^15",[729,"^12",2,536898422]],["^15",[732,"^3","- Just like other langs, rust supports Generics. \n  They are simply abstract [[Data Type]]s that act as stand-ins for more concrete types defined elsewhere. The benefit is that we get a type definition that allows multiple [[Data Type]]s in the same place. \n  Rust's powerful compiler requires us to only use features allowed by the type definition, through [[Trait]]s. \n  \n  For ex.: \n  ```rust\n  fn largest<T>(list: &[T]) -> &T {\n      let mut largest = &list[0];\n  \n      for item in list {\n          if item > largest {\n              largest = item;\n          }\n      }\n  \n      largest\n  }\n  \n  fn main() {\n       let number_list = vec![34, 50, 25, 100, 65];\n  \n      let result = largest(&number_list); //Rust can infer the correct type for T automatically\n  }\n  ```\n  Whilst a correct example of a Generic Type, fails to compile. This is because it is not guaranteed that every concrete type that will replace T will implement the ``>`` [[Operator]] (greater than).\n  Rust allows us to restrict the usage of items like ``largest`` [[Function]] here to only types that will implement this behavior, this means the call-site will fail to call the function, to do so we use [[Trait]]s, so here we make the function like so\n  \n  ```rust\n  fn largest<T: PartialOrd>(list: &[T]) -> &T {\n      let mut largest = &list[0];\n  \n      for item in list {\n          if item > largest {\n              largest = item;\n          }\n      }\n  \n      largest\n  }\n  ```\n  \n  And this says that concrete types for T must implement the ``std::cmp::PartialOrd`` [[Trait]].\n- Generics can be used anywhere we have any definition, be it [[Function]]s, [[Struct]]s, [[Enum]]s, [[Method]]s, [[Trait]]s etc.\n- General Generic Syntax\n  For [[Function]]s / [[Method]]s \n  ``\n  fn <fn name><<lifetime><generic name 1>: Trait 1 + Trait 2 +,...,+ Trait n = <Optional Type>, <lifetime><generic name 2>: Trait 1 + Trait 2 +,...,+ Trait n = <Optional Type>,....,<lifetime><generic name k>: Trait 1 + Trait 2 +,...,+ Trait n = <Optional Type>>(<params>) -> <Return Type, default is Unit Type> { \n  ...\n  }\n  ``\n  And the other definitions are kind of the same. \n  Here [[Lifetime]]s and [[Trait]]s are optional but restrict usage of the function with only types that satisfy the requirements.\n  Multiple ``trait``s are defined with the ``+`` [[Operator]]. \n  \n  * There's another syntax specific to [[Function]]s/ [[Method]]s to make this definition soup more readable. It uses the ``where`` keyword and is hence called the *Where Clause*.\n  \n  Syntax\n  ``\n  fn <fn name><<generic name 1>, <generic name 2>...<<generic name n>>(<params>) -> <Return Type> where <generic name 1> : <traits>, <generic name 2>: <traits>, <generic name n>:<traits> { }\n  ``\n  \n  ```rust\n  //fn yo<T: X, R: X+Y>(…) -> String {…}\n  //can be written as\n  \n  fn yo<T,R>(…)-> String \n  where T: X,\n  \tR: X+Y \n  { } \n  ```\n- [[Struct]]s and [[Enum]]s \n  \n  For ex.:\n  ```rust\n  struct X<T,K> {\n   x: T,\n   y: K,\n   z: T\n  }\n  \n  //And similarly for enums\n  enum A<T> {\n   Hello(T, i32),\n   No\n  }\n  \n  //and to use\n  fn main() {\n   let x= X{2,4.0,5}; //ok, infers the types as i32 and f64\n   let a= A::Hello(2,4); //ok\n  }\n  ```\n- [[Method]]s\n  \n  Using Generics in Methods and their implementation blocks allow us to define certain behavior only for certain concrete types. \n  \n  For ex.:\n  ```rust\n  struct X<T> {\n   x: T\n  }\n  \n  impl<T> X<T> {\n   fn yo(&self, value: T) {}\n  }\n  ```\n  Here we say ``impl`` will accept a generic and the same generic will be used for an instance of the ``X``. ``impl`` can only take a generic if it is applied to the [[Struct]]/ [[Enum]] as well. And the type after ``impl`` can take a generic only if ``impl`` takes a generic.\n  \n  So, \n  ```rust\n  //impl X<T> {...} is invalid as T is unknown\n  //impl<T> X{...} is invalid as X needs a type\n  impl X<i32>{ \n   fn naa(&self) { }\n  } //is valid because we simply define a concrete type of X\n  ```\n  \n  When we define a [[Method]] for ``X<T>`` then it is on every instance of every type of ``X``. But when we define it for ``X<i32>``, then the [[Method]] is only available on every instance of ``X`` of type ``i32``.\n  That is, for the above 2 examples combined, \n  \n  ```rust\n  struct X<T> {\n      x: T,\n  }\n  impl<T> X<T> {\n      fn yo(&self, value: T) {}\n  }\n  //impl X<T> {...} is invalid as T is unknown\n  //impl<T> X{...} is invalid as X needs a type\n  impl X<i32> {\n      fn naa(&self) {}\n  } //is valid because we simply define a concrete type of X\n  \n  fn main() {\n      let x = X { x: 4 };\n      let y = X { x: 2.0 };\n  \n      x.yo(2); //ok\n  \n      //x.yo(5.0); //error because T for X in x is i32, but here we are passing f64\n      //y.yo(3); //Similarly, this is also an error\n  \n      y.yo(4.0); //ok\n  \n      x.naa(); //ok\n  \n      //but\n      //y.naa(); //error as naa doesn't exist on the instance of X that isn't of type i32\n  }\n  \n  ```\n  \n  \n  * Methods theirselves can then have their own generics too, which are defined just like [[Function]]s.\n- Runtime Cost of Generics: 0\n  This is due to a process called *Monomorphization*. \n  During compilation, Rust compiler creates the explicit definitions for all [[Data Type]]s of a generic that are used in the code. This makes it as if we had declared each [[Function]] for a type separately. And the generic is replaced with concrete types at compile time itself. The resultant code is called [[Static Dispatch]], as the compiler knows what to call at compile-time itself.\n  \n  For ex.:\n  \n  ```rust\n  //This definition\n  struct X<T> {\n   x:T\n  }\n  \n  fn main() {\n   let x= X{2};\n   let y= X{4.0};\n  }\n  \n  //After compilation would become\n  /* \n  struct X_i32 {\n   x: i32\n  }\n  \n  struct X_f64{\n   x: f64\n  }\n  \n  fn main() {\n   let x = X_i32{2};\n   let y = X_f64{4.0};\n  }\n  */\n  ```\n- An example with Generic + [[Lifetime]] + [[Trait]]s + ``Trait Bound`` Syntax for a [[Function]] with [[Reference Type]]s \n  ```rust\n  use std::fmt::Display;\n  \n  fn longest_with_an_announcement<'a, T>(\n      x: &'a str,\n      y: &'a str,\n      ann: T,\n  ) -> &'a str\n  where\n      T: Display,\n  {\n      println!(\"Announcement! {}\", ann);\n      if x.len() > y.len() {\n          x\n      } else {\n          y\n      }\n  }\n  ```\n- There's a difference between a generic name and generic type.\n  For ex.:\n  ```rust\n  use std::fmt::Display;\n  trait X<T>{\n      fn whoa(&self, x:T);\n  }\n  \n  struct A{}\n  \n  impl<i32:Display> X<i32> for A {\n      fn whoa(&self, x: i32) {\n          println!(\"tf {}\", x);\n      }\n  }\n  \n  fn main() {\n      let a= A{};\n      a.whoa(2); //as expected\n      a.whoa(\"hm\"); //is it weird ?\n  } //works!\n  ```\n  Here we may think ``i32`` is the [[Number]] ``i32`` but in-fact it is just a name for the generic type. The definition for conditionally implementing ``X<i32>`` for [[Trait]] ``A`` here is ``impl X<i32> for A{...}``.\n- Default Type Parameters\n  We can define default [[Data Type]] for generics if they aren’t given with the type annotations and aren't inferable automatically. They are only applicable for generics on [[Struct]]s, [[Enum]]s or [[Trait]]s. \n  \n  For ex.:\n  ```rust\n  struct X<T = i32> {}\n  \n  struct Y<T> {}\n  \n  impl X { //takes T as i32 automatically.\n      fn yo(&self) {}\n  }\n  \n  /* impl Y {\n      fn yo(&self) {}\n  }\n  // error as T needs to be defined for Y\n  */ \n  ```\n-",536925762]],["^15",[732,"^18","~m1690967755471",536925761]],["^15",[732,"^Z","pages/Generic Type.md",536898428]],["^15",[735,"^Q","Generics can be used anywhere we have any definition, be it [[Function]]s, [[Struct]]s, [[Enum]]s, [[Method]]s, [[Trait]]s etc.",536916331]],["^15",[735,"^O","^16",536898892]],["^15",[735,"^@",false,536898892]],["^15",[735,"^F",244,536898892]],["^15",[735,"^X",131,536898892]],["^15",[735,"^V",131,536898892]],["^15",[735,"^U",130,536898944]],["^15",[735,"^U",131,536898944]],["^15",[735,"^U",242,536898944]],["^15",[735,"^U",414,536916331]],["^15",[735,"^U",497,536898944]],["^15",[735,"^U",511,536898944]],["^15",[735,"^H",130,536916331]],["^15",[735,"^H",242,536916331]],["^15",[735,"^H",414,536916331]],["^15",[735,"^H",497,536916331]],["^15",[735,"^H",511,536916331]],["^15",[735,"^17",true,536898892]],["^15",[735,"^;","~u64b612d2-0e37-4e2e-b75d-1e6d33e3a4ab",536898892]],["^15",[737,"^Q","Runtime Cost of Generics: 0\nThis is due to a process called *Monomorphization*. \nDuring compilation, Rust compiler creates the explicit definitions for all [[Data Type]]s of a generic that are used in the code. This makes it as if we had declared each [[Function]] for a type separately. And the generic is replaced with concrete types at compile time itself. The resultant code is called [[Static Dispatch]], as the compiler knows what to call at compile-time itself.\n\nFor ex.:\n\n```rust\n//This definition\nstruct X<T> {\n x:T\n}\n\nfn main() {\n let x= X{2};\n let y= X{4.0};\n}\n\n//After compilation would become\n/* \nstruct X_i32 {\n x: i32\n}\n\nstruct X_f64{\n x: f64\n}\n\nfn main() {\n let x = X_i32{2};\n let y = X_f64{4.0};\n}\n*/\n```",536900304]],["^15",[737,"^O","^16",536899236]],["^15",[737,"^@",false,536899236]],["^15",[737,"^F",743,536899515]],["^15",[737,"^X",131,536899236]],["^15",[737,"^V",131,536899236]],["^15",[737,"^U",130,536900077]],["^15",[737,"^U",131,536900077]],["^15",[737,"^U",148,536900077]],["^15",[737,"^U",744,536900077]],["^15",[737,"^H",130,536916331]],["^15",[737,"^H",148,536916331]],["^15",[737,"^H",744,536916331]],["^15",[737,"^17",true,536899236]],["^15",[737,"^;","~u64b61514-037a-475e-ba33-fa45fbe3acf0",536899236]],["^15",[738,"^Q","[[Struct]]s and [[Enum]]s \n\nFor ex.:\n```rust\nstruct X<T,K> {\n x: T,\n y: K,\n z: T\n}\n\n//And similarly for enums\nenum A<T> {\n Hello(T, i32),\n No\n}\n\n//and to use\nfn main() {\n let x= X{2,4.0,5}; //ok, infers the types as i32 and f64\n let a= A::Hello(2,4); //ok\n}\n```",536899509]],["^15",[738,"^O","^16",536899264]],["^15",[738,"^@",false,536899264]],["^15",[738,"^F",1038,536916331]],["^15",[738,"^X",131,536899264]],["^15",[738,"^V",131,536899264]],["^15",[738,"^U",131,536899391]],["^15",[738,"^U",242,536899391]],["^15",[738,"^U",511,536899391]],["^15",[738,"^H",242,536916331]],["^15",[738,"^H",511,536916331]],["^15",[738,"^17",true,536899264]],["^15",[738,"^;","~u64b61561-9340-4701-abb6-38876c793747",536899264]],["^15",[743,"^Q","[[Method]]s\n\nUsing Generics in Methods and their implementation blocks allow us to define certain behavior only for certain concrete types. \n\nFor ex.:\n```rust\nstruct X<T> {\n x: T\n}\n\nimpl<T> X<T> {\n fn yo(&self, value: T) {}\n}\n```\nHere we say ``impl`` will accept a generic and the same generic will be used for an instance of the ``X``. ``impl`` can only take a generic if it is applied to the [[Struct]]/ [[Enum]] as well. And the type after ``impl`` can take a generic only if ``impl`` takes a generic.\n\nSo, \n```rust\n//impl X<T> {...} is invalid as T is unknown\n//impl<T> X{...} is invalid as X needs a type\nimpl X<i32>{ \n fn naa(&self) { }\n} //is valid because we simply define a concrete type of X\n```\n\nWhen we define a [[Method]] for ``X<T>`` then it is on every instance of every type of ``X``. But when we define it for ``X<i32>``, then the [[Method]] is only available on every instance of ``X`` of type ``i32``.\nThat is, for the above 2 examples combined, \n\n```rust\nstruct X<T> {\n    x: T,\n}\nimpl<T> X<T> {\n    fn yo(&self, value: T) {}\n}\n//impl X<T> {...} is invalid as T is unknown\n//impl<T> X{...} is invalid as X needs a type\nimpl X<i32> {\n    fn naa(&self) {}\n} //is valid because we simply define a concrete type of X\n\nfn main() {\n    let x = X { x: 4 };\n    let y = X { x: 2.0 };\n\n    x.yo(2); //ok\n\n    //x.yo(5.0); //error because T for X in x is i32, but here we are passing f64\n    //y.yo(3); //Similarly, this is also an error\n\n    y.yo(4.0); //ok\n\n    x.naa(); //ok\n\n    //but\n    //y.naa(); //error as naa doesn't exist on the instance of X that isn't of type i32\n}\n\n```\n\n\n* Methods theirselves can then have their own generics too, which are defined just like [[Function]]s.",536916331]],["^15",[743,"^O","^16",536899515]],["^15",[743,"^@",false,536899515]],["^15",[743,"^F",738,536899515]],["^15",[743,"^X",131,536899515]],["^15",[743,"^V",131,536899515]],["^15",[743,"^U",130,536900029]],["^15",[743,"^U",131,536900029]],["^15",[743,"^U",242,536900029]],["^15",[743,"^U",497,536900029]],["^15",[743,"^U",511,536900029]],["^15",[743,"^H",130,536916331]],["^15",[743,"^H",242,536916331]],["^15",[743,"^H",497,536916331]],["^15",[743,"^H",511,536916331]],["^15",[743,"^17",true,536899515]],["^15",[743,"^;","~u64b616f0-c07b-49f3-aaa5-2248523f5007",536899515]],["^15",[744,"^K",1689655903325,536900076]],["^15",[744,"^@",false,536900076]],["^15",[744,"^Y","static dispatch",536900076]],["^15",[744,"^11","Static Dispatch",536900076]],["^15",[744,"^B",1689655903325,536900076]],["^15",[744,"^;","~u64c20232-677a-449a-bd64-3d1cfb4e3b9a",536916331]],["^15",[745,"^Q","Default Type Parameters\nWe can define default [[Data Type]] for generics if they aren’t given with the type annotations and aren't inferable automatically. They are only applicable for generics on [[Struct]]s, [[Enum]]s or [[Trait]]s. \n\nFor ex.:\n```rust\nstruct X<T = i32> {}\n\nstruct Y<T> {}\n\nimpl X { //takes T as i32 automatically.\n    fn yo(&self) {}\n}\n\n/* impl Y {\n    fn yo(&self) {}\n}\n// error as T needs to be defined for Y\n*/ \n```",536919634]],["^15",[745,"^O","^16",536900092]],["^15",[745,"^@",false,536900092]],["^15",[745,"^F",1039,536916331]],["^15",[745,"^X",131,536900092]],["^15",[745,"^V",131,536900092]],["^15",[745,"^U",131,536919533]],["^15",[745,"^U",148,536919533]],["^15",[745,"^U",242,536919533]],["^15",[745,"^U",414,536919533]],["^15",[745,"^U",511,536919533]],["^15",[745,"^?",["^ "],536919634]],["^15",[745,"^H",148,536919634]],["^15",[745,"^H",242,536919634]],["^15",[745,"^H",414,536919634]],["^15",[745,"^H",511,536919634]],["^15",[745,"^17",true,536900092]],["^15",[745,"^;","~u64b61a68-0de2-4c47-86ee-e3b0e2d3ae1b",536900092]],["^15",[746,"^Q","An example with Generic + [[Lifetime]] + [[Trait]]s + ``Trait Bound`` Syntax for a [[Function]] with [[Reference Type]]s \n```rust\nuse std::fmt::Display;\n\nfn longest_with_an_announcement<'a, T>(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```",536905296]],["^15",[746,"^O","^16",536900309]],["^15",[746,"^@",false,536900309]],["^15",[746,"^F",737,536900309]],["^15",[746,"^X",131,536900309]],["^15",[746,"^V",131,536900309]],["^15",[746,"^U",130,536905284]],["^15",[746,"^U",131,536905284]],["^15",[746,"^U",253,536905284]],["^15",[746,"^U",280,536905284]],["^15",[746,"^U",414,536905284]],["^15",[746,"^H",130,536916331]],["^15",[746,"^H",253,536916331]],["^15",[746,"^H",280,536916331]],["^15",[746,"^H",414,536916331]],["^15",[746,"^17",true,536900309]],["^15",[746,"^;","~u64b61b01-8892-4398-8f94-8cad15ba2fb1",536900309]],["^15",[747,"^Q","~``trait``\nKind of like an *interface* from other langs.\nTraits allow us to define functionality that can be shared to one or more [[Data Type]]s. By [[Data Type]]s we refer to [[Struct]] and [[Enum]]s.",536900777]],["^15",[747,"^O","^16",536900314]],["^15",[747,"^@",false,536900314]],["^15",[747,"^F",414,536900314]],["^15",[747,"^X",414,536900314]],["^15",[747,"^V",414,536900314]],["^15",[747,"^U",148,536900773]],["^15",[747,"^U",242,536900773]],["^15",[747,"^U",414,536900773]],["^15",[747,"^U",511,536900773]],["^15",[747,"^H",148,536916346]],["^15",[747,"^H",242,536916346]],["^15",[747,"^H",511,536916346]],["^15",[747,"^17",true,536900314]],["^15",[747,"^;","~u64b625e9-b4fe-4b89-bf76-d3c6c45108fa",536900314]],["^15",[749,"^Q","Traits are defined using ``trait``, and then for a type they are implemented using ``impl`` blocks.\nMuch like *interface*s, ``trait``s can just define the [[Method]] Signatures, and the actual implementation for the methods can be given by the type implementing the  Trait.\n\nSyntax:\n``\n<Optional Access Modifier> trait <trait name> {\n fn <method 1 name>(<params>)-> <Optional Return Type>;\n //can define a default implementation\nfn <method 2 name>(<params>)-> <Optional Return Type> { } //ok\n ...\n  fn <method n name>(<params>)-> <Optional Return Type>;\n}\n``\nAnd then to implement them,\n\n``\nimpl <trait name> for <Struct/Enum name> {\n <Method 1 definition>{...}\n  <Method 2 definition>{...}\n ...\n  <Method n definition>{...}\n}\n``\n\nFor ex.:\n```rust\npub trait Dance{\n fn move(&Self)-> i32;\n \n}\n\nstruct X{\n x:i32,\n}\n\nimpl Dance for X {\n fn move(&self)-> i32 {\n 2+2\n }\n}\n\nfn main() {\n let x= X{2};\n x.move(); //works\n}\n```\n\nThe [[Access Modifier]]s are applied to trait definitions too and they are *private* by default, so if a [[Crate]]/ [[Module]] has a private trait then it can't be used by an external [[Crate]] to implement the trait on its types, this doesn't mean private traits defined for public types have their implementations hidden, the implemented methods are still available to external [[Crate]]s.",536919987]],["^15",[749,"^O","^16",536900538]],["^15",[749,"^@",false,536900538]],["^15",[749,"^F",747,536900538]],["^15",[749,"^X",414,536900538]],["^15",[749,"^V",414,536900538]],["^15",[749,"^U",414,536919988]],["^15",[749,"^U",497,536919988]],["^15",[749,"^U",530,536919988]],["^15",[749,"^U",577,536919988]],["^15",[749,"^U",583,536919988]],["^15",[749,"^?",["^ "],536919987]],["^15",[749,"^H",497,536919987]],["^15",[749,"^H",530,536919987]],["^15",[749,"^H",577,536919987]],["^15",[749,"^H",583,536919987]],["^15",[749,"^17",true,536900538]],["^15",[749,"^;","~u64b62793-b82e-4744-81e1-42eeec4b88ef",536900538]],["^15",[750,"^Q","Orphan Rule\nThis is part of a property called [[coherence]]. According to it, a ``trait`` can be implemented for a type iff either the trait or the [[Data Type]] is local to the [[Crate]] (defined in the same [[Crate]]). \n\nFor ex.:\nIf crate ``A`` defines a trait ``X`` then it can define the trait ``X`` for any [[Data Type]] , local or external, such as a type ``T`` from crate ``B``. \nSimilarly, if crate ``A`` defines a type ``T`` then it can implement trait ``X`` defined in crate B for its type ``T``. \nBut if crate ``C`` defines neither type ``T`` or trait ``X`` but takes them from crate ``A`` and ``B``, i.e., both are external then this is not allowed according to this rule.\n\nThis is to ensure the Parent type exists, and other people’s code can’t break our own or theirs because a trait/type is defined at a place different from the crate where it is created.\n\n* Newtype Pattern: It is possible to avoid the Orphan Rule by simply wrapping the external type ``T`` in a new type and then implementing a trait on this new type. It's called so because of a similar pattern in Haskell.\nFor ex.:\n```rust\nuse std::fmt;\n \nstruct Wrapper{\n    v: Vec<String>\n}\n \nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.v.join(\", \"))\n    }\n}\n \nfn main() {\n    let w = Wrapper{v:vec![String::from(\"hello\"), String::from(\"world\")]};\n    println!(\"w = {}\", w);\n}\n\n```",536901352]],["^15",[750,"^O","^16",536900875]],["^15",[750,"^@",false,536900875]],["^15",[750,"^F",754,536901507]],["^15",[750,"^X",414,536900875]],["^15",[750,"^V",414,536900875]],["^15",[750,"^U",148,536901044]],["^15",[750,"^U",414,536901044]],["^15",[750,"^U",577,536901044]],["^15",[750,"^U",751,536901044]],["^15",[750,"^H",148,536916346]],["^15",[750,"^H",577,536916346]],["^15",[750,"^H",751,536916346]],["^15",[750,"^17",true,536900875]],["^15",[750,"^;","~u64b628d6-bdff-4af9-bb61-0866d669a616",536900875]],["^15",[751,"^K",1689660302639,536901032]],["^15",[751,"^@",false,536901032]],["^15",[751,"^Y","coherence",536901032]],["^15",[751,"^11","coherence",536901032]],["^15",[751,"^B",1689660302639,536901032]],["^15",[751,"^;","~u64c20233-c09c-46f4-8f31-ccbf3e599809",536916346]],["^15",[754,"^Q","Default implementation\nA trait definition can define a default implementation for a [[Method]], and then that definition is used if the implementing type doesn't override it.\n\nFor ex.:\n\n```rust\npub trait Dance{\n fn move(&Self)-> i32 { }\n}\n\nstruct X{\n x:i32,\n}\n\nimpl Dance for X {\n\n}\n//ok\n\n```\nThe empty ``impl`` block is necessary as it defines ``Dance`` is being implemented on ``X``.\n\nTrait implementations with empty bodies are called *Marker Trait*s or *Tag Trait*s.",536901500]],["^15",[754,"^O","^16",536901157]],["^15",[754,"^@",false,536901157]],["^15",[754,"^F",755,536901189]],["^15",[754,"^X",414,536901157]],["^15",[754,"^V",414,536901157]],["^15",[754,"^U",414,536901177]],["^15",[754,"^U",497,536901177]],["^15",[754,"^H",497,536916346]],["^15",[754,"^17",true,536901157]],["^15",[754,"^;","~u64b62c43-e631-4bcf-bff5-003c8c8de653",536901157]],["^15",[755,"^Q","All [[Method]]s in a trait definition without a default implementation need to be defined when the trait is implemented for a [[Data Type]].",536901365]],["^15",[755,"^O","^16",536901189]],["^15",[755,"^@",false,536901189]],["^15",[755,"^F",1115,536919987]],["^15",[755,"^X",414,536901189]],["^15",[755,"^V",414,536901189]],["^15",[755,"^U",148,536901231]],["^15",[755,"^U",414,536901231]],["^15",[755,"^U",497,536901231]],["^15",[755,"^H",148,536916346]],["^15",[755,"^H",497,536916346]],["^15",[755,"^17",true,536901189]],["^15",[755,"^;","~u64b62c6f-31ed-44e0-8c36-04e948835c15",536901189]],["^15",[757,"^Q","~``self``\nWe use ``self`` in a trait to pass an instance of the type to the function, allowing us to call other [[Method]]s and fields.\nWhile this means we can’t access a type-specific method/field in a trait’s default method, we can access trait-specific methods because of it. \nFor ex.:\n```rust\npub trait X {\n    fn na();\n    fn ya(&self);\n    fn yo(&self) -> String {\n        Self::na();\n        self.ya();\n        return \"na\".to_string();\n    } //works because self will always have na() and ya() as it’s defined on trait itself.\n    fn ayo(&mut self);\n}\n\nstruct A {\n    x: i32,\n}\n\nimpl X for A {\n    fn na() {}\n    fn ya(&self) {}\n    fn ayo(&mut self) {\n        self.x += 2;\n    }\n}\n\nfn main() {\n    let mut a = A { x: 2 };\n    a.ayo();\n}\n```\nHowever, non-default implemented trait methods can access instance fields and methods.",536901650]],["^15",[757,"^O","^16",536901361]],["^15",[757,"^@",false,536901361]],["^15",[757,"^F",750,536901361]],["^15",[757,"^X",414,536901361]],["^15",[757,"^V",414,536901361]],["^15",[757,"^U",414,536901548]],["^15",[757,"^U",497,536901548]],["^15",[757,"^H",497,536916346]],["^15",[757,"^17",true,536901361]],["^15",[757,"^;","~u64b62d3d-3d07-4690-800a-ea3fe462ef3c",536901361]],["^15",[760,"^U",414,536901574]],["^15",[761,"^U",414,536901574]],["^15",[762,"^U",414,536901574]],["^15",[763,"^U",414,536901574]],["^15",[764,"^Q","",536901622]],["^15",[764,"^O","^16",536901622]],["^15",[764,"^@",false,536901622]],["^15",[764,"^F",504,536901622]],["^15",[764,"^X",497,536901622]],["^15",[764,"^V",497,536901622]],["^15",[764,"^U",497,536901623]],["^15",[764,"^?",["^ "],536901622]],["^15",[764,"^17",true,536901622]],["^15",[764,"^;","~u64b631e7-487f-47df-beba-a6d517b82259",536901622]],["^15",[765,"^12",2,536901713]],["^15",[768,"^Q","[[Function]]/ [[Method]] Parameters/Return Types can use [[Trait]]s too\nWhen Parameters use traits, they require the type of object being passed as argument to implement the trait(s).\nThese are simply a syntax sugar for using [[Generic Type]]s, aka ``Trait Bound`` Syntax.\n\nSyntax:\n\n``\nfn <somename>(<param name>: <optional reference &> impl <trait name> + <any other trait> + .., <param 2>) {...}\n``\n\nFor ex.:\n```rust\npub trait X {\n fn notify() {}\n}\npub fn notify(item: &impl X) { //Requires the type of object being passed to notify() to implement the trait X\n    println!(\"Breaking news! {}\", item.notify());\n}\n```\n\n* ``Trait Bound`` Syntax: \nThe ``impl Trait`` is simply a syntax sugar for a longer syntax which is just the [[Generic Type]] syntax.\n\nFor ex.:\n```rust\npub trait X {\n fn notify() {}\n}\npub fn notify<T: X>(item: &T) { \n    println!(\"Breaking news! {}\", item.notify());\n}\n```\nThere's a slight difference between the 2 syntaxes, the ``impl Trait`` syntax requires simply the type of the argument object to implement the trait, but it doesn't require the object's types to be the same.\nFor ex.:\n```rust\npub trait X {\n fn notify() {}\n}\npub fn notify<T: X>(item: &T, item2: &T) {  //accepts a single type T and that T must be the same for both the args/params\n}\npub fn notify(item: &impl X, item2: &impl X) {  //accepts 2 types, they can be the same, they just need to implement the trait X\n}\n\n```\n\n* The Return types can use the ``impl Trait`` and [[Generic Type]]s too\nHowever, there's a limitation with the Rust Compiler that disallows different code paths returning different types. All code paths in a [[Function]]/ [[Method]] must return the same [[Data Type]] object, and that type must implement the given trait(s). \nFor ex.:\n```rust\npub trait X {}\n\nstruct A{ }\n\nimpl X for A {}\n\nstruct B{ }\n\nimpl X for B {}\n\nfn yo()-> impl X {\n if (1==2) {\n   return A{};\n  }\nelse {\n  return B{};\n }\n}\n//whilst it should work, doesn't. Gives an error as both must return the same type of object.\n```",536903131]],["^15",[768,"^O","^16",536901756]],["^15",[768,"^@",false,536901756]],["^15",[768,"^F",757,536901756]],["^15",[768,"^X",414,536901756]],["^15",[768,"^V",414,536901792]],["^15",[768,"^U",130,536902932]],["^15",[768,"^U",131,536902932]],["^15",[768,"^U",148,536902932]],["^15",[768,"^U",414,536902932]],["^15",[768,"^U",497,536902932]],["^15",[768,"^H",130,536916346]],["^15",[768,"^H",131,536916346]],["^15",[768,"^H",148,536916346]],["^15",[768,"^H",414,536916346]],["^15",[768,"^H",497,536916346]],["^15",[768,"^17",true,536901756]],["^15",[768,"^;","~u64b7e9c0-6e16-442a-8f3a-73c4928395ec",536901756]],["^15",[776,"^Q","Multiple Traits for [[Generic Type]]s definition are combined with the ``+`` [[Operator]]\n\nFor ex.:\n```rust\ntrait X{}\ntrait Y{}\npb fn yo<T: X+Y>() {}\n```",536902452]],["^15",[776,"^O","^16",536902359]],["^15",[776,"^@",false,536902359]],["^15",[776,"^F",787,536903077]],["^15",[776,"^X",414,536902359]],["^15",[776,"^V",414,536902359]],["^15",[776,"^U",131,536902398]],["^15",[776,"^U",206,536902398]],["^15",[776,"^U",414,536902398]],["^15",[776,"^H",131,536916346]],["^15",[776,"^H",206,536916346]],["^15",[776,"^17",true,536902359]],["^15",[776,"^;","~u64b803ca-485d-4db8-8317-1632d4b51041",536902359]],["^15",[777,"^5",1079,536917707]],["^15",[777,"^K",1689781493830,536902579]],["^15",[777,"^[",1075,536917555]],["^15",[777,"^O","^16",536917550]],["^15",[777,"^@",false,536902579]],["^15",[777,"^Y","dynamically sized type",536902579]],["^15",[777,"^11","Dynamically Sized Type",536902579]],["^15",[777,"^?",["^ ","^19",["^1:",["DST"]]],536917707]],["^15",[777,"^4",["^ ","^19","DST"],536917707]],["^15",[777,"^B",1690515225592,536918327]],["^15",[777,"^;","~u64c20233-b28f-44ca-9a44-a69c1512e583",536916346]],["^15",[778,"^U",131,536902644]],["^15",[779,"^U",131,536902644]],["^15",[780,"^U",131,536902644]],["^15",[781,"^U",131,536902644]],["^15",[782,"^U",131,536902644]],["^15",[783,"^U",131,536902644]],["^15",[784,"^U",131,536902644]],["^15",[785,"^U",131,536902644]],["^15",[787,"^Q","Conditionally implementing [[Method]]s and Traits for custom [[Data Type]]s\nUsing ``Trait Bound`` Syntax, we can define methods or traits for types that have\ngiven traits.\nFor ex.:\n```rust\nstruct X<T> {…}\ntrait Y {}\ntrait Z {\nfn na() {}\n}\n\nimpl<T: Y> X<T> {\n\tfn yo() { }\n}\n\nimpl<T: Y> Z for X<T> {\n\t\n}\n\nimpl<T> Y for X<T> {\n\n}\n```\nFor a type ``T`` used to create the object of ``X``, the method ``yo()`` can only be called if ``T`` implements the trait ``Y`` and the methods of trait ``Z``, i.e., ``na()`` can only be called if ``T`` implements the trait ``Y``.\n\nThis is how we conditionally implement [[Method]]s/Traits for a [[Data Type]]. Yes, this condition is resolved at compile-time itself as the concrete definitions are put in by the compiler.\n\n* Blanket Implementation\nWe can also apply traits to [[Generic Type]]s directly. These are known as blanket implementations as they apply a trait to multiple types.\n\nFor ex.:\n```rust\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\nThis is how the ``ToString`` trait is already applied in the [[Standard Library]], for any [[Data Type]] that implements the trait ``Display``, the trait ``ToString`` is automatically applied. Similarly we can apply our own traits to multiple types at once too.",536903541]],["^15",[787,"^O","^16",536903077]],["^15",[787,"^@",false,536903077]],["^15",[787,"^F",768,536903077]],["^15",[787,"^X",414,536903077]],["^15",[787,"^V",414,536903077]],["^15",[787,"^U",93,536903502]],["^15",[787,"^U",131,536903502]],["^15",[787,"^U",148,536903502]],["^15",[787,"^U",414,536903502]],["^15",[787,"^U",497,536903502]],["^15",[787,"^H",93,536916346]],["^15",[787,"^H",131,536916346]],["^15",[787,"^H",148,536916346]],["^15",[787,"^H",497,536916346]],["^15",[787,"^17",true,536903077]],["^15",[787,"^;","~u64b80f08-90ba-4f5d-97c7-695e248202e3",536903077]],["^15",[788,"^Q","All References have an associated [[Lifetime]] with them.",536903569]],["^15",[788,"^O","^16",536903546]],["^15",[788,"^@",false,536903546]],["^15",[788,"^F",438,536903546]],["^15",[788,"^X",253,536903546]],["^15",[788,"^V",253,536903546]],["^15",[788,"^U",253,536903566]],["^15",[788,"^U",280,536903566]],["^15",[788,"^H",280,536908129]],["^15",[788,"^17",true,536903546]],["^15",[788,"^;","~u64b81c9a-8723-4c17-b6c7-798f158e05e2",536903546]],["^15",[789,"^Q","Referencing and Dereferencing\n\nA [[Data Type]] ``&T`` simply stores value that is a memory address, so a ``&T`` value will never be equal/comparable to a value of type ``T``. \n\n``T`` -> ``&T`` : We do this with ``<value>``-> ``&<value>``. The ``&`` [[Operator]] returns the memory address and a type ``&T`` can store the address.\n\n``&T`` -> ``T`` : We do this with ``<value>`` -> ``*<value>`` where the ``*`` [[Operator]] is called the dereference operator. It accesses the value at the address pointed to by a ``&T`` value and returns a value of type ``T``.  \n\n* The memory address has a single type, i32 for 32-bit systems and i64 for 64-bit systems. But by having a different name for ``&T``, Rust ensures no type-checking is required when converting references/derefences.\n\n* Dereference of non-primitive [[Data Type]]s requires implementation of the ``Deref`` [[Trait]].",536908719]],["^15",[789,"^O","^16",536903572]],["^15",[789,"^@",false,536903572]],["^15",[789,"^F",788,536903572]],["^15",[789,"^X",253,536903572]],["^15",[789,"^V",253,536903572]],["^15",[789,"^U",148,536908720]],["^15",[789,"^U",206,536908720]],["^15",[789,"^U",253,536908720]],["^15",[789,"^U",414,536908720]],["^15",[789,"^?",["^ "],536908719]],["^15",[789,"^H",148,536908719]],["^15",[789,"^H",206,536908719]],["^15",[789,"^H",414,536908719]],["^15",[789,"^17",true,536903572]],["^15",[789,"^;","~u64b81cf3-d611-492c-9c30-e6a005fe577e",536903572]],["^15",[790,"^Q","Lifetimes are kind of like [[Generic Type]]s and whilst Rust implicitly uses them, we can also use them as abstract symbols that explicitly define the validity of [[Reference Type]]s. \nJust like the [[Data Type]] for [[Generic Type]]s is inferred automatically, the lifetime for [[Reference Type]]s are also inferred automatically.\n\nThe main objective of lifetimes is to track the validity of references making sure they are valid when accessed.\n\nLifetimes are always used for [[Reference Type]]s, the only thing is that Rust can infer the lifetimes automatically most of the time (aka *Lifetime Elision*), but where it can't, we have to explicitly define the lifetime.",536904878]],["^15",[790,"^O","^16",536903577]],["^15",[790,"^@",false,536903577]],["^15",[790,"^F",280,536903577]],["^15",[790,"^X",280,536903577]],["^15",[790,"^V",280,536903577]],["^15",[790,"^U",131,536903658]],["^15",[790,"^U",148,536903658]],["^15",[790,"^U",253,536903658]],["^15",[790,"^U",280,536903658]],["^15",[790,"^H",131,536916334]],["^15",[790,"^H",148,536916334]],["^15",[790,"^H",253,536916334]],["^15",[790,"^17",true,536903577]],["^15",[790,"^;","~u64b81d09-8235-4deb-ada2-56757251a725",536903577]],["^15",[791,"^3","- Lifetimes are kind of like [[Generic Type]]s and whilst Rust implicitly uses them, we can also use them as abstract symbols that explicitly define the validity of [[Reference Type]]s. \n  Just like the [[Data Type]] for [[Generic Type]]s is inferred automatically, the lifetime for [[Reference Type]]s are also inferred automatically.\n  \n  The main objective of lifetimes is to track the validity of references making sure they are valid when accessed.\n  \n  Lifetimes are always used for [[Reference Type]]s, the only thing is that Rust can infer the lifetimes automatically most of the time (aka *Lifetime Elision*), but where it can't, we have to explicitly define the lifetime.\n- The [[Borrow]] Checker\n  Rust compiler has this feature, which allows it to check, at compile time itself, if all the references in the code are valid, checking if the [[Borrow]] is valid. \n  \n  For ex.:\n  ```rust\n  fn main() {\n      let r;                // ---------+-- 'a\n                            //          |\n      {                     //          |\n          let x = 5;        // -+-- 'b  |\n          r = &x;           //  |       |\n      }                     // -+       |\n                            //          |\n      println!(\"r: {}\", r); //          |\n  }                         // ---------+\n  ```\n  Here, the lifetime of ``r`` is represented with ``'a`` and for ``x`` it is ``'b`` and as we can see ``'b`` is valid for a smaller duration than ``'b`` and hence if the reference ``r`` tries to access the value of ``x``, it will fail as the life of ``x`` is over already.\n  The Borrow Checker checks all borrows like so at compile time.\n  \n  Similarly, in [[Function]]s/ [[Method]]s , if we use [[Reference Type]] returns, and when it is not inferrable which parameter will be returned, we need to explicitly define the lifetimes. \n  For ex.:\n  ```rust\n  fn longest(x: &str, y: &str) -> &str {\n      if x.len() > y.len() {\n          x\n      } else {\n          y\n      }\n  }\n  \n  fn main() {\n   let a= \"yo\";\n   let mut c: &str;\n   { \n    let b= \"no\";\n    c = longest(&a,&b); //Which reference is returned from longest ? \n   } //if c has the reference lifetime of b then this is where it becomes invalid \n   \n  } //if c has the reference lifetime of a then this is where it becomes invalid \n  ```\n  This code leads to an error at compile time, because the borrow checker is not sure if ``x`` or ``y`` will be returned, meaning it is not guaranteed for the caller of ``longest()``which lifetime it will have. \n  This is why we need to explicitly define the lifetimes for ``longest`` here to let the compiler know which lifetime is being returned.\n- Explicit definition of lifetimes\n  We use the same syntax as [[Generic Type]]s, however the key difference is that generic lifetime names need to be prefixed with the ``'`` letter, like ``'x`` and they aren't [[Generic Type]]s so they can't be used to replace them in the syntax.\n  \n  Syntax for [[Function]]s/ [[Method]]s :\n  ``\n  fn <fn name><< ' + lifetime name 1>, < ' + lifetime name 2>,..., < ' + lifetime name n>(<param name 1>: <if param type & then, & ' + lifetime name>, ...)-> <if return type & then, & + ' + lifetime name> {...}\n  ``\n  Lifetime definitions on [[Function]] parameters are called *input lifetimes* while the return type lifetime definitions are called *output lifetimes*.\n  \n  For ex.:\n  ```rust\n  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n      if x.len() > y.len() {\n          x\n      } else {\n          y\n      }\n  }\n  ```\n  This function has only a single lifetime generic, so it will only infer a single lifetime from its args and expect the same from both the args. If the args have different lifetimes, then the smaller lifetime is inferred. \n  Here, we are not changing the lifetime of ``longest``, rather only allowing certain lifetimes and letting the [[Borrow]] checker know which lifetimes will be used where. \n  \n  We can only define lifetimes in [[Function]] Signatures, not in their bodies.\n  Furthermore, when returning a reference type and defining a lifetime for it, the lifetime must be also applied to a reference parameter.\n  \n  * For [[Struct]]s:\n  For ex.:\n  ```rust\n  struct X<’a> {\n  \tyo: &’a str,\n  }\n  //says the instance of struct X will only live as long as the string field yo lives.\n  ```\n  \n  * For [[Method]] implementation blocks:\n  ```rust\n  impl<’a> X<’a> {\n  \tfn yo(&self) {…}\n  }\n  ```\n- *Lifetime Elision* Rules\n  [[Function]]s and ``impl`` blocks always need a lifetime definition for [[Reference Type]]s. \n  \n  We don't always need to explicitly define them, but if none of these rules can be applied then they need to be explicitly defined:\n  *\tEach reference parameter in signature gets a separate lifetime. \n  ```rust\n  fn yo(x: &str) {} //gets fn yo<’a>(x:&’a str) \n  fn yo2(x: &str,y: &str){} //gets fn  yo<’a, ‘b>(x: &’a str, y: &’b str) \n  //and so on\n  ``` \n  \n  *\tIf there’s exactly 1 reference parameter and it is given an explicit lifetime then the same lifetime is applied to the return type reference, if any.\n  * If there are multiple *input lifetime* parameters, and one of them is ``&self`` or ``&mut self`` then the ``self``’s lifetime is applied to the return type reference. \n  \n  Multiple rules will be applied to the same signature if a single rule doesn’t make the signature valid.\n  For ex.:\n  ```rust\n  Struct X{}\n  impl  X {\n  \tfn yo(&self, x: &str) -> &str {…} \n  }\n  // This is not an error, as the 1st rule applies a lifetime to both the parameters and the 3rd rule applies the self’s lifetime to the return type. \n  ```\n- *Static lifetime*\n  Applying this lifetime to a [[Reference Type]] puts it in the binary and increases the size of it. But the reference is valid for the duration of entire program. \n  Static lifetime can only be applied to values that are known at compile time.\n  For ex.:\n  ```rust\n  let x: &’static str= \"yeee\";\n  ```\n  \n  All [[str]] literals have the static lifetime anyways.\n-",536916334]],["^15",[791,"^18","~m1690334761078",536916335]],["^15",[791,"^Z","pages/Lifetime.md",536903581]],["^15",[792,"^Q","The [[Borrow]] Checker\nRust compiler has this feature, which allows it to check, at compile time itself, if all the references in the code are valid, checking if the [[Borrow]] is valid. \n\nFor ex.:\n```rust\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n```\nHere, the lifetime of ``r`` is represented with ``'a`` and for ``x`` it is ``'b`` and as we can see ``'b`` is valid for a smaller duration than ``'b`` and hence if the reference ``r`` tries to access the value of ``x``, it will fail as the life of ``x`` is over already.\nThe Borrow Checker checks all borrows like so at compile time.\n\nSimilarly, in [[Function]]s/ [[Method]]s , if we use [[Reference Type]] returns, and when it is not inferrable which parameter will be returned, we need to explicitly define the lifetimes. \nFor ex.:\n```rust\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n let a= \"yo\";\n let mut c: &str;\n { \n  let b= \"no\";\n  c = longest(&a,&b); //Which reference is returned from longest ? \n } //if c has the reference lifetime of b then this is where it becomes invalid \n \n} //if c has the reference lifetime of a then this is where it becomes invalid \n```\nThis code leads to an error at compile time, because the borrow checker is not sure if ``x`` or ``y`` will be returned, meaning it is not guaranteed for the caller of ``longest()``which lifetime it will have. \nThis is why we need to explicitly define the lifetimes for ``longest`` here to let the compiler know which lifetime is being returned.",536910830]],["^15",[792,"^O","^16",536903670]],["^15",[792,"^@",false,536903670]],["^15",[792,"^F",790,536903670]],["^15",[792,"^X",280,536903670]],["^15",[792,"^V",280,536903670]],["^15",[792,"^U",130,536904399]],["^15",[792,"^U",253,536904399]],["^15",[792,"^U",254,536908123]],["^15",[792,"^U",280,536904399]],["^15",[792,"^U",497,536904399]],["^15",[792,"^H",130,536916334]],["^15",[792,"^H",253,536916334]],["^15",[792,"^H",254,536916334]],["^15",[792,"^H",497,536916334]],["^15",[792,"^17",true,536903670]],["^15",[792,"^;","~u64b81e64-b018-4246-86f1-2534efe969bf",536903670]],["^15",[793,"^Q","*Static lifetime*\nApplying this lifetime to a [[Reference Type]] puts it in the binary and increases the size of it. But the reference is valid for the duration of entire program. \nStatic lifetime can only be applied to values that are known at compile time.\nFor ex.:\n```rust\nlet x: &’static str= \"yeee\";\n```\n\nAll [[str]] literals have the static lifetime anyways.",536916334]],["^15",[793,"^O","^16",536903827]],["^15",[793,"^@",false,536903827]],["^15",[793,"^F",795,536904887]],["^15",[793,"^X",280,536903827]],["^15",[793,"^V",280,536903827]],["^15",[793,"^U",253,536905226]],["^15",[793,"^U",268,536905226]],["^15",[793,"^U",280,536905226]],["^15",[793,"^H",253,536916334]],["^15",[793,"^H",268,536916334]],["^15",[793,"^17",true,536903827]],["^15",[793,"^;","~u64b8230c-dd81-4be5-96d0-57534e92160b",536903827]],["^15",[794,"^Q","Explicit definition of lifetimes\nWe use the same syntax as [[Generic Type]]s, however the key difference is that generic lifetime names need to be prefixed with the ``'`` letter, like ``'x`` and they aren't [[Generic Type]]s so they can't be used to replace them in the syntax.\n\nSyntax for [[Function]]s/ [[Method]]s :\n``\nfn <fn name><< ' + lifetime name 1>, < ' + lifetime name 2>,..., < ' + lifetime name n>(<param name 1>: <if param type & then, & ' + lifetime name>, ...)-> <if return type & then, & + ' + lifetime name> {...}\n``\nLifetime definitions on [[Function]] parameters are called *input lifetimes* while the return type lifetime definitions are called *output lifetimes*.\n\nFor ex.:\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\nThis function has only a single lifetime generic, so it will only infer a single lifetime from its args and expect the same from both the args. If the args have different lifetimes, then the smaller lifetime is inferred. \nHere, we are not changing the lifetime of ``longest``, rather only allowing certain lifetimes and letting the [[Borrow]] checker know which lifetimes will be used where. \n\nWe can only define lifetimes in [[Function]] Signatures, not in their bodies.\nFurthermore, when returning a reference type and defining a lifetime for it, the lifetime must be also applied to a reference parameter.\n\n* For [[Struct]]s:\nFor ex.:\n```rust\nstruct X<’a> {\n\tyo: &’a str,\n}\n//says the instance of struct X will only live as long as the string field yo lives.\n```\n\n* For [[Method]] implementation blocks:\n```rust\nimpl<’a> X<’a> {\n\tfn yo(&self) {…}\n}\n```",536910841]],["^15",[794,"^O","^16",536904293]],["^15",[794,"^@",false,536904293]],["^15",[794,"^F",792,536904293]],["^15",[794,"^X",280,536904293]],["^15",[794,"^V",280,536904293]],["^15",[794,"^U",130,536910842]],["^15",[794,"^U",131,536910842]],["^15",[794,"^U",242,536910842]],["^15",[794,"^U",254,536910842]],["^15",[794,"^U",280,536910842]],["^15",[794,"^U",497,536910842]],["^15",[794,"^H",130,536916334]],["^15",[794,"^H",131,536916334]],["^15",[794,"^H",242,536916334]],["^15",[794,"^H",254,536916334]],["^15",[794,"^H",497,536916334]],["^15",[794,"^17",true,536904293]],["^15",[794,"^;","~u64b825d1-f53b-4099-a5dd-4455a062132e",536904293]],["^15",[795,"^Q","*Lifetime Elision* Rules\n[[Function]]s and ``impl`` blocks always need a lifetime definition for [[Reference Type]]s. \n\nWe don't always need to explicitly define them, but if none of these rules can be applied then they need to be explicitly defined:\n*\tEach reference parameter in signature gets a separate lifetime. \n```rust\nfn yo(x: &str) {} //gets fn yo<’a>(x:&’a str) \nfn yo2(x: &str,y: &str){} //gets fn  yo<’a, ‘b>(x: &’a str, y: &’b str) \n//and so on\n``` \n\n*\tIf there’s exactly 1 reference parameter and it is given an explicit lifetime then the same lifetime is applied to the return type reference, if any.\n* If there are multiple *input lifetime* parameters, and one of them is ``&self`` or ``&mut self`` then the ``self``’s lifetime is applied to the return type reference. \n\nMultiple rules will be applied to the same signature if a single rule doesn’t make the signature valid.\nFor ex.:\n```rust\nStruct X{}\nimpl  X {\n\tfn yo(&self, x: &str) -> &str {…} \n}\n// This is not an error, as the 1st rule applies a lifetime to both the parameters and the 3rd rule applies the self’s lifetime to the return type. \n```",536905174]],["^15",[795,"^O","^16",536904887]],["^15",[795,"^@",false,536904887]],["^15",[795,"^F",794,536904887]],["^15",[795,"^X",280,536904887]],["^15",[795,"^V",280,536904887]],["^15",[795,"^U",130,536904940]],["^15",[795,"^U",253,536904940]],["^15",[795,"^U",280,536904940]],["^15",[795,"^H",130,536916334]],["^15",[795,"^H",253,536916334]],["^15",[795,"^17",true,536904887]],["^15",[795,"^;","~u64b829a7-1754-4c58-aade-665c9302343c",536904887]],["^15",[798,"^U",280,536905178]],["^15",[799,"^U",280,536905178]],["^15",[800,"^Q","",536905218]],["^15",[800,"^O","^16",536905218]],["^15",[800,"^@",false,536905218]],["^15",[800,"^F",793,536905218]],["^15",[800,"^X",280,536905218]],["^15",[800,"^V",280,536905218]],["^15",[800,"^U",280,536905219]],["^15",[800,"^17",true,536905218]],["^15",[800,"^;","~u64b82c6e-047c-4fb7-b279-96890a5184f3",536905218]],["^15",[801,"^U",131,536905254]],["^15",[802,"^U",131,536905254]],["^15",[803,"^12",2,536905300]],["^15",[804,"^K",1689871470011,536905302]],["^15",[804,"^[",806,536905311]],["^15",[804,"^O","^16",536905306]],["^15",[804,"^@",false,536905302]],["^15",[804,"^Y","testing framework",536905302]],["^15",[804,"^11","Testing Framework",536905302]],["^15",[804,"^B",1689883441180,536907972]],["^15",[804,"^;","~u64c20233-71cf-414a-8321-3b956e6694db",536916343]],["^15",[805,"^Q","Rust already has a testing framework built-in, this allows us to do *TDD*.",536905329]],["^15",[805,"^O","^16",536905307]],["^15",[805,"^@",false,536905307]],["^15",[805,"^F",804,536905307]],["^15",[805,"^X",804,536905307]],["^15",[805,"^V",804,536905307]],["^15",[805,"^U",804,536905308]],["^15",[805,"^?",["^ "],536905329]],["^15",[805,"^17",true,536905307]],["^15",[805,"^;","~u64b9646e-0096-4196-a4aa-bf18f28af5d1",536905307]],["^15",[806,"^3","- Rust already has a testing framework built-in, this allows us to do *TDD*.\n- Tests in rust are [[Function]] annotated with ``#[test]`` [[Macro Attribute]] inside a test [[Module]] which can be annotated with ``#[cfg(test)]``.\n  A test module is generated automatically for any new [[Cargo]] library created with ``cargo new <name> --lib``.\n  \n  Then to run all test functions in test [[Module]s we run ``cargo test``.\n  \n  For ex.:\n  ```rust\n  #[cfg(test)]\n  mod tests {\n      #[test]\n      fn it_works() {\n          let result = 2 + 2;\n          assert_eq!(result, 4);\n      }\n  }\n  ```\n  prints\n  ```sh\n  running 1 test\n  test tests::it_works ... ok\n  \n  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n  \n     Doc-tests <package name>\n  \n  running 0 tests\n  \n  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n  \n  ```\n  \n  ``0 measured`` is for benchmark Tests, which is only available on [[Nightly Rust]] right now. \n  ``0 ignored``  as we can ignore tests\n  ``0 filtered out`` as we can specify only certain tests to run by passing args to``cargo test``\n  \n  ``Doc-tests`` are Documentation Tests\n- Tests are written in 3 steps\n  * Set up any needed data or state using test functions and modules.\n  * Run the code we want to test with test ``cargo test``.\n  * Assert the results are what we expect using [[Assert]].\n- Failure\n  Tests can fail if [[Assert]]s fail or if a test [[Function]] [[Thread]] dies. \n  That is, each test is ran in a different thread and if a thread becomes unresponsive or dies (like when it calls [[Panic]]) it is marked as failed.\n- ``#[should_panic(expected= \"<optional string message>\")]``\n  If this [[Macro Attribute]] annotates any test [[Function]] then the test function should [[Panic]], if it panics then the test passes. \n  By specifying the ``expected`` arg with a [[String]], we constraint the panic's message to have the provided string as a substring.\n  For ex.:\n  ```rust\n  #[test]\n  #[should_panic(expected= \"hello\")]\n  fn yo() {\n   panic!(\"hello world\")\n  } //this test passes, as it panics, and the panic message has the string \"hello\" as a substring\n  ```\n- We can return [[Result Type]] from test functions. \n  If the test function returns ``T`` of ``Result<T,E>`` then it is assumed as success and if it returns ``E`` failure is assumed.\n  \n  For ex.:\n  ```rust\n  #[test]\n  fn yo() -> Result<(),String> {\n   if (2==3) {\n    Ok(());\n   }\n   else  {\n   Err(String::from(\"naa\"));\n   //we can use assert like so with Result return types, assert!(something.is_err()); \n  //where is_err is defined for Result Types, we can also use the ? operator like something? which immediately \n  // returns if Err() and returns the Err\n   }\n  }\n  ```\n  As we see, we can use [[Assert]] with [[Result Type]]s of normal [[Function]]s as ``.is_err()`` returns true if Result fails, as this [[Method]] is defined on Result. \n  \n  We can't use ``#[should_panic]`` with test functions that return Result Types.\n- Ignoring tests\n  We can ignore certain test [[Function]]s by using ``#[ignore]`` [[Macro Attribute]] .\n  For ex.:\n  ```rust\n  #[test]\n  #[ignore]\n  fn yo(){ }\n  //this test method will be ignored.\n  ```\n- [[Cargo]] test args\n  ``cargo test`` compiles the code in test mode and accepts some args, then it generates a test binary/executable which also accepts some args. Both of these take args and just running ``cargo test`` runs the compiler, then the test binary. So if we wish to pass CLI args to both of them we have to use a separator token, which is ``--``.\n  For ex.:\n  ```sh\n  cargo test --help \n  #is passed to the test runner, displays test options.\n  cargo test -- --help \n  #is passed to the test binary, displays test binary options.\n  ```\n  * ``cargo test -- --test-threads=1``: Sets the number of [[Thread]]s tests use. By default test functions run parallelly, meaning if they mustn't depend on each other's result. By setting the ``threads`` to 1 we serially run them.\n  * ``cargo test -- --show-output``: Prints any output printed by any function.\n  * ``cargo test <testname>``: Runs only tests whose function names have the ``<testname>`` as substring.\n  * ``cargo test -- --ignored`` :Runs only the ignore attributed tests.\n  * ``cargo test -- --include-ignored``: Runs all tests including ignored ones.\n  * ``cargo test --test <someTest>``: Runs the given file's tests, used with Integration Tests, so if ``<someTest>`` is ``x`` then it looks for ``<packageName>/tests/x.rs`` and runs all test functions inside ``x.rs``.\n- Test Categories and locations\n  * ``Unit Tests``: These test individual [[Function]]s/ [[Method]]s , covering all of them and ensuring they by theirselves work without issue. \n  * ``Integration Tests``: These test a feature, like if a [[Struct]] [[Method]] is correctly generating a new instance and doing all its startup tasks successfully. \n  \n  * The UT tests are put in their own [[Modules]] in the ``src/`` folder, by convention they must be put in the same ``.rs`` file for which they cover the test cases at the top in a [[Module]]. The module name and its test functions name could be anything.\n  We annotate the [[Module]] with ``#[cfg(test)]`` [[Macro Attribute]]. This attribute tells the Rust Compiler, it should only compile the given module when the ``Configuration`` of [[Cargo]] is provided with ``test``, i.e., ``cargo test`` is invoked.\n  \n  * UTs can freely access all private/public [[Access Modifier]] items in their file.\n  For ex.:\n  ```rust\n  pub fn add_two(a: i32) -> i32 {\n      internal_adder(a, 2)\n  }\n  \n  fn internal_adder(a: i32, b: i32) -> i32 {\n      a + b\n  }\n  \n  #[cfg(test)]\n  mod tests {\n      use super::*;\n  \n      #[test]\n      fn internal() {\n          assert_eq!(4, internal_adder(2, 2));\n      }\n  } //works\n  ```\n  \n  * Integration tests are ``.rs`` files defined inside ``<package name>/tests/`` directory. \n  Like so\n  ```\n  somepackage\n  ├── Cargo.lock\n  ├── Cargo.toml\n  ├── src\n  │   └── lib.rs\n  └── tests\n      └── integration_test.rs\n  ```\n  All ``.rs`` files directly inside ``tests/`` folder are executed by the test runner.\n  They test out functionalities and are created in their own crates (outside crate root) by the test runner. So they can only access public items of our crates.\n  For ex.:\n  In ``x/tests/it.rs`` where ``x`` is our package name,\n  ```rust\n  use x;\n  \n  #[test]\n  fn yo() { } //normal test method\n  ```\n  then running ``cargo test`` runs this IT.\n  \n  * Submodules in ITs\n  By default, all files directly inside the ``tests`` folder are ran and their test [[Function]]s executed. This means if we use some modules inside our IT files then they are executed by the test runner too, to solve this we put them in a ``.../tests/<modname>/mod.rs`` file and they aren't executed separately, so the IT file can use them directly.\n  For ex.:\n  If we have a [[Module]] ``yo`` then we will put it in ``tests/yo/mod.rs``\n  ```rust\n  mod yo {}\n  ```\n  and use it in ``tests/someFile.rs`` with\n  ```rust\n  mod yo;\n  ```\n  \n  * IT can only work with library crates and not binary crates. This is because it is its own crate and a binary crate compiles to an executable directly with its content not exposed. This is why it is recommended in [[Module System]] to use a library crate with a binary crate when we only need a binary crate.\n-",536907974]],["^15",[806,"^18","~m1689883441915",536907973]],["^15",[806,"^Z","pages/Testing Framework.md",536905311]],["^15",[807,"^Q","Tests are written in 3 steps\n* Set up any needed data or state using test functions and modules.\n* Run the code we want to test with test ``cargo test``.\n* Assert the results are what we expect using [[Assert]].",536905621]],["^15",[807,"^O","^16",536905332]],["^15",[807,"^@",false,536905332]],["^15",[807,"^F",808,536905345]],["^15",[807,"^X",804,536905332]],["^15",[807,"^V",804,536905332]],["^15",[807,"^U",804,536905612]],["^15",[807,"^U",820,536905612]],["^15",[807,"^?",["^ "],536905621]],["^15",[807,"^H",820,536905621]],["^15",[807,"^17",true,536905332]],["^15",[807,"^;","~u64b96bf8-fe9d-4668-901f-cfe0ca27c6c5",536905332]],["^15",[808,"^Q","Tests in rust are [[Function]] annotated with ``#[test]`` [[Macro Attribute]] inside a test [[Module]] which can be annotated with ``#[cfg(test)]``.\nA test module is generated automatically for any new [[Cargo]] library created with ``cargo new <name> --lib``.\n\nThen to run all test functions in test [[Module]s we run ``cargo test``.\n\nFor ex.:\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n```\nprints\n```sh\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests <package name>\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\n``0 measured`` is for benchmark Tests, which is only available on [[Nightly Rust]] right now. \n``0 ignored``  as we can ignore tests\n``0 filtered out`` as we can specify only certain tests to run by passing args to``cargo test``\n\n``Doc-tests`` are Documentation Tests",536907111]],["^15",[808,"^O","^16",536905345]],["^15",[808,"^@",false,536905345]],["^15",[808,"^F",805,536905345]],["^15",[808,"^X",804,536905345]],["^15",[808,"^V",804,536905345]],["^15",[808,"^U",45,536905676]],["^15",[808,"^U",130,536905676]],["^15",[808,"^U",530,536905676]],["^15",[808,"^U",804,536905676]],["^15",[808,"^U",811,536905676]],["^15",[808,"^U",821,536905676]],["^15",[808,"^?",["^ "],536907111]],["^15",[808,"^H",45,536907111]],["^15",[808,"^H",130,536907111]],["^15",[808,"^H",530,536907111]],["^15",[808,"^H",811,536907111]],["^15",[808,"^H",821,536907111]],["^15",[808,"^17",true,536905345]],["^15",[808,"^;","~u64b96c14-ce39-4853-9852-c12471d7fdfa",536905345]],["^15",[810,"^Q","Failure\nTests can fail if [[Assert]]s fail or if a test [[Function]] [[Thread]] dies. \nThat is, each test is ran in a different thread and if a thread becomes unresponsive or dies (like when it calls [[Panic]]) it is marked as failed.",536905794]],["^15",[810,"^O","^16",536905386]],["^15",[810,"^@",false,536905386]],["^15",[810,"^F",807,536905386]],["^15",[810,"^X",804,536905386]],["^15",[810,"^V",804,536905386]],["^15",[810,"^U",130,536905785]],["^15",[810,"^U",219,536905785]],["^15",[810,"^U",804,536905785]],["^15",[810,"^U",820,536905785]],["^15",[810,"^U",822,536905785]],["^15",[810,"^?",["^ "],536905794]],["^15",[810,"^H",130,536905794]],["^15",[810,"^H",219,536905794]],["^15",[810,"^H",820,536905794]],["^15",[810,"^H",822,536905794]],["^15",[810,"^17",true,536905386]],["^15",[810,"^;","~u64b96c35-3fed-4a08-ba85-29dfbaf576e0",536905386]],["^15",[811,"^K",1689873521014,536905390]],["^15",[811,"^[",813,536905399]],["^15",[811,"^O","^16",536905394]],["^15",[811,"^@",false,536905390]],["^15",[811,"^Y","macro attribute",536905390]],["^15",[811,"^11","Macro Attribute",536905390]],["^15",[811,"^B",1689873971181,536905519]],["^15",[811,"^;","~u64c20233-2785-4378-8f49-a9f908fecbdf",536916346]],["^15",[812,"^Q","Attributes are metadata about pieces of Rust code.\nFor ex.:\n```rust\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n```",536905519]],["^15",[812,"^O","^16",536905395]],["^15",[812,"^@",false,536905395]],["^15",[812,"^F",811,536905395]],["^15",[812,"^X",811,536905395]],["^15",[812,"^V",811,536905395]],["^15",[812,"^U",811,536905513]],["^15",[812,"^?",["^ "],536905519]],["^15",[812,"^17",true,536905395]],["^15",[812,"^;","~u64b96c73-4171-41f1-890b-9b278eea1feb",536905395]],["^15",[813,"^3","- Attributes are metadata about pieces of Rust code.\n  For ex.:\n  ```rust\n      #[test]\n      fn it_works() {\n          let result = 2 + 2;\n          assert_eq!(result, 4);\n      }\n  ```\n-",536905521]],["^15",[813,"^18","~m1689873971407",536905520]],["^15",[813,"^Z","pages/Macro Attribute.md",536905399]],["^15",[814,"^Q","",536905408]],["^15",[814,"^O","^16",536905408]],["^15",[814,"^@",false,536905408]],["^15",[814,"^F",812,536905408]],["^15",[814,"^X",811,536905408]],["^15",[814,"^V",811,536905408]],["^15",[814,"^U",811,536905409]],["^15",[814,"^?",["^ "],536905408]],["^15",[814,"^17",true,536905408]],["^15",[814,"^;","~u64b96c98-9a19-4cdc-8349-90e6c66c946e",536905408]],["^15",[818,"^Q","~``Deref`` and ``DerefMut``\nTraits defined in ``std::ops``.\n\n* ``Deref``: Any [[Data Type]] that implements this trait can use the dereference [[Operator]] ``*``. \n[[Pointer]]s and non-primitive [[Reference Type]]s implement it in [[Standard Library]] .\n\nThe main method of this trait is the ``deref()`` [[Method]] which is called when value of the implementing type is getting dereferenced.\n``Deref`` and its ``deref()`` return immutable [[Reference Type]]s.\n\n* Since [[Pointer]]s implement the ``Deref`` [[Trait]], they can be dereferenced.\nFor ex.:\n```rust\nfn main {\n let x = Box::new(2);\n println!(\"{}\", *x);\n}\n```\nThat is also to say, a pointer has a [[Reference Type]] to the data (as the data is stored in a separate memory address from the pointer itself). Since Reference values can't be used without being dereferenced we need to use the ``*`` [[Operator]].\n\nWe can implement this Trait for our types too,\nFor ex.:\n```rust\nuse std::ops::Deref;\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target { //notice dereference returns the &T\n        &self.0\n    }\n}\n\nfn main() {\n let x = MyBox::new(2);\n *x; //returns 2\n //is the same as\n *(x.deref()); //also returns 2\n}\n```\nusing an [[Associated Type]] ``target``.\nThe reason ``deref()`` [[Method]] returns a [[Reference Type]] is simply because if it returned the value directly, it would invoke [[Copy or Move]] and transfer the [[Ownership]] out of ``MyBox``. \nThe main goal dereferencing is to reach a primitive type, as primitive types have the concrete implementation for how actually dereferencing works without transferring [[Ownership]] or [[Copy or Move]]ing. \nSo if our type ``T`` dereferences into a value of type ``K`` (i.e., ``T``'s ``Deref`` trait's ``deref`` method returned ``&K``) which dereferences into a primitive type such as ``i32`` then the dereference chain to go from ``&T`` to ``i32`` would be\n``*<T value>``->``*<K value>``->``*<i32 value>`` where the dereference of ``*<i32 value>`` is defined internally.\n\nThe feature by which Rust automatically goes from ``*<T value>`` to ``<i32 value>`` is called [[Deref Coercion]].```\n\n* ``DerefMut``:  This trait and its ``deref()`` method return mutable references.\nRust's [[Deref Coercion]] uses the following chain\n\n* From ``&T`` to ``&U`` if ``T: Deref<Target=U>``, i.e., ``T`` implements the ``Deref`` trait. and returns a value of type ``&U`` from its ``deref()`` [[Method]].\n \n* From ``&mut T`` to ``&mut U`` if ``T: DerefMut<Target=U>``\n* From ``&mut T`` to ``&U`` if ``T: Deref<Target=U>``",536909941]],["^15",[818,"^O","^16",536905475]],["^15",[818,"^@",false,536905475]],["^15",[818,"^F",419,536905475]],["^15",[818,"^X",414,536905475]],["^15",[818,"^V",414,536905475]],["^15",[818,"^U",93,536909914]],["^15",[818,"^U",148,536909914]],["^15",[818,"^U",206,536909914]],["^15",[818,"^U",253,536909914]],["^15",[818,"^U",255,536909914]],["^15",[818,"^U",256,536909914]],["^15",[818,"^U",414,536909914]],["^15",[818,"^U",461,536909914]],["^15",[818,"^U",497,536909914]],["^15",[818,"^U",878,536909914]],["^15",[818,"^U",894,536909914]],["^15",[818,"^H",93,536916346]],["^15",[818,"^H",148,536916346]],["^15",[818,"^H",206,536916346]],["^15",[818,"^H",253,536916346]],["^15",[818,"^H",255,536916346]],["^15",[818,"^H",256,536916346]],["^15",[818,"^H",414,536916346]],["^15",[818,"^H",461,536916346]],["^15",[818,"^H",497,536916346]],["^15",[818,"^H",878,536916346]],["^15",[818,"^H",894,536916346]],["^15",[818,"^17",true,536905475]],["^15",[818,"^;","~u64b96d34-dba2-41d1-8f99-9a7e95f7c75c",536905475]],["^15",[820,"^K",1689874239697,536905611]],["^15",[820,"^[",825,536905806]],["^15",[820,"^O","^16",536905801]],["^15",[820,"^@",false,536905611]],["^15",[820,"^Y","assert",536905611]],["^15",[820,"^11","Assert",536905611]],["^15",[820,"^B",1689876181745,536906093]],["^15",[820,"^;","~u64b96f3f-680a-4d2a-84fa-0c2588eb1453",536905611]],["^15",[821,"^K",1689874542896,536905675]],["^15",[821,"^@",false,536905675]],["^15",[821,"^Y","nightly rust",536905675]],["^15",[821,"^11","Nightly Rust",536905675]],["^15",[821,"^B",1689874542896,536905675]],["^15",[821,"^;","~u64b9706e-fc20-488b-b0de-8393306359a3",536905675]],["^15",[822,"^K",1689875311510,536905780]],["^15",[822,"^[",976,536912071]],["^15",[822,"^O","^16",536911958]],["^15",[822,"^@",false,536905780]],["^15",[822,"^Y","thread",536905780]],["^15",[822,"^11","Thread",536905780]],["^15",[822,"^B",1690065660488,536912754]],["^15",[822,"^;","~u64c20233-0649-476c-911f-1551fd71c9c9",536916352]],["^15",[823,"^Q","~``#[should_panic(expected= \"<optional string message>\")]``\nIf this [[Macro Attribute]] annotates any test [[Function]] then the test function should [[Panic]], if it panics then the test passes. \nBy specifying the ``expected`` arg with a [[String]], we constraint the panic's message to have the provided string as a substring.\nFor ex.:\n```rust\n#[test]\n#[should_panic(expected= \"hello\")]\nfn yo() {\n panic!(\"hello world\")\n} //this test passes, as it panics, and the panic message has the string \"hello\" as a substring\n```",536906313]],["^15",[823,"^O","^16",536905797]],["^15",[823,"^@",false,536905797]],["^15",[823,"^F",810,536905797]],["^15",[823,"^X",804,536905797]],["^15",[823,"^V",804,536906257]],["^15",[823,"^U",118,536906265]],["^15",[823,"^U",130,536906265]],["^15",[823,"^U",219,536906265]],["^15",[823,"^U",804,536906265]],["^15",[823,"^U",811,536906265]],["^15",[823,"^?",["^ "],536906313]],["^15",[823,"^H",118,536906313]],["^15",[823,"^H",130,536906313]],["^15",[823,"^H",219,536906313]],["^15",[823,"^H",811,536906313]],["^15",[823,"^17",true,536905797]],["^15",[823,"^;","~u64b97390-3f34-4911-8ac8-e68b6f9c0d51",536905797]],["^15",[824,"^Q","An assert is simply a requirement, that the condition being checked must be true. If it isn't, this leads to a [[Panic]].\n\nWe use asserts using the ``assert!`` [[Macro]].\n\nFor ex.:\n```rust\n    fn exploration() {\n        assert!(2 + 2 == 4);\n    }\n```",536905889]],["^15",[824,"^O","^16",536905802]],["^15",[824,"^@",false,536905802]],["^15",[824,"^F",820,536905802]],["^15",[824,"^X",820,536905802]],["^15",[824,"^V",820,536905802]],["^15",[824,"^U",219,536905844]],["^15",[824,"^U",246,536905844]],["^15",[824,"^U",820,536905844]],["^15",[824,"^?",["^ "],536905889]],["^15",[824,"^H",219,536905889]],["^15",[824,"^H",246,536905889]],["^15",[824,"^17",true,536905802]],["^15",[824,"^;","~u64b973a6-8da2-468b-975e-46ad5532af37",536905802]],["^15",[825,"^3","- An assert is simply a requirement, that the condition being checked must be true. If it isn't, this leads to a [[Panic]].\n  \n  We use asserts using the ``assert!`` [[Macro]].\n  \n  For ex.:\n  ```rust\n      fn exploration() {\n          assert!(2 + 2 == 4);\n      }\n  ```\n- Similarly there are other variants \n  * ``assert_eq!(<obj 1>,<obj 2>)``: If ``obj 1`` == ``obj 2``.\n  * ``assert_ne!(<obj 1>,<obj 2>)``: If ``obj 1`` != ``obj 2``.\n- Custom failure text\n  After the required arguments to all ``assert`` [[Macro]]s , the [[String]] passed is given to ``format!`` [[Macro]] and it prints the given string.\n-",536906099]],["^15",[825,"^18","~m1689876183367",536906098]],["^15",[825,"^Z","pages/Assert.md",536905806]],["^15",[826,"^Q","Similarly there are other variants \n* ``assert_eq!(<obj 1>,<obj 2>)``: If ``obj 1`` == ``obj 2``.\n* ``assert_ne!(<obj 1>,<obj 2>)``: If ``obj 1`` != ``obj 2``.",536906038]],["^15",[826,"^O","^16",536905889]],["^15",[826,"^@",false,536905889]],["^15",[826,"^F",824,536905889]],["^15",[826,"^X",820,536905889]],["^15",[826,"^V",820,536905889]],["^15",[826,"^U",820,536905890]],["^15",[826,"^?",["^ "],536906038]],["^15",[826,"^17",true,536905889]],["^15",[826,"^;","~u64b97424-978d-4798-847e-18f36173f265",536905889]],["^15",[827,"^Q","Custom failure text\nAfter the required arguments to all ``assert`` [[Macro]]s , the [[String]] passed is given to ``format!`` [[Macro]] and it prints the given string.",536906093]],["^15",[827,"^O","^16",536905920]],["^15",[827,"^@",false,536905920]],["^15",[827,"^F",826,536906028]],["^15",[827,"^X",820,536905920]],["^15",[827,"^V",820,536905920]],["^15",[827,"^U",118,536906081]],["^15",[827,"^U",246,536906081]],["^15",[827,"^U",820,536906081]],["^15",[827,"^?",["^ "],536906093]],["^15",[827,"^H",118,536906093]],["^15",[827,"^H",246,536906093]],["^15",[827,"^17",true,536905920]],["^15",[827,"^;","~u64b9743d-3fb0-4929-9bee-0199672dd4af",536905920]],["^15",[828,"^K",1689875747772,536905959]],["^15",[828,"^[",830,536905972]],["^15",[828,"^O","^16",536905966]],["^15",[828,"^@",false,536905959]],["^15",[828,"^Y","super",536905959]],["^15",[828,"^11","super",536905959]],["^15",[828,"^B",1689875791419,536906004]],["^15",[828,"^;","~u64b97523-81f5-4236-8270-90282e94f6b3",536905959]],["^15",[829,"^Q","This keyword can be only at the starting of a path, when used it goes one up in the hierarchy of modules where the current [[Module]] / [[Crate]] is the current position. \nFor ex.:\n```rust\nmod x {\n  pub mod y {\n      pub mod z {\n          pub mod k {\n              pub fn aye() {\n                  super::super::super::yo();\n              }\n          }\n      }\n  }\n- pub fn yo() {}\n}\n- fn main() {\n  crate::x::y::z::k::aye(); //works\n}\n```",536905970]],["^15",[829,"^O","^16",536905967]],["^15",[829,"^@",false,536905967]],["^15",[829,"^F",828,536905967]],["^15",[829,"^X",828,536905967]],["^15",[829,"^V",828,536905967]],["^15",[829,"^U",530,536905971]],["^15",[829,"^U",577,536905971]],["^15",[829,"^U",828,536905971]],["^15",[829,"^?",["^ "],536905967]],["^15",[829,"^H",530,536905970]],["^15",[829,"^H",577,536905970]],["^15",[829,"^17",true,536905967]],["^15",[829,"^;","~u64b97530-3102-4a1a-bfaf-1ae8928c7f60",536905967]],["^15",[830,"^3","- This keyword can be only at the starting of a path, when used it goes one up in the hierarchy of modules where the current [[Module]] / [[Crate]] is the current position. \n  For ex.:\n  ```rust\n  mod x {\n    pub mod y {\n        pub mod z {\n            pub mod k {\n                pub fn aye() {\n                    super::super::super::yo();\n                }\n            }\n        }\n    }\n  - pub fn yo() {}\n  }\n  - fn main() {\n    crate::x::y::z::k::aye(); //works\n  }\n  ```\n- Similarly, by using ``use super::*`` with [[use]], we essentially open an entire parent namespace into the current namespace.\n-",536906007]],["^15",[830,"^18","~m1689875791972",536906006]],["^15",[830,"^Z","pages/super.md",536905972]],["^15",[831,"^Q","Similarly, by using ``use super::*`` with [[use]], we essentially open an entire parent namespace into the current namespace.",536906004]],["^15",[831,"^O","^16",536905975]],["^15",[831,"^@",false,536905975]],["^15",[831,"^F",829,536905975]],["^15",[831,"^X",828,536905975]],["^15",[831,"^V",828,536905975]],["^15",[831,"^U",90,536905989]],["^15",[831,"^U",828,536905989]],["^15",[831,"^?",["^ "],536906004]],["^15",[831,"^H",90,536906004]],["^15",[831,"^17",true,536905975]],["^15",[831,"^;","~u64b97534-a751-4393-9777-7da37af31070",536905975]],["^15",[832,"^Q","",536906004]],["^15",[832,"^O","^16",536906004]],["^15",[832,"^@",false,536906004]],["^15",[832,"^F",831,536906004]],["^15",[832,"^X",828,536906004]],["^15",[832,"^V",828,536906004]],["^15",[832,"^U",828,536906005]],["^15",[832,"^?",["^ "],536906004]],["^15",[832,"^17",true,536906004]],["^15",[832,"^;","~u64b9754f-287a-499b-97e0-6382ad4a17d8",536906004]],["^15",[833,"^U",820,536906013]],["^15",[835,"^Q","",536906096]],["^15",[835,"^O","^16",536906096]],["^15",[835,"^@",false,536906096]],["^15",[835,"^F",827,536906096]],["^15",[835,"^X",820,536906096]],["^15",[835,"^V",820,536906096]],["^15",[835,"^U",820,536906097]],["^15",[835,"^?",["^ "],536906096]],["^15",[835,"^17",true,536906096]],["^15",[835,"^;","~u64b976d6-9a79-412f-a763-64185dc916d5",536906096]],["^15",[838,"^Q","We can return [[Result Type]] from test functions. \nIf the test function returns ``T`` of ``Result<T,E>`` then it is assumed as success and if it returns ``E`` failure is assumed.\n\nFor ex.:\n```rust\n#[test]\nfn yo() -> Result<(),String> {\n if (2==3) {\n  Ok(());\n }\n else  {\n Err(String::from(\"naa\"));\n //we can use assert like so with Result return types, assert!(something.is_err()); \n//where is_err is defined for Result Types, we can also use the ? operator like something? which immediately \n// returns if Err() and returns the Err\n }\n}\n```\nAs we see, we can use [[Assert]] with [[Result Type]]s of normal [[Function]]s as ``.is_err()`` returns true if Result fails, as this [[Method]] is defined on Result. \n\nWe can't use ``#[should_panic]`` with test functions that return Result Types.",536906611]],["^15",[838,"^O","^16",536906316]],["^15",[838,"^@",false,536906316]],["^15",[838,"^F",823,536906316]],["^15",[838,"^X",804,536906316]],["^15",[838,"^V",804,536906316]],["^15",[838,"^U",130,536906581]],["^15",[838,"^U",497,536906581]],["^15",[838,"^U",687,536906581]],["^15",[838,"^U",804,536906581]],["^15",[838,"^U",820,536906581]],["^15",[838,"^?",["^ "],536906611]],["^15",[838,"^H",130,536906611]],["^15",[838,"^H",497,536906611]],["^15",[838,"^H",687,536906611]],["^15",[838,"^H",820,536906611]],["^15",[838,"^17",true,536906316]],["^15",[838,"^;","~u64b9806f-20f0-4eda-8ffb-59c310d522da",536906316]],["^15",[839,"^Q","",536906332]],["^15",[839,"^O","^16",536906332]],["^15",[839,"^@",false,536906332]],["^15",[839,"^?",["^ "],536906332]],["^15",[839,"^17",true,536906332]],["^15",[839,"^;","~u64b9807e-f4ca-40cc-97df-ad590148b897",536906332]],["^15",[840,"^Q","Test Categories and locations\n* ``Unit Tests``: These test individual [[Function]]s/ [[Method]]s , covering all of them and ensuring they by theirselves work without issue. \n* ``Integration Tests``: These test a feature, like if a [[Struct]] [[Method]] is correctly generating a new instance and doing all its startup tasks successfully. \n\n* The UT tests are put in their own [[Modules]] in the ``src/`` folder, by convention they must be put in the same ``.rs`` file for which they cover the test cases at the top in a [[Module]]. The module name and its test functions name could be anything.\nWe annotate the [[Module]] with ``#[cfg(test)]`` [[Macro Attribute]]. This attribute tells the Rust Compiler, it should only compile the given module when the ``Configuration`` of [[Cargo]] is provided with ``test``, i.e., ``cargo test`` is invoked.\n\n* UTs can freely access all private/public [[Access Modifier]] items in their file.\nFor ex.:\n```rust\npub fn add_two(a: i32) -> i32 {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        assert_eq!(4, internal_adder(2, 2));\n    }\n} //works\n```\n\n* Integration tests are ``.rs`` files defined inside ``<package name>/tests/`` directory. \nLike so\n```\nsomepackage\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    └── integration_test.rs\n```\nAll ``.rs`` files directly inside ``tests/`` folder are executed by the test runner.\nThey test out functionalities and are created in their own crates (outside crate root) by the test runner. So they can only access public items of our crates.\nFor ex.:\nIn ``x/tests/it.rs`` where ``x`` is our package name,\n```rust\nuse x;\n\n#[test]\nfn yo() { } //normal test method\n```\nthen running ``cargo test`` runs this IT.\n\n* Submodules in ITs\nBy default, all files directly inside the ``tests`` folder are ran and their test [[Function]]s executed. This means if we use some modules inside our IT files then they are executed by the test runner too, to solve this we put them in a ``.../tests/<modname>/mod.rs`` file and they aren't executed separately, so the IT file can use them directly.\nFor ex.:\nIf we have a [[Module]] ``yo`` then we will put it in ``tests/yo/mod.rs``\n```rust\nmod yo {}\n```\nand use it in ``tests/someFile.rs`` with\n```rust\nmod yo;\n```\n\n* IT can only work with library crates and not binary crates. This is because it is its own crate and a binary crate compiles to an executable directly with its content not exposed. This is why it is recommended in [[Module System]] to use a library crate with a binary crate when we only need a binary crate.",536907972]],["^15",[840,"^O","^16",536906385]],["^15",[840,"^@",false,536906385]],["^15",[840,"^F",856,536907039]],["^15",[840,"^X",804,536906385]],["^15",[840,"^V",804,536907768]],["^15",[840,"^U",45,536907963]],["^15",[840,"^U",130,536907963]],["^15",[840,"^U",242,536907963]],["^15",[840,"^U",497,536907963]],["^15",[840,"^U",530,536907963]],["^15",[840,"^U",570,536907963]],["^15",[840,"^U",583,536907963]],["^15",[840,"^U",804,536907963]],["^15",[840,"^U",811,536907963]],["^15",[840,"^U",866,536907963]],["^15",[840,"^?",["^ "],536907972]],["^15",[840,"^H",45,536907972]],["^15",[840,"^H",130,536907972]],["^15",[840,"^H",242,536907972]],["^15",[840,"^H",497,536907972]],["^15",[840,"^H",530,536907972]],["^15",[840,"^H",570,536907972]],["^15",[840,"^H",583,536907972]],["^15",[840,"^H",811,536907972]],["^15",[840,"^H",866,536907972]],["^15",[840,"^17",true,536906385]],["^15",[840,"^;","~u64b980e2-2ee5-4a89-bdb4-9db2357b3d2c",536906385]],["^15",[841,"^Q","Ignoring tests\nWe can ignore certain test [[Function]]s by using ``#[ignore]`` [[Macro Attribute]] .\nFor ex.:\n```rust\n#[test]\n#[ignore]\nfn yo(){ }\n//this test method will be ignored.\n```",536906691]],["^15",[841,"^O","^16",536906614]],["^15",[841,"^@",false,536906614]],["^15",[841,"^F",838,536906614]],["^15",[841,"^X",804,536906614]],["^15",[841,"^V",804,536906614]],["^15",[841,"^U",130,536906667]],["^15",[841,"^U",804,536906667]],["^15",[841,"^U",811,536906667]],["^15",[841,"^?",["^ "],536906691]],["^15",[841,"^H",130,536906691]],["^15",[841,"^H",811,536906691]],["^15",[841,"^17",true,536906614]],["^15",[841,"^;","~u64b9829f-ce81-4b46-b9e7-8a10e7f4c00d",536906614]],["^15",[842,"^U",804,536906624]],["^15",[843,"^U",804,536906624]],["^15",[844,"^U",804,536906624]],["^15",[845,"^U",804,536906624]],["^15",[846,"^U",804,536906624]],["^15",[847,"^U",804,536906624]],["^15",[848,"^U",804,536906624]],["^15",[849,"^U",804,536906624]],["^15",[856,"^Q","[[Cargo]] test args\n``cargo test`` compiles the code in test mode and accepts some args, then it generates a test binary/executable which also accepts some args. Both of these take args and just running ``cargo test`` runs the compiler, then the test binary. So if we wish to pass CLI args to both of them we have to use a separator token, which is ``--``.\nFor ex.:\n```sh\ncargo test --help \n#is passed to the test runner, displays test options.\ncargo test -- --help \n#is passed to the test binary, displays test binary options.\n```\n* ``cargo test -- --test-threads=1``: Sets the number of [[Thread]]s tests use. By default test functions run parallelly, meaning if they mustn't depend on each other's result. By setting the ``threads`` to 1 we serially run them.\n* ``cargo test -- --show-output``: Prints any output printed by any function.\n* ``cargo test <testname>``: Runs only tests whose function names have the ``<testname>`` as substring.\n* ``cargo test -- --ignored`` :Runs only the ignore attributed tests.\n* ``cargo test -- --include-ignored``: Runs all tests including ignored ones.\n* ``cargo test --test <someTest>``: Runs the given file's tests, used with Integration Tests, so if ``<someTest>`` is ``x`` then it looks for ``<packageName>/tests/x.rs`` and runs all test functions inside ``x.rs``.",536907696]],["^15",[856,"^O","^16",536906694]],["^15",[856,"^@",false,536906694]],["^15",[856,"^F",841,536906694]],["^15",[856,"^X",804,536906694]],["^15",[856,"^V",804,536906694]],["^15",[856,"^U",45,536906724]],["^15",[856,"^U",804,536906724]],["^15",[856,"^U",822,536906724]],["^15",[856,"^?",["^ "],536907696]],["^15",[856,"^H",45,536907696]],["^15",[856,"^H",822,536907696]],["^15",[856,"^17",true,536906694]],["^15",[856,"^;","~u64b98303-6654-4788-9743-9cc5ce1463bf",536906694]],["^15",[857,"^U",804,536906906]],["^15",[858,"^U",804,536906906]],["^15",[859,"^U",804,536906906]],["^15",[860,"^U",804,536906906]],["^15",[861,"^U",804,536906906]],["^15",[862,"^U",804,536907028]],["^15",[863,"^U",804,536907028]],["^15",[864,"^U",804,536907040]],["^15",[865,"^U",804,536907040]],["^15",[866,"^K",1689882377174,536907219]],["^15",[866,"^@",false,536907219]],["^15",[866,"^Y","modules",536907219]],["^15",[866,"^11","Modules",536907219]],["^15",[866,"^B",1689882377174,536907219]],["^15",[866,"^;","~u64b98f09-c882-419a-9848-1f7b47c47c84",536907219]],["^15",[867,"^Q","",536907591]],["^15",[867,"^O","^16",536907591]],["^15",[867,"^@",false,536907591]],["^15",[867,"^F",840,536907768]],["^15",[867,"^X",804,536907591]],["^15",[867,"^V",804,536907591]],["^15",[867,"^U",804,536907592]],["^15",[867,"^?",["^ "],536907591]],["^15",[867,"^17",true,536907591]],["^15",[867,"^;","~u64b990e9-4554-403c-be28-8e1f575eb80e",536907591]],["^15",[868,"^Q","Reading environment args and environment variables\nTo do so,\n```rust\nuse std::env;\n\nfn main() {\nlet values: Vec<String>= env::args().collect();\n//puts env args as String objects into values.\nlet val= env::var(\"MYENV_VAR\");\nlet isOk= val.is_ok(); \n//reads the given env var and returns Result in val. .is_ok() returns true if the Result is Ok().\n\n}\n```\nTo pass env args,\n\n``cargo run arg1 arg2``to [[Cargo]]. \n\nSometimes env args can fail due to Unicode issues. To solve that we can use ``.args_os()`` instead, this returns values of ``OsString`` [[Data Type]].",536908088]],["^15",[868,"^O","^16",536907976]],["^15",[868,"^@",false,536907976]],["^15",[868,"^F",571,536907976]],["^15",[868,"^X",28,536907976]],["^15",[868,"^V",28,536907976]],["^15",[868,"^U",28,536908057]],["^15",[868,"^U",45,536908057]],["^15",[868,"^U",148,536908057]],["^15",[868,"^H",45,536916343]],["^15",[868,"^H",148,536916343]],["^15",[868,"^17",true,536907976]],["^15",[868,"^;","~u64b99797-c61b-4bd2-a4a9-3adc2ced62c1",536907976]],["^15",[869,"^Q","[[Concurrency or Parallelism]]",536914291]],["^15",[869,"^O","^16",536908061]],["^15",[869,"^@",false,536908061]],["^15",[869,"^F",921,536908132]],["^15",[869,"^X",28,536908061]],["^15",[869,"^V",28,536908061]],["^15",[869,"^U",28,536911879]],["^15",[869,"^U",971,536911879]],["^15",[869,"^H",971,536916343]],["^15",[869,"^17",true,536908061]],["^15",[869,"^;","~u64b997e2-6b63-46ab-9623-0258d85fe004",536908061]],["^15",[870,"^12",2,536908092]],["^15",[873,"^3","- [[Interior Mutability Pattern]]\n-\n-",536914492]],["^15",[873,"~:file/created-at",1690033164224,536908096]],["^15",[873,"^18","~m1690127588068",536914491]],["^15",[873,"^Z","pages/Borrow.md",536910761]],["^15",[874,"^Q","[[Interior Mutability Pattern]]",536914489]],["^15",[874,"^O","^16",536908096]],["^15",[874,"^F",254,536908096]],["^15",[874,"^X",254,536908096]],["^15",[874,"^V",254,536908096]],["^15",[874,"^U",254,536914490]],["^15",[874,"^U",1011,536914490]],["^15",[874,"^?",["^ "],536914489]],["^15",[874,"^H",1011,536914489]],["^15",[874,"^17",true,536908096]],["^15",[874,"^;","~u64bbdc0c-8580-453f-a19b-4f23c0cf1b67",536908096]],["^15",[875,"^Q","",536908096]],["^15",[875,"^O","^16",536908096]],["^15",[875,"^F",957,536911045]],["^15",[875,"^X",254,536908096]],["^15",[875,"^V",254,536908096]],["^15",[875,"^U",254,536908096]],["^15",[875,"^17",true,536908096]],["^15",[875,"^;","~u64bbdc0c-7983-4df6-84fa-3dea7398d354",536908096]],["^15",[876,"^3","- The simplest Smart [[Pointer]] in Rust. It has the least overhead and provides a simple way to store a value on the heap whilst the pointer remains on the stack.\n  \n  For ex.:\n  ```rust\n  fn main() {\n      let b = Box::new(5);\n      println!(\"b = {}\", b); //prints 5\n  } //automatically gets deallocated (along with the value) at the end of the scope.\n  ```\n- *Recursive [[Data Type]]s*\n  A recursive data type is one which has its own type in its fields. \n  For ex.:\n  A *Cons List*, this is a data structure in *Lisp* and in Rust could be represented through this [[Enum]]\n  \n  ```rust\n  enum List {\n   Cons(i32, List),\n   Nil\n  }\n  \n  fn main() {\n   let x = List::Cons(1, List::Cons(2, List::Cons(3, List::Nil));\n  }\n  ```\n  This is a recursive data type, however such types are an error in Rust as the compiler needs to know exactly how much size each type takes. However, here if it tries to figure out the size it will go into an infinite loop like so\n  ![image.png](../assets/image_1689962545952_0.png)\n  \n  A simple fix to store such types is by using the ``Box`` [[Pointer]] as Rust knows the size of a pointer at compile time and hence does not need to recurse the type definition.\n  ![A finite Cons list](https://doc.rust-lang.org/book/img/trpl15-02.svg)\n  Making our code like so\n  \n  ```rust\n  enum List {\n   Cons(i32, Box<List>),\n   Nil\n  }\n  \n  fn main() {\n   let x = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, List::Nil)))));\n  }\n  ```\n-\n-",536908098]],["^15",[876,"^1=",1690033164279,536908098]],["^15",[876,"^18","~m1689962829840",536908099]],["^15",[876,"^Z","pages/Box%3CT%3E.md",536908098]],["^15",[877,"^K",1690033164276,536908098]],["^15",[877,"^[",876,536908098]],["^15",[877,"^@",false,536908098]],["^15",[877,"^Y","box<t>",536908098]],["^15",[877,"^11","Box<T>",536908098]],["^15",[877,"^B",1690033164276,536908098]],["^15",[877,"^;","~u64c20233-cae8-4507-a127-636b85bfc9ca",536916340]],["^15",[878,"^K",1690033164278,536908098]],["^15",[878,"^[",902,536908108]],["^15",[878,"^@",false,536908098]],["^15",[878,"^Y","pointer",536908098]],["^15",[878,"^11","Pointer",536908098]],["^15",[878,"^B",1690952552087,536924396]],["^15",[878,"^;","~u64c20233-fd7b-4e30-a57b-2b46120a19bb",536916349]],["^15",[879,"^Q","The simplest Smart [[Pointer]] in Rust. It has the least overhead and provides a simple way to store a value on the heap whilst the pointer remains on the stack.\n\nFor ex.:\n```rust\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {}\", b); //prints 5\n} //automatically gets deallocated (along with the value) at the end of the scope.\n```",536908098]],["^15",[879,"^O","^16",536908098]],["^15",[879,"^F",877,536908098]],["^15",[879,"^X",877,536908098]],["^15",[879,"^V",877,536908098]],["^15",[879,"^U",877,536908098]],["^15",[879,"^U",878,536908098]],["^15",[879,"^H",878,536908098]],["^15",[879,"^17",true,536908098]],["^15",[879,"^;","~u64bbdc0c-4722-4156-afda-9d2d74e1879d",536908098]],["^15",[880,"^Q","*Recursive [[Data Type]]s*\nA recursive data type is one which has its own type in its fields. \nFor ex.:\nA *Cons List*, this is a data structure in *Lisp* and in Rust could be represented through this [[Enum]]\n\n```rust\nenum List {\n Cons(i32, List),\n Nil\n}\n\nfn main() {\n let x = List::Cons(1, List::Cons(2, List::Cons(3, List::Nil));\n}\n```\nThis is a recursive data type, however such types are an error in Rust as the compiler needs to know exactly how much size each type takes. However, here if it tries to figure out the size it will go into an infinite loop like so\n![image.png](../assets/image_1689962545952_0.png)\n\nA simple fix to store such types is by using the ``Box`` [[Pointer]] as Rust knows the size of a pointer at compile time and hence does not need to recurse the type definition.\n![A finite Cons list](https://doc.rust-lang.org/book/img/trpl15-02.svg)\nMaking our code like so\n\n```rust\nenum List {\n Cons(i32, Box<List>),\n Nil\n}\n\nfn main() {\n let x = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, List::Nil)))));\n}\n```",536908098]],["^15",[880,"^O","^16",536908098]],["^15",[880,"^F",879,536908098]],["^15",[880,"^X",877,536908098]],["^15",[880,"^V",877,536908098]],["^15",[880,"^U",148,536908098]],["^15",[880,"^U",511,536908098]],["^15",[880,"^U",877,536908098]],["^15",[880,"^U",878,536908098]],["^15",[880,"^H",148,536908098]],["^15",[880,"^H",511,536908098]],["^15",[880,"^H",878,536908098]],["^15",[880,"^17",true,536908098]],["^15",[880,"^;","~u64bbdc0c-d58c-41b2-9a37-67c028ac7455",536908098]],["^15",[881,"^Q","",536908098]],["^15",[881,"^O","^16",536908098]],["^15",[881,"^F",880,536908098]],["^15",[881,"^X",877,536908098]],["^15",[881,"^V",877,536908098]],["^15",[881,"^U",877,536908098]],["^15",[881,"^17",true,536908098]],["^15",[881,"^;","~u64bbdc0c-3947-42e7-9965-4f84254295ef",536908098]],["^15",[882,"^Q","",536908098]],["^15",[882,"^O","^16",536908098]],["^15",[882,"^F",881,536908098]],["^15",[882,"^X",877,536908098]],["^15",[882,"^V",877,536908098]],["^15",[882,"^U",877,536908098]],["^15",[882,"^17",true,536908098]],["^15",[882,"^;","~u64bbdc0c-59da-40a2-af62-7ad83471151c",536908098]],["^15",[883,"^3","- Anonymous [[Function]]s\n  Can be stored, passed around, capture the values of their context and even be ran in different contexts.\n  For ex.:\n  ```rust\n  fn yo()-> i32 {\n   2\n  }\n  \n  fn main() {\n  let someOption= Option::Some(\"ya\");\n  let value=someOption.unwrap_or_else(|| yo());\n  }\n  ```\n  Here the body of the closure calls ``yo()`` and returns its return value when the [[Unwrap]] gets a ``None``.\n- Syntax\n  Closely resembles that of a [[Function]] but closures can omit most of the explicit [[Data Type]] definitions as they are able to infer them from the context.\n  Closures are short-lived, context-dependent and narrow-use [[Function]]s\n  \n  ``\n  let <variable name> = <optional move> |<param name>: <optional param type>, ... , <more params>| -> <optional return type> { <body that returns the value of the return type> }\n  ``\n  If there's a single statement/expression in the closure we can even omit the [[Scope]] Blocks.\n  Then we can call a closure with ``<variable name>()``, just like [[Function]]s. \n  \n  For ex.:\n  ```rust\n  fn  add_function  (x: u32) -> u32 { x + 1 } //A function\n  \n  fn main() {\n  let add_closure1 = |x: u32| -> u32 { x + 1 }; //A verbose closure\n  let add_closure2 = |x|             { x + 1 }; // Return type and param type is inferred\n  let add_closure3 = |x|               x + 1  ; // Single expression so the block can be omitted\n  //All these are valid definitions\n  add_closure2(2); //required\n  add_closure3(4);  //required\n  }\n  ```\n  As we can see, unlike functions, closures can even infer the return types. However, for the parameter's [[Data Type]]s, we need to call the closures at-least once otherwise the compiler won't be able to infer the type of the params, just like [[Variable]] declarations. This is also to say, closure params aren't dynamically typed, they are statically typed and hence they must have a single concrete type, which the Rust compiler can infer if we call them once.\n- Capturing [[Variable]]s\n  Closures can capture variables, but unlike *C++* where the captured variables need to be explicitly defined, closures automatically capture them if their body uses them and they do so in 3 ways, just like [[Function]]s. They either do immutable [[Borrow]] or mutable [[Borrow]] or take [[Ownership]].\n  \n  For ex.:\n  ```rust\n  fn main() {\n      let mut list = vec![1, 2, 3];\n      let x = || println!(\"{}\", list[0]); //borrows list immutably.\n      x();\n      let mut y = || list.push(4); //borrows list mutably\n      y();\n  }\n  ```\n  The [[Variable]]s are borrowed from the point of closure creation till the last time the closure is invoked (*Nox-Lexical Lifetimes* [[Lifetime]]).\n  \n  * We can force the closure to take [[Ownership]] of all captured variables with the ``move`` keyword making [[Copy or Move]] always move the captured values.\n  \n  For ex.:\n  \n  ```rust\n  fn main() {\n      let mut list = vec![1, 2, 3];\n      let mut y = move || list.push(4); //moves list's ownership to the closure\n      y();\n  }\n  ```\n  \n  This is sometimes required, such as in [[Thread]]s\n  For ex.:\n  ```rust\n  use std::thread;\n  \n  fn main() {\n      let list = vec![1, 2, 3];\n      println!(\"Before defining closure: {:?}\", list);\n  \n      thread::spawn(move || println!(\"From thread: {:?}\", list))\n          .join()\n          .unwrap();\n  }\n  ```\n  Here, since the closure runs in a separate thread, it is not guaranteed if the main thread or the child thread will finish first, but if main has the ownership and it dies first then the ``list`` will be deallocated rendering an immutable reference passed to the child thread as a dangling [[Reference Type]]. To avoid this, rust compiler itself ensures we ``move`` the captured variables.\n  \n  A closure can then ``move`` the variable to another closure or [[Function]] or etc passing the [[Ownership]] to something else. This is called moving a variable outside a closure.\n- Capture [[Trait]]s and passing closures around\n  All closures implement some traits depending on what they do with their captured [[Variable]]s. \n  There are 4 cases, \n  \n  * A closure captures a variable but doesn't mutate it, nor moves it outside.\n  * Mutates the value.\n  * Moves it outside.\n  * Doesn't capture any variable, so no moving outside nor mutating.\n  \n  Based on these cases, it automatically implements 1 or more of these traits\n  \n  * ``FnOnce``: Applies to all closures that can be called at-least once. All closures implement this. Ones that move captured references outside their body implement only this because they can be called only once as they move the references outside so they can’t be used again.\n  \n  * ``FnMut``: Applies to closures that mutate references but don’t move them outside.\n  \n  * ``Fn``: Applies to closures that don’t mutate references and don’t move references outside. It is also applied to closures that don’t capture anything.\n  \n  We can then use these traits with the [[Generic Type]]s too. The type of [[Function]]s/ [[Method]]s and Closures is ``( )`` for using with Generics and they also automatically implement these traits. This is why we can pass a function/method to params that accept a closure.\n  For ex.:\n  ```rust\n  fn yo<T>(a: T) -> String \n  where\n      T: Fn() -> i32,  //defining the type of T as function with (), then the trait with Fn and return type of the closure/function passed to T\n  {\n      a();\n      return String::from(\"ya\");\n  }\n  fn ya() -> i32 {\n      return 2;\n  }\n  \n  fn yo2<T>(a: T) -> String\n  where\n      T: Fn() -> i32 + FnMut() -> i32, //We use this syntax for multiple Fn traits.\n  {\n      a();\n      return String::from(\"ya\");\n  }\n  \n  \n  fn main() {\n      let x = || 2;\n      yo(x); //works\n      yo(ya); //also works!\n      yo2(x); //works too\n  }\n  \n  ```\n- Returning Closures\n  Closures are represented by [[Trait]]s, which is why they are [[DST]]s. \n  So to return a closure we need to use [[Trait Object]]s.\n  \n  For ex.:\n  ```rust\n  fn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n      Box::new(|x| x + 1)\n  } //works\n  ```",536919456]],["^15",[883,"^1=",1690033164386,536908100]],["^15",[883,"^18","~m1690519415527",536919455]],["^15",[883,"^Z","pages/Closure.md",536908100]],["^15",[884,"^Q","Anonymous [[Function]]s\nCan be stored, passed around, capture the values of their context and even be ran in different contexts.\nFor ex.:\n```rust\nfn yo()-> i32 {\n 2\n}\n\nfn main() {\nlet someOption= Option::Some(\"ya\");\nlet value=someOption.unwrap_or_else(|| yo());\n}\n```\nHere the body of the closure calls ``yo()`` and returns its return value when the [[Unwrap]] gets a ``None``.",536908100]],["^15",[884,"^O","^16",536908100]],["^15",[884,"^F",714,536908100]],["^15",[884,"^X",714,536908100]],["^15",[884,"^V",714,536908100]],["^15",[884,"^U",130,536908100]],["^15",[884,"^U",681,536908100]],["^15",[884,"^U",714,536908100]],["^15",[884,"^H",130,536908100]],["^15",[884,"^H",681,536908100]],["^15",[884,"^17",true,536908100]],["^15",[884,"^;","~u64bbdc0c-6b07-4d4c-a5a2-9c6e9a922e31",536908100]],["^15",[885,"^Q","Syntax\nClosely resembles that of a [[Function]] but closures can omit most of the explicit [[Data Type]] definitions as they are able to infer them from the context.\nClosures are short-lived, context-dependent and narrow-use [[Function]]s\n\n``\nlet <variable name> = <optional move> |<param name>: <optional param type>, ... , <more params>| -> <optional return type> { <body that returns the value of the return type> }\n``\nIf there's a single statement/expression in the closure we can even omit the [[Scope]] Blocks.\nThen we can call a closure with ``<variable name>()``, just like [[Function]]s. \n\nFor ex.:\n```rust\nfn  add_function  (x: u32) -> u32 { x + 1 } //A function\n\nfn main() {\nlet add_closure1 = |x: u32| -> u32 { x + 1 }; //A verbose closure\nlet add_closure2 = |x|             { x + 1 }; // Return type and param type is inferred\nlet add_closure3 = |x|               x + 1  ; // Single expression so the block can be omitted\n//All these are valid definitions\nadd_closure2(2); //required\nadd_closure3(4);  //required\n}\n```\nAs we can see, unlike functions, closures can even infer the return types. However, for the parameter's [[Data Type]]s, we need to call the closures at-least once otherwise the compiler won't be able to infer the type of the params, just like [[Variable]] declarations. This is also to say, closure params aren't dynamically typed, they are statically typed and hence they must have a single concrete type, which the Rust compiler can infer if we call them once.",536908100]],["^15",[885,"^O","^16",536908100]],["^15",[885,"^F",884,536908100]],["^15",[885,"^X",714,536908100]],["^15",[885,"^V",714,536908100]],["^15",[885,"^U",89,536908100]],["^15",[885,"^U",99,536908100]],["^15",[885,"^U",130,536908100]],["^15",[885,"^U",148,536908100]],["^15",[885,"^U",714,536908100]],["^15",[885,"^H",89,536908100]],["^15",[885,"^H",99,536908100]],["^15",[885,"^H",130,536908100]],["^15",[885,"^H",148,536908100]],["^15",[885,"^17",true,536908100]],["^15",[885,"^;","~u64bbdc0c-e71e-4ff1-a3f4-dabbc5afe047",536908100]],["^15",[886,"^Q","Capturing [[Variable]]s\nClosures can capture variables, but unlike *C++* where the captured variables need to be explicitly defined, closures automatically capture them if their body uses them and they do so in 3 ways, just like [[Function]]s. They either do immutable [[Borrow]] or mutable [[Borrow]] or take [[Ownership]].\n\nFor ex.:\n```rust\nfn main() {\n    let mut list = vec![1, 2, 3];\n    let x = || println!(\"{}\", list[0]); //borrows list immutably.\n    x();\n    let mut y = || list.push(4); //borrows list mutably\n    y();\n}\n```\nThe [[Variable]]s are borrowed from the point of closure creation till the last time the closure is invoked (*Nox-Lexical Lifetimes* [[Lifetime]]).\n\n* We can force the closure to take [[Ownership]] of all captured variables with the ``move`` keyword making [[Copy or Move]] always move the captured values.\n\nFor ex.:\n\n```rust\nfn main() {\n    let mut list = vec![1, 2, 3];\n    let mut y = move || list.push(4); //moves list's ownership to the closure\n    y();\n}\n```\n\nThis is sometimes required, such as in [[Thread]]s\nFor ex.:\n```rust\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n}\n```\nHere, since the closure runs in a separate thread, it is not guaranteed if the main thread or the child thread will finish first, but if main has the ownership and it dies first then the ``list`` will be deallocated rendering an immutable reference passed to the child thread as a dangling [[Reference Type]]. To avoid this, rust compiler itself ensures we ``move`` the captured variables.\n\nA closure can then ``move`` the variable to another closure or [[Function]] or etc passing the [[Ownership]] to something else. This is called moving a variable outside a closure.",536910762]],["^15",[886,"^O","^16",536908100]],["^15",[886,"^F",885,536908100]],["^15",[886,"^X",714,536908100]],["^15",[886,"^V",714,536908100]],["^15",[886,"^U",99,536908100]],["^15",[886,"^U",130,536908100]],["^15",[886,"^U",253,536908100]],["^15",[886,"^U",254,536908100]],["^15",[886,"^U",255,536908100]],["^15",[886,"^U",256,536908100]],["^15",[886,"^U",280,536908100]],["^15",[886,"^U",714,536908100]],["^15",[886,"^U",822,536908100]],["^15",[886,"^H",99,536908100]],["^15",[886,"^H",130,536908100]],["^15",[886,"^H",253,536908100]],["^15",[886,"^H",254,536908100]],["^15",[886,"^H",255,536908100]],["^15",[886,"^H",256,536908100]],["^15",[886,"^H",280,536908100]],["^15",[886,"^H",822,536908100]],["^15",[886,"^17",true,536908100]],["^15",[886,"^;","~u64bbdc0c-4b14-49b9-a6e0-d56ac213a0e0",536908100]],["^15",[887,"^Q","Capture [[Trait]]s and passing closures around\nAll closures implement some traits depending on what they do with their captured [[Variable]]s. \nThere are 4 cases, \n\n* A closure captures a variable but doesn't mutate it, nor moves it outside.\n* Mutates the value.\n* Moves it outside.\n* Doesn't capture any variable, so no moving outside nor mutating.\n\nBased on these cases, it automatically implements 1 or more of these traits\n\n* ``FnOnce``: Applies to all closures that can be called at-least once. All closures implement this. Ones that move captured references outside their body implement only this because they can be called only once as they move the references outside so they can’t be used again.\n\n* ``FnMut``: Applies to closures that mutate references but don’t move them outside.\n\n* ``Fn``: Applies to closures that don’t mutate references and don’t move references outside. It is also applied to closures that don’t capture anything.\n\nWe can then use these traits with the [[Generic Type]]s too. The type of [[Function]]s/ [[Method]]s and Closures is ``( )`` for using with Generics and they also automatically implement these traits. This is why we can pass a function/method to params that accept a closure.\nFor ex.:\n```rust\nfn yo<T>(a: T) -> String \nwhere\n    T: Fn() -> i32,  //defining the type of T as function with (), then the trait with Fn and return type of the closure/function passed to T\n{\n    a();\n    return String::from(\"ya\");\n}\nfn ya() -> i32 {\n    return 2;\n}\n\nfn yo2<T>(a: T) -> String\nwhere\n    T: Fn() -> i32 + FnMut() -> i32, //We use this syntax for multiple Fn traits.\n{\n    a();\n    return String::from(\"ya\");\n}\n\n\nfn main() {\n    let x = || 2;\n    yo(x); //works\n    yo(ya); //also works!\n    yo2(x); //works too\n}\n\n```",536908100]],["^15",[887,"^O","^16",536908100]],["^15",[887,"^F",886,536908100]],["^15",[887,"^X",714,536908100]],["^15",[887,"^V",714,536908100]],["^15",[887,"^U",99,536908100]],["^15",[887,"^U",130,536908100]],["^15",[887,"^U",131,536908100]],["^15",[887,"^U",414,536908100]],["^15",[887,"^U",497,536908100]],["^15",[887,"^U",714,536908100]],["^15",[887,"^H",99,536908100]],["^15",[887,"^H",130,536908100]],["^15",[887,"^H",131,536908100]],["^15",[887,"^H",414,536908100]],["^15",[887,"^H",497,536908100]],["^15",[887,"^17",true,536908100]],["^15",[887,"^;","~u64bbdc0c-e0bc-448f-b10d-e9ff73a68f16",536908100]],["^15",[888,"^Q","Returning Closures\nClosures are represented by [[Trait]]s, which is why they are [[DST]]s. \nSo to return a closure we need to use [[Trait Object]]s.\n\nFor ex.:\n```rust\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n} //works\n```",536919454]],["^15",[888,"^O","^16",536908100]],["^15",[888,"^F",887,536908100]],["^15",[888,"^X",714,536908100]],["^15",[888,"^V",714,536908100]],["^15",[888,"^U",262,536919451]],["^15",[888,"^U",414,536919451]],["^15",[888,"^U",714,536919451]],["^15",[888,"^U",1079,536919451]],["^15",[888,"^?",["^ "],536919454]],["^15",[888,"^H",262,536919454]],["^15",[888,"^H",414,536919454]],["^15",[888,"^H",1079,536919454]],["^15",[888,"^17",true,536908100]],["^15",[888,"^;","~u64bbdc0c-bf06-47de-a0b7-7deb6f56ebb3",536908100]],["^15",[889,"^3","- Read file to [[String]]\n  \n  For ex.:\n  ```rust\n  use std::fs;\n  use std::io;\n   \n  fn read_username_from_file() -> Result<String, io::Error> {\n      fs::read_to_string(\"hello.txt\")\n  }\n  ```\n-",536908102]],["^15",[889,"^1=",1690033164495,536908102]],["^15",[889,"^18","~m1689886001609",536908103]],["^15",[889,"^Z","pages/File.md",536908102]],["^15",[890,"^K",1690033164495,536908102]],["^15",[890,"^[",889,536908102]],["^15",[890,"^@",false,536908102]],["^15",[890,"^Y","file",536908102]],["^15",[890,"^11","File",536908102]],["^15",[890,"^B",1690033164495,536908102]],["^15",[890,"^;","~u64c20233-3ea1-45e1-b7b5-504a220baf89",536916343]],["^15",[891,"^Q","Read file to [[String]]\n\nFor ex.:\n```rust\nuse std::fs;\nuse std::io;\n \nfn read_username_from_file() -> Result<String, io::Error> {\n    fs::read_to_string(\"hello.txt\")\n}\n```",536908102]],["^15",[891,"^O","^16",536908102]],["^15",[891,"^F",890,536908102]],["^15",[891,"^X",890,536908102]],["^15",[891,"^V",890,536908102]],["^15",[891,"^U",118,536908102]],["^15",[891,"^U",890,536908102]],["^15",[891,"^H",118,536908102]],["^15",[891,"^17",true,536908102]],["^15",[891,"^;","~u64bbdc0c-cb6e-4e03-9874-14d641910def",536908102]],["^15",[892,"^Q","",536908102]],["^15",[892,"^O","^16",536908102]],["^15",[892,"^F",891,536908102]],["^15",[892,"^X",890,536908102]],["^15",[892,"^V",890,536908102]],["^15",[892,"^U",890,536908102]],["^15",[892,"^17",true,536908102]],["^15",[892,"^;","~u64bbdc0c-c621-4233-86d7-08d23611a4d8",536908102]],["^15",[893,"^3","- In Rust, an iterator is a [[Trait]] that [[Loop]]s over the items of a sequence. \n  They are lazy, so until the next value is requested in a sequence, they don't iterate over it.\n  \n  For ex.:\n  ```rust\n  fn main() {\n  let list= vec![1,2,3];\n  let listIt = list.iter();\n  \n  for item in listIt {\n  \t//use item\n  }\n  \n  }\n  ```\n- ``Iterator`` [[Trait]]\n  Any [[Data Type]] that implements this trait, gets [[Method]]s such as ``.into_iter()`` and ``.iter()`` which return an iterator.\n  \n  This trait is defined like so\n  ```\n  pub trait Iterator {\n  type Item;\n  \n  fn next(&mut self) -> Option<Self::Item>;\n  // the other methods have default implementations \n  }\n  ```\n  Here, the ``type Item`` is an [[Associated Type]]. \n  So if our [[Data Type]] implements this trait then it must provide a type to ``Item`` and the ``next`` [[Method]] must be defined.\n  \n  The way it works is simple, ``next`` uses mutable [[Borrow]] to get the next value of the data type and then change the internal state of the iterator marking the current position. This is why iterators are exhaustive, i.e., if an iterator instance is created and the ``.next()`` called then the iterator will reach a terminal state and won't start over again. This is required behavior too, as the ``.next()`` returns an [[Option Type]] so it must return ``Some`` if there's a value or ``None`` if it is exhausted.\n  \n  For ex.:\n  ```rust\n  fn main() {\n      let list = vec![1, 2, 3];\n      let mut listIt = list.iter(); //Iterators change the internal state, so the variable must be mutable\n      let x: &i32 = &1220;\n      println!(\"{}\", listIt.next().unwrap_or(x));\n      println!(\"{}\", listIt.next().unwrap_or(x));\n      println!(\"{}\", listIt.next().unwrap_or(x));\n      println!(\"{}\", listIt.next().unwrap_or(x)); //prints 1220\n  }\n  \n  ```\n  \n  The ``Some()`` returns an immutable [[Reference Type]] to the value in the actual sequence container when we get an iterator with ``.iter()``. We can get mutqable references with ``.`iter_mut()`` and take [[Ownership]] of the values with ``.to_iter()`` so now the value is [[Copy or Move]]ed into the ``Some()``.\n  \n  * The ``for`` [[Loop]] doesn't need the [[Variable]] to be ``mut`` as it can internally do that.\n  For ex.:\n  ```rust\n  fn main() {\n    let list = vec![1, 2, 3];\n    let list_it= list.iter();\n   for item in list_it{\n     //works, doesn't need list_it to be mutable.\n   }\n  }\n  ```\n  \n  * Iterator Trait [[Method]]s that call ``.next()`` are called *Consuming Adaptor*s as they consume up the iterator.\n  On the contrary, we have *Iterator Adaptor*s, which are methods that don't consume up the iterator and instead produce different iterators. \n  For ex.:\n  ```rust\n  fn main() {\n    let list = vec![1, 2, 3];\n    let new_it= list.iter().map(|x| x + 1); // is an iterator that will take a value from list, apply the map closure, then  return the new value. \n  ```\n  using a [[Closure]]. \n  * ``.collect()`` on an iterator consumes it up and returns a Vector.\n  For ex.:\n  ```rust\n   let list = vec![1, 2, 3];\n   let collected_it : Vec<_> = list.iter().map(|x| x + 1).collect(); \n  }\n  ```\n  Using the ``placeholder`` type and [[Vector]].\n- Iterators vs [[Loop]]s\n  Iterators follow the *zero-cost abstraction principle* in Rust. \n  \"What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.” - Bjarne Stroustrup\n  \n  This basically means unlike loops, iterators will always be the most efficient ways of iterating over sequences. They will always be equal, if not faster, than raw loops. So it is recommended to use iterators wherever loops are concerned. This is because iterators are unrolled. Unrolling is an optimization that compilers perform by unwrapping fixed size loops into individual pieces of code, so if a loop runs 12 times then 12 similar definitions are created. This increases the binary size but allows the runtime to avoid bound checking, and other overheads associated with loops.\n-\n-",536910767]],["^15",[893,"^1=",1690033164540,536908104]],["^15",[893,"^18","~m1690040200630",536910788]],["^15",[893,"^Z","pages/Iterator.md",536908104]],["^15",[894,"^K",1690033164538,536908104]],["^15",[894,"^[",1050,536916389]],["^15",[894,"^O","^16",536916383]],["^15",[894,"^@",false,536908104]],["^15",[894,"^Y","associated type",536908104]],["^15",[894,"^11","Associated Type",536908104]],["^15",[894,"^B",1690436921705,536916868]],["^15",[894,"^;","~u64c20233-1d2f-4102-911a-c54e5863d67d",536916346]],["^15",[895,"^Q","In Rust, an iterator is a [[Trait]] that [[Loop]]s over the items of a sequence. \nThey are lazy, so until the next value is requested in a sequence, they don't iterate over it.\n\nFor ex.:\n```rust\nfn main() {\nlet list= vec![1,2,3];\nlet listIt = list.iter();\n\nfor item in listIt {\n\t//use item\n}\n\n}\n```",536908104]],["^15",[895,"^O","^16",536908104]],["^15",[895,"^F",692,536908104]],["^15",[895,"^X",692,536908104]],["^15",[895,"^V",692,536908104]],["^15",[895,"^U",259,536908104]],["^15",[895,"^U",414,536908104]],["^15",[895,"^U",692,536908104]],["^15",[895,"^H",259,536908104]],["^15",[895,"^H",414,536908104]],["^15",[895,"^17",true,536908104]],["^15",[895,"^;","~u64bbdc0c-fb22-4192-bbcc-1e86408c2e6e",536908104]],["^15",[896,"^Q","~``Iterator`` [[Trait]]\nAny [[Data Type]] that implements this trait, gets [[Method]]s such as ``.into_iter()`` and ``.iter()`` which return an iterator.\n\nThis trait is defined like so\n```\npub trait Iterator {\ntype Item;\n\nfn next(&mut self) -> Option<Self::Item>;\n// the other methods have default implementations \n}\n```\nHere, the ``type Item`` is an [[Associated Type]]. \nSo if our [[Data Type]] implements this trait then it must provide a type to ``Item`` and the ``next`` [[Method]] must be defined.\n\nThe way it works is simple, ``next`` uses mutable [[Borrow]] to get the next value of the data type and then change the internal state of the iterator marking the current position. This is why iterators are exhaustive, i.e., if an iterator instance is created and the ``.next()`` called then the iterator will reach a terminal state and won't start over again. This is required behavior too, as the ``.next()`` returns an [[Option Type]] so it must return ``Some`` if there's a value or ``None`` if it is exhausted.\n\nFor ex.:\n```rust\nfn main() {\n    let list = vec![1, 2, 3];\n    let mut listIt = list.iter(); //Iterators change the internal state, so the variable must be mutable\n    let x: &i32 = &1220;\n    println!(\"{}\", listIt.next().unwrap_or(x));\n    println!(\"{}\", listIt.next().unwrap_or(x));\n    println!(\"{}\", listIt.next().unwrap_or(x));\n    println!(\"{}\", listIt.next().unwrap_or(x)); //prints 1220\n}\n\n```\n\nThe ``Some()`` returns an immutable [[Reference Type]] to the value in the actual sequence container when we get an iterator with ``.iter()``. We can get mutqable references with ``.`iter_mut()`` and take [[Ownership]] of the values with ``.to_iter()`` so now the value is [[Copy or Move]]ed into the ``Some()``.\n\n* The ``for`` [[Loop]] doesn't need the [[Variable]] to be ``mut`` as it can internally do that.\nFor ex.:\n```rust\nfn main() {\n  let list = vec![1, 2, 3];\n  let list_it= list.iter();\n for item in list_it{\n   //works, doesn't need list_it to be mutable.\n }\n}\n```\n\n* Iterator Trait [[Method]]s that call ``.next()`` are called *Consuming Adaptor*s as they consume up the iterator.\nOn the contrary, we have *Iterator Adaptor*s, which are methods that don't consume up the iterator and instead produce different iterators. \nFor ex.:\n```rust\nfn main() {\n  let list = vec![1, 2, 3];\n  let new_it= list.iter().map(|x| x + 1); // is an iterator that will take a value from list, apply the map closure, then  return the new value. \n```\nusing a [[Closure]]. \n* ``.collect()`` on an iterator consumes it up and returns a Vector.\nFor ex.:\n```rust\n let list = vec![1, 2, 3];\n let collected_it : Vec<_> = list.iter().map(|x| x + 1).collect(); \n}\n```\nUsing the ``placeholder`` type and [[Vector]].",536910762]],["^15",[896,"^O","^16",536908104]],["^15",[896,"^F",895,536908104]],["^15",[896,"^X",692,536908104]],["^15",[896,"^V",692,536908104]],["^15",[896,"^U",99,536908104]],["^15",[896,"^U",148,536908104]],["^15",[896,"^U",228,536908104]],["^15",[896,"^U",238,536908104]],["^15",[896,"^U",253,536908104]],["^15",[896,"^U",254,536908104]],["^15",[896,"^U",255,536908104]],["^15",[896,"^U",256,536908104]],["^15",[896,"^U",259,536908104]],["^15",[896,"^U",414,536908104]],["^15",[896,"^U",497,536908104]],["^15",[896,"^U",692,536908104]],["^15",[896,"^U",714,536908104]],["^15",[896,"^U",894,536908104]],["^15",[896,"^H",99,536908104]],["^15",[896,"^H",148,536908104]],["^15",[896,"^H",228,536908104]],["^15",[896,"^H",238,536908104]],["^15",[896,"^H",253,536908104]],["^15",[896,"^H",254,536908104]],["^15",[896,"^H",255,536908104]],["^15",[896,"^H",256,536908104]],["^15",[896,"^H",259,536908104]],["^15",[896,"^H",414,536908104]],["^15",[896,"^H",497,536908104]],["^15",[896,"^H",714,536908104]],["^15",[896,"^H",894,536908104]],["^15",[896,"^17",true,536908104]],["^15",[896,"^;","~u64bbdc0c-ed17-4888-9fb8-0634a196ccbe",536908104]],["^15",[897,"^Q","Iterators vs [[Loop]]s\nIterators follow the *zero-cost abstraction principle* in Rust. \n\"What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.” - Bjarne Stroustrup\n\nThis basically means unlike loops, iterators will always be the most efficient ways of iterating over sequences. They will always be equal, if not faster, than raw loops. So it is recommended to use iterators wherever loops are concerned. This is because iterators are unrolled. Unrolling is an optimization that compilers perform by unwrapping fixed size loops into individual pieces of code, so if a loop runs 12 times then 12 similar definitions are created. This increases the binary size but allows the runtime to avoid bound checking, and other overheads associated with loops.",536908104]],["^15",[897,"^O","^16",536908104]],["^15",[897,"^F",896,536908104]],["^15",[897,"^X",692,536908104]],["^15",[897,"^V",692,536908104]],["^15",[897,"^U",259,536908104]],["^15",[897,"^U",692,536908104]],["^15",[897,"^H",259,536908104]],["^15",[897,"^17",true,536908104]],["^15",[897,"^;","~u64bbdc0c-a4e9-44ac-b843-3bf7dde9f2e8",536908104]],["^15",[898,"^Q","",536908104]],["^15",[898,"^O","^16",536908104]],["^15",[898,"^F",897,536908104]],["^15",[898,"^X",692,536908104]],["^15",[898,"^V",692,536908104]],["^15",[898,"^U",692,536908104]],["^15",[898,"^17",true,536908104]],["^15",[898,"^;","~u64bbdc0c-5fdf-4041-87b3-bb6caa789cf4",536908104]],["^15",[899,"^Q","",536908104]],["^15",[899,"^O","^16",536908104]],["^15",[899,"^F",898,536908104]],["^15",[899,"^X",692,536908104]],["^15",[899,"^V",692,536908104]],["^15",[899,"^U",692,536908104]],["^15",[899,"^17",true,536908104]],["^15",[899,"^;","~u64bbdc0c-28a1-4f4f-8199-8a671f225ad2",536908104]],["^15",[900,"^3","- Macros are special symbols that expand to more text in the source code.\n  Just like *C++* has *#define* which can define a symbol which is expanded before compilation phase and modifies the code in the translation unit, Rust has macros which are symbols that get replaced with other text in the equivalent of translation unit in rust (not sure what it is [[TODO]]).\n  \n  This means, we can use macros to define [[Function]]s and other code in a single place, and using the same symbol in different projects can allow us to skip writing a lot of boilerplate. \n  The only cost associated with Macros is the less simpler syntax and linter assistance making them harder to maintain and debug. As they use a slightly different syntax than normal Rust.\n  \n  * Unlike [[Function]]s, Macros must be defined/imported into a [[Scope]] before being used.\n  \n  * Rust has 2 main type, but 4 different sub-types of Macros\n  Declarative macros: Implemented with [[macro_rules!]]\n  Procedural macros: They include [[Custom Derive Macro]]s, [[Macro Attribute]]s and [[Function Macro]]s.\n- Procedural Macros\n  These macros must be defined in their own special [[Crate]]s and then added as a dependency to the crate that needs to use them.\n  \n  For ex.:\n  ```rust\n  use proc_macro;\n  \n  #[some_attribute]\n  pub fn some_name(input: TokenStream) -> TokenStream {\n  }\n  ```\n  ``TokenStream`` is a [[Data Type]] that is defined by Rust itself and holds the source code in text.\n  \n  * [[Procedural Macro Crate]]s are different from normal crates.\n  * [[Custom Derive Macro]]s are macros like ``#[something_derive]`` applied only on either [[Struct]]s or [[Enum]]s. They need to have ``derive`` at the end of their name due to how [[Procedural Macro Crate]]s are defined, this is a known technical limitation.\n  \n  These macros are defined with the ``#[proc_macro_derive]`` [[Macro Attribute]]. \n  \n  For ex.:\n  ```rust\n  use proc_macro::TokenStream;\n  use quote::quote;\n  use syn;\n  \n  #[proc_macro_derive(HelloMacro)]\n  pub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n      // Construct a representation of Rust code as a syntax tree\n      // that we can manipulate\n      let ast = syn::parse(input).unwrap();\n  \n      // Build the trait implementation\n      impl_hello_macro(&ast)\n  }\n  ```\n  * [[Macro Attribute]]s are like Custom Derive Macros but they don't have the limitation of ``derive`` name at their end and can be applied to other items such as [[Function]]s too. They take the whole item, such as a function, modify it, and return the newly modified function back. \n  For ex.:\n  ```rust\n  #[route(GET, \"/\")]\n  fn index() { }\n  ```\n  These macros are defined with ``#[proc_macro_attribute]``\n  For ex.:\n  ```rust\n  #[proc_macro_attribute]\n  pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {}\n  ```\n  \n  * [[Function Macro]]s define macros that look like functions and work kind of like [[macro_rules!]]. They can take any number of arguments and accept ``TokenStream`` as parameter so they take the code and modify it and return it, just like [[macro_rules!]] but without any pattern matching involved.\n  The syntax to call them is ``<some proc macro name>!(<some code>)`` which is slightly different from [[macro_rules!]].\n  \n  These macros are defined with the ``#[proc_macro]`` syntax\n  \n  For ex.:\n  ```rust\n  pub fn sql(input: TokenStream) -> TokenStream { }\n  ```\n-\n- Print and debug\n  ``print!()`` is a [[macro_rules!]] macro that prints text to stdout.\n  ``println!()`` is its newline ending variant. \n  For ex.:\n  ```rust\n  prinln!(\"{} yoo {}\",2,4); \n  ```\n  Here the given string is printed and all ``{ }`` in it indicate scalar/printable [[Data Type]]s which are provided as variable number of args to the macro.\n  \n  * Output Format:\n  We can specify output formats inside the ``{ }``.\n  \n  * Debug Printing:\n  If we use ``{:?}``  then it prints the given object in debug mode, but requires the [[Data Type]] to implement the ``Debug`` [[Trait]], this is a derivable trait.\n  \n  For ex.:\n  ```rust\n  #[derive(Debug)]\n  struct X {}\n  \n  fn main() {\n  let x = X{};\n  println!(\"{:?}\", X);\n  //and it will debug print it. \n  \n  println!(\"{:#?}\", x); //debug prints the instance.\n  ```\n  \n  Alternatively, we can instead use ``dbg!(<value>)``. This macro returns the [[Ownership]] of expressions so having it there or not there is the same thing to Rust.\n  For ex.:\n  ```rust\n  let a=dbg!(2*4); //a will be 8 and it will print 2 * 4 = 8\n  ```\n  ``dbg!`` prints to stderr.\n  \n  * ``eprintln!(...)``: Just like dbg!, prints stuff to stderr.\n- Common Macros\n  * ``println!(<>)``: Prints stuff",536921484]],["^15",[900,"^1=",1690033164578,536908106]],["^15",[900,"^18","~m1690893290375",536921483]],["^15",[900,"^Z","pages/Macro.md",536908106]],["^15",[901,"^Q","Common Macros\n* ``println!(<>)``: Prints stuff",536908106]],["^15",[901,"^O","^16",536908106]],["^15",[901,"^F",700,536908106]],["^15",[901,"^X",246,536908106]],["^15",[901,"^V",246,536908106]],["^15",[901,"^U",246,536908106]],["^15",[901,"^17",true,536908106]],["^15",[901,"^;","~u64bbdc0c-f42c-4d66-b8a4-93c46451a4fa",536908106]],["^15",[902,"^3","- A Pointer is a [[Data Type]] that points to data stored on the memory. \n  [[Reference Type]]s are the most basic type of pointers in Rust as they point to an address and have no performance overhead, represented with ``&`` [[Operator]].\n- *Smart Pointer*s\n  Implemented as [[Struct]]s which store data on the heap and usually also have [[Ownership]] of it. They have a bit of performance overhead, as is true with accessing heap anyways, but are able to provide some additional functionality such as cleaning up after all pointers to the same data are out of [[Lifetime]]s.\n  \n  Smart Pointer [[Data Type]]s must implement at-least the ``Deref`` and ``drop`` [[Trait]].\n  Some smart pointers already in the [[Standard Library]] are\n  \n  * [[Box<T>]]\n  * [[Rc<T>]]\n  * [[Ref<T>]] and [[RefMut<T>]]\n  * [[RefCell<T>]]\n  * [[Cell<T>]]\n  * [[Mutex<T>]] and [[MutexGuard<T>]]\n  \n  These smart pointers don't implement the ``Send`` [[Trait]] and ``Sync`` Trait, as they are not safe to be shared across [[Thread]]s. \n  But there are other variants which do, they are\n  \n  * [[Arc<T>]]\n- *Raw Pointer*s\n  Rust allows raw pointers. They're allowed to ignore [[Borrow]]ing rules and have multiple pointers (immutable + mutable) to the same  value, aren't required to point to valid memory, can be null, and don't implement any automatic cleanup.\n  Creating raw pointers and pointing them to any value is allowed in normal rust. However, dereferencing a raw pointer is [[unsafe]]. \n  \n  There's 2 of these\n  * immutable Raw Pointer: ``*const T`` where ``*`` is in the type name and not the deref [[Operator]]. These pointers can't be reassigned. \n  \n  * mutable Raw Pointer: ``*mut T``. Can be reassigned to point to a different value.\n  \n  For ex.:\n  ```rust\n  fn main() {\n      let mut num = 5;\n  \n      let r1 = &num as *const i32;\n      let r2 = &mut num as *mut i32;\n  \n      unsafe {\n          println!(\"r1 is: {}\", *r1);\n          println!(\"r2 is: {}\", *r2);\n      }\n   \n  } //works\n  ```\n  We use [[as]] to [[Cast]] a [[Reference Type]] to a Raw Pointer.\n- The ``fn`` [[Function]] Pointer\n- Pointers and the address problem\n  Consider a [[Struct]] like so\n  ```rust\n  #[derive(Debug)]\n  struct Test {\n      a: String,\n      b: *const String,\n  }\n  //and the impl block is designed like pointer b always points to a\n  //thereby creating a self-referencing struct\n  impl Test {\n      fn new(txt: &str) -> Self {\n          Test {\n              a: String::from(txt),\n              b: std::ptr::null(),\n          }\n      }\n  \n      fn init(&mut self) {\n          let self_ref: *const String = &self.a;\n          self.b = self_ref;\n      }\n  \n      fn a(&self) -> &str {\n          &self.a\n      }\n  \n      fn b(&self) -> &String {\n          assert!(!self.b.is_null(), \"Test::b called without Test::init being called first\");\n          unsafe { &*(self.b) }\n      }\n  }\n  \n  //Now somewhere we do  std::mem::swap(&mut test1, &mut test2); \n  ```\n   Now if we print the value behind b after swapping the memory of 2 objects, that is we swap the memory where the object's reference is stored, then we swap each field's data at their memory addresses. But ``mem::swap`` [[Module]] doesn't modify the values in their addresses, so the pointers will still point to  their old addresses, thereby breaking the self-referential struct.\n  \n  That is,\n  ![image.png](../assets/image_1690904345284_0.png)\n   \n  When we store a pointer as a [[Data Type]] and then do a ``mem::swap`` with another of the same type then the pointer's data is swapped. But, the values at the address theirselves aren't modified.\n  This isn't an issue with non self-referential types as it would be intended to have the pointers still point to the same address, but in self-referential types, it'd be a problem.\n   \n  For this reason extra care must be taken with raw pointers.\n  We can resolve this with [[Pinning]].",536924399]],["^15",[902,"^1=",1690033164670,536908108]],["^15",[902,"^18","~m1690952553180",536924398]],["^15",[902,"^Z","pages/Pointer.md",536908108]],["^15",[903,"^K",1690033164667,536908108]],["^15",[903,"^[",959,536911141]],["^15",[903,"^O","^16",536911136]],["^15",[903,"^@",false,536908108]],["^15",[903,"^Y","refcell<t>",536908108]],["^15",[903,"^11","RefCell<T>",536908108]],["^15",[903,"^B",1690127614083,536914505]],["^15",[903,"^;","~u64c20233-0ad1-45c2-a757-c8b05aada917",536916340]],["^15",[904,"^K",1690033164669,536908108]],["^15",[904,"^@",false,536908108]],["^15",[904,"^Y","ref<t>",536908108]],["^15",[904,"^11","Ref<T>",536908108]],["^15",[904,"^B",1690033164669,536908108]],["^15",[904,"^;","~u64c20233-fff6-46c2-85d9-fbdd6c94e3a1",536916340]],["^15",[905,"^K",1690033164668,536908108]],["^15",[905,"^@",false,536908108]],["^15",[905,"^Y","refmut<t>",536908108]],["^15",[905,"^11","RefMut<T>",536908108]],["^15",[905,"^B",1690033164668,536908108]],["^15",[905,"^;","~u64c20233-74d1-40ef-a1cc-596345108ec5",536916340]],["^15",[906,"^K",1690033164670,536908108]],["^15",[906,"^[",947,536910279]],["^15",[906,"^O","^16",536910274]],["^15",[906,"^@",false,536908108]],["^15",[906,"^Y","rc<t>",536908108]],["^15",[906,"^11","Rc<T>",536908108]],["^15",[906,"^B",1690043542554,536911871]],["^15",[906,"^;","~u64c20233-24e9-4398-a657-287bc32d7333",536916346]],["^15",[907,"^Q","A Pointer is a [[Data Type]] that points to data stored on the memory. \n[[Reference Type]]s are the most basic type of pointers in Rust as they point to an address and have no performance overhead, represented with ``&`` [[Operator]].",536908108]],["^15",[907,"^O","^16",536908108]],["^15",[907,"^F",878,536908108]],["^15",[907,"^X",878,536908108]],["^15",[907,"^V",878,536908108]],["^15",[907,"^U",148,536908108]],["^15",[907,"^U",206,536908108]],["^15",[907,"^U",253,536908108]],["^15",[907,"^U",878,536908108]],["^15",[907,"^H",148,536916340]],["^15",[907,"^H",206,536916340]],["^15",[907,"^H",253,536916340]],["^15",[907,"^17",true,536908108]],["^15",[907,"^;","~u64bbdc0c-14e8-46a4-9489-c9ebd2f85061",536908108]],["^15",[908,"^Q","*Smart Pointer*s\nImplemented as [[Struct]]s which store data on the heap and usually also have [[Ownership]] of it. They have a bit of performance overhead, as is true with accessing heap anyways, but are able to provide some additional functionality such as cleaning up after all pointers to the same data are out of [[Lifetime]]s.\n\nSmart Pointer [[Data Type]]s must implement at-least the ``Deref`` and ``drop`` [[Trait]].\nSome smart pointers already in the [[Standard Library]] are\n\n* [[Box<T>]]\n* [[Rc<T>]]\n* [[Ref<T>]] and [[RefMut<T>]]\n* [[RefCell<T>]]\n* [[Cell<T>]]\n* [[Mutex<T>]] and [[MutexGuard<T>]]\n\nThese smart pointers don't implement the ``Send`` [[Trait]] and ``Sync`` Trait, as they are not safe to be shared across [[Thread]]s. \nBut there are other variants which do, they are\n\n* [[Arc<T>]]",536914515]],["^15",[908,"^O","^16",536908108]],["^15",[908,"^F",907,536908108]],["^15",[908,"^X",878,536908108]],["^15",[908,"^V",878,536908108]],["^15",[908,"^U",93,536914185]],["^15",[908,"^U",148,536914185]],["^15",[908,"^U",242,536914185]],["^15",[908,"^U",255,536914185]],["^15",[908,"^U",280,536914185]],["^15",[908,"^U",414,536914185]],["^15",[908,"^U",822,536914185]],["^15",[908,"^U",877,536914185]],["^15",[908,"^U",878,536914185]],["^15",[908,"^U",903,536914185]],["^15",[908,"^U",904,536914185]],["^15",[908,"^U",905,536914185]],["^15",[908,"^U",906,536914185]],["^15",[908,"^U",963,536914185]],["^15",[908,"^U",995,536914185]],["^15",[908,"^U",999,536914185]],["^15",[908,"^U",1002,536914185]],["^15",[908,"^H",93,536916340]],["^15",[908,"^H",148,536916340]],["^15",[908,"^H",242,536916340]],["^15",[908,"^H",255,536916340]],["^15",[908,"^H",280,536916340]],["^15",[908,"^H",414,536916340]],["^15",[908,"^H",822,536916340]],["^15",[908,"^H",877,536916340]],["^15",[908,"^H",903,536916340]],["^15",[908,"^H",904,536916340]],["^15",[908,"^H",905,536916340]],["^15",[908,"^H",906,536916340]],["^15",[908,"^H",963,536916340]],["^15",[908,"^H",995,536916340]],["^15",[908,"^H",999,536916340]],["^15",[908,"^H",1002,536916340]],["^15",[908,"^17",true,536908108]],["^15",[908,"^;","~u64bbdc0c-fe5f-4114-826f-f9c46342af1b",536908108]],["^15",[909,"^Q","The ``fn`` [[Function]] Pointer",536918536]],["^15",[909,"^O","^16",536908108]],["^15",[909,"^F",1042,536916340]],["^15",[909,"^X",878,536908108]],["^15",[909,"^V",878,536908108]],["^15",[909,"^U",130,536918537]],["^15",[909,"^U",878,536918537]],["^15",[909,"^?",["^ "],536918536]],["^15",[909,"^H",130,536918536]],["^15",[909,"^17",true,536908108]],["^15",[909,"^;","~u64bbdc0c-9483-4b67-b058-1dbef1fd2804",536908108]],["^15",[910,"^K",1690033164739,536908111]],["^15",[910,"^@",false,536908111]],["^15",[910,"^Y","cargo.lock",536908111]],["^15",[910,"^11","cargo.lock",536908111]],["^15",[910,"^B",1690033164739,536908111]],["^15",[910,"^;","~u64bbdc0c-8e07-45aa-b172-5c982c0e144f",536908111]],["^15",[911,"^Q","Release Profile\nCargo has 2 main profiles, ``dev`` and ``release`` profile. These profile define the configs applied to the compilation of the project. The ``dev`` profile is used when using ``cargo build`` by default and the ``release`` profile is used when we use ``cargo build --release``. \nThe primary difference between the 2 is the level of optimization applied to the executable (using ``opt-level = <number>`` in [[cargo.toml]]), the higher the level the greater the runtime performance but greater compile time too. This is why ``release`` is intended for release mode.\n\nTo further configure them, in [[cargo.toml]]\n```toml\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n```\nThis is their default optimization level.",536908111]],["^15",[911,"^O","^16",536908111]],["^15",[911,"^F",98,536908111]],["^15",[911,"^X",45,536908111]],["^15",[911,"^V",45,536908111]],["^15",[911,"^U",43,536908111]],["^15",[911,"^U",45,536908111]],["^15",[911,"^H",43,536908111]],["^15",[911,"^17",true,536908111]],["^15",[911,"^;","~u64bbdc0c-aa8e-4176-917e-d7ab482988f4",536908111]],["^15",[912,"^Q","Publishing a [[Crate]]\nCheck [here](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html)",536908111]],["^15",[912,"^O","^16",536908111]],["^15",[912,"^F",911,536908111]],["^15",[912,"^X",45,536908111]],["^15",[912,"^V",45,536908111]],["^15",[912,"^U",45,536908111]],["^15",[912,"^U",577,536908111]],["^15",[912,"^H",577,536908111]],["^15",[912,"^17",true,536908111]],["^15",[912,"^;","~u64bbdc0c-9074-4472-8510-c7706b1fd81d",536908111]],["^15",[913,"^Q","",536908111]],["^15",[913,"^O","^16",536908111]],["^15",[913,"^F",916,536908111]],["^15",[913,"^X",45,536908111]],["^15",[913,"^V",45,536908111]],["^15",[913,"^U",45,536908111]],["^15",[913,"^17",true,536908111]],["^15",[913,"^;","~u64bbdc0c-2c64-4270-ad23-782705d728f1",536908111]],["^15",[914,"^Q","Workspace\nBy using workspace, which is a cargo feature, we can have multiple [[Package]]s in a single project. They share the same [[cargo.lock]] and ``target/`` folder, which is from common parent which is a ``workspace``.\n\nFor ex.:\n```sh\nmkdir x\ntouch cargo.toml\n# creates a new folder x and a cargo.toml in it\n```\n\nThen we make ``x``  a Workspace by modifying its [[cargo.toml]]\n```toml\n[workspace]\n\nmembers = [\n  y,\n  z,\n]\n```\nBy replacing the ``[package]`` block with ``[workspace]`` we make a ``cargo.toml``'s folder a workspace. Here ``y`` and ``z`` are its child [[Package]]s.\n\nTo create them,\n```sh\ncd x\ncargo new y\n# creates crate y inside x with x being its workspace and hence a cargo.lock and target/ isn't created inside y/\ncargo new z --lib\n```\n\nFinally, we get this structure\n```\nx\n├── Cargo.lock\n├── Cargo.toml\n├── y\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n├── z\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── target\n```\nThe reason they share the ``target`` directory is because the packages in a workspace are  meant to depend on each other, by sharing the ``target`` folder they keep track of which package has been already built and hence avoid rebuilding each dependent package each time for each package.\n\n* To use a package like ``z`` in ``y`` we would do something like so\nIn ``lib.rs`` in ``z``,\n```rust\npub fn yo() {}\n```\nNow to use ``yo`` in ``y``,\nmodify ``y``'s [[cargo.toml]],\n```toml\n[dependencies]\nz = { path = \"../z\" }\n```\n\nNow we can use ``z``'s items in ``y``, like so\n```rust\nuse z;\n\nfn main() {\n yo(); //works\n}\n```\n\n* ``cargo test -p <package name>``\nBy default cargo runs test on all crates inside a workspace, we can select a specific package with this arg.",536908111]],["^15",[914,"^O","^16",536908111]],["^15",[914,"^F",912,536908111]],["^15",[914,"^X",45,536908111]],["^15",[914,"^V",45,536908111]],["^15",[914,"^U",43,536908111]],["^15",[914,"^U",45,536908111]],["^15",[914,"^U",704,536908111]],["^15",[914,"^U",910,536908111]],["^15",[914,"^H",43,536908111]],["^15",[914,"^H",704,536908111]],["^15",[914,"^H",910,536908111]],["^15",[914,"^17",true,536908111]],["^15",[914,"^;","~u64bbdc0c-03c6-4050-bf00-4e628b8de039",536908111]],["^15",[915,"^Q","~``cargo install``\nInstalls a binary to be used directly. By default ``cargo install`` installs a binary to ``$Home/.cargo/bin`` so we have to add that path to ``$PATH``. Only packages on crates.io that are a binary crate can be installed like this. \nFor ex.:\n```sh\ncargo install ripgrep\n#installs rigrep, a rust package for searching files.\n```",536908111]],["^15",[915,"^O","^16",536908111]],["^15",[915,"^F",914,536908111]],["^15",[915,"^X",45,536908111]],["^15",[915,"^V",45,536908111]],["^15",[915,"^U",45,536908111]],["^15",[915,"^17",true,536908111]],["^15",[915,"^;","~u64bbdc0c-a42d-4aa9-a2ac-c3f2e6ac7c4a",536908111]],["^15",[916,"^Q","",536908111]],["^15",[916,"^O","^16",536908111]],["^15",[916,"^F",915,536908111]],["^15",[916,"^X",45,536908111]],["^15",[916,"^V",45,536908111]],["^15",[916,"^U",45,536908111]],["^15",[916,"^17",true,536908111]],["^15",[916,"^;","~u64bbdc0c-ff5c-4428-8dbc-e419c38d25f3",536908111]],["^15",[917,"^Q","[[Result Type]]",536908120]],["^15",[917,"^O","^16",536908120]],["^15",[917,"^F",522,536908120]],["^15",[917,"^X",261,536908120]],["^15",[917,"^V",261,536908120]],["^15",[917,"^U",261,536908120]],["^15",[917,"^U",687,536908120]],["^15",[917,"^H",687,536908120]],["^15",[917,"^17",true,536908120]],["^15",[917,"^;","~u64bbdc0c-ef7a-49cc-8a64-75a33a395159",536908120]],["^15",[918,"^Q","Size of an Enum\nThe size of an enum is the same as the biggest variant of it, so if an enum had a variant ``X`` and then a variant ``Y(i32)`` then the size of the enum would be the same as an ``i32``. \nThe reason is pretty simple, an enum's value can only be any 1 of its variants, so the largest variant's size is the size of the enum itself.",536908120]],["^15",[918,"^O","^16",536908120]],["^15",[918,"^F",917,536908120]],["^15",[918,"^X",261,536908120]],["^15",[918,"^V",261,536908120]],["^15",[918,"^U",261,536908120]],["^15",[918,"^17",true,536908120]],["^15",[918,"^;","~u64bbdc0c-9e28-4459-947d-857de086311b",536908120]],["^15",[919,"^Q","",536908126]],["^15",[919,"^O","^16",536908126]],["^15",[919,"^F",376,536908126]],["^15",[919,"^X",259,536908126]],["^15",[919,"^V",259,536908126]],["^15",[919,"^U",259,536908126]],["^15",[919,"^17",true,536908126]],["^15",[919,"^;","~u64bbdc0d-f61b-4120-9990-ab55dca2cee4",536908126]],["^15",[920,"^Q","[[File]]",536908132]],["^15",[920,"^O","^16",536908132]],["^15",[920,"^F",868,536908132]],["^15",[920,"^X",28,536908132]],["^15",[920,"^V",28,536908132]],["^15",[920,"^U",28,536908132]],["^15",[920,"^U",890,536908132]],["^15",[920,"^H",890,536916343]],["^15",[920,"^17",true,536908132]],["^15",[920,"^;","~u64bbdc0d-4454-41d1-980e-b50689410e65",536908132]],["^15",[921,"^Q","*Functional Programming*\nRust borrows some concepts from FP languages. An FP language generally\nsees [[Function]]s as values.\nThese concepts in Rust are similar to what FP languages have.\n* [[Closure]]\n* [[Iterator]]",536908132]],["^15",[921,"^O","^16",536908132]],["^15",[921,"^F",920,536908132]],["^15",[921,"^X",28,536908132]],["^15",[921,"^V",28,536908132]],["^15",[921,"^U",28,536908132]],["^15",[921,"^U",130,536908132]],["^15",[921,"^U",692,536908132]],["^15",[921,"^U",714,536908132]],["^15",[921,"^H",130,536916343]],["^15",[921,"^H",692,536916343]],["^15",[921,"^H",714,536916343]],["^15",[921,"^17",true,536908132]],["^15",[921,"^;","~u64bbdc0d-1356-4457-8b4d-a81797326348",536908132]],["^15",[922,"^K",1690033165275,536908135]],["^15",[922,"^[",1184,536926083]],["^15",[922,"^O","^16",536926079]],["^15",[922,"^@",false,536908135]],["^15",[922,"^Y","cast",536908135]],["^15",[922,"^11","Cast",536908135]],["^15",[922,"^B",1690969067724,536926128]],["^15",[922,"^;","~u64c20233-9f70-4bc1-aa41-ab965f32d4f7",536916340]],["^15",[923,"^K",1690033165273,536908135]],["^15",[923,"^@",false,536908135]],["^15",[923,"^Y","as",536908135]],["^15",[923,"^11","as",536908135]],["^15",[923,"^B",1690033165273,536908135]],["^15",[923,"^;","~u64c20233-273e-4166-b88e-e1260802a281",536916340]],["^15",[924,"^Q","[[Fully Qualified Syntax for Disambiguation]]",536917342]],["^15",[924,"^O","^16",536908135]],["^15",[924,"^F",494,536908135]],["^15",[924,"^X",242,536908135]],["^15",[924,"^V",242,536908135]],["^15",[924,"^U",242,536917343]],["^15",[924,"^U",1056,536917343]],["^15",[924,"^?",["^ "],536917342]],["^15",[924,"^H",1056,536917342]],["^15",[924,"^17",true,536908135]],["^15",[924,"^;","~u64bbdc0d-e609-4ee6-81a6-aea1ddd9b904",536908135]],["^15",[925,"^Q","",536908616]],["^15",[925,"^O","^16",536908616]],["^15",[925,"^@",false,536908616]],["^15",[925,"^F",926,536908721]],["^15",[925,"^X",253,536908616]],["^15",[925,"^V",253,536908616]],["^15",[925,"^U",253,536908617]],["^15",[925,"^?",["^ "],536908616]],["^15",[925,"^17",true,536908616]],["^15",[925,"^;","~u64bbde77-fdd8-4a8c-9464-a003212c4fc0",536908616]],["^15",[926,"^Q","",536908721]],["^15",[926,"^O","^16",536908721]],["^15",[926,"^@",false,536908721]],["^15",[926,"^F",789,536908721]],["^15",[926,"^X",253,536908721]],["^15",[926,"^V",253,536908721]],["^15",[926,"^U",253,536908722]],["^15",[926,"^?",["^ "],536908721]],["^15",[926,"^17",true,536908721]],["^15",[926,"^;","~u64bbe0d5-b77a-4fcf-a1f5-fd90b05ba61a",536908721]],["^15",[928,"^Q","Rust can automatically convert a [[Reference Type]] of [[Data Type]] ``A`` into a reference of type ``B`` if the type ``A`` implements the ``Deref`` [[Trait]] and its ``deref()`` [[Method]] returns a value of type ``&B``. \nThis is how [[String]]'s ``&String`` is automatically converted into ``&str`` as the trait is implemented for ``String``.\nSo if a [[Variable]]/ [[Function]]/ [[Method]]/etc. requires ``&B`` or in this case ``&str`` then we can pass ``&A`` or ``&String`` and Rust would automatically coerce the reference into that type using the dereference trait.\n\nFor ex.:\n```rust\nfn yo(x: &str) {}\n\nfn main() {\n let x = String::from(\"yo\");\n yo(&x); //works\n}\n```",536909540]],["^15",[928,"^O","^16",536909187]],["^15",[928,"^@",false,536909187]],["^15",[928,"^F",461,536909187]],["^15",[928,"^X",461,536909187]],["^15",[928,"^V",461,536909187]],["^15",[928,"^U",99,536909396]],["^15",[928,"^U",118,536909396]],["^15",[928,"^U",130,536909396]],["^15",[928,"^U",148,536909396]],["^15",[928,"^U",253,536909396]],["^15",[928,"^U",414,536909396]],["^15",[928,"^U",461,536909396]],["^15",[928,"^U",497,536909396]],["^15",[928,"^?",["^ "],536909540]],["^15",[928,"^H",99,536909540]],["^15",[928,"^H",118,536909540]],["^15",[928,"^H",130,536909540]],["^15",[928,"^H",148,536909540]],["^15",[928,"^H",253,536909540]],["^15",[928,"^H",414,536909540]],["^15",[928,"^H",497,536909540]],["^15",[928,"^17",true,536909187]],["^15",[928,"^;","~u64bbe44e-9aab-49d7-b398-f6f5b22ae214",536909187]],["^15",[929,"^3","- Rust can automatically convert a [[Reference Type]] of [[Data Type]] ``A`` into a reference of type ``B`` if the type ``A`` implements the ``Deref`` [[Trait]] and its ``deref()`` [[Method]] returns a value of type ``&B``. \n  This is how [[String]]'s ``&String`` is automatically converted into ``&str`` as the trait is implemented for ``String``.\n  So if a [[Variable]]/ [[Function]]/ [[Method]]/etc. requires ``&B`` or in this case ``&str`` then we can pass ``&A`` or ``&String`` and Rust would automatically coerce the reference into that type using the dereference trait.\n  \n  For ex.:\n  ```rust\n  fn yo(x: &str) {}\n  \n  fn main() {\n   let x = String::from(\"yo\");\n   yo(&x); //works\n  }\n  ```\n- Rust can follow the deref chain so if ``&A``->``&B`` is ``&A``->``&C``->``&B`` then coercion will still work.\n- Deref coercion is resolved at compile-time itself. So there is no runtime cost.",536909607]],["^15",[929,"^18","~m1690035741541",536909606]],["^15",[929,"^Z","pages/Deref Coercion.md",536909242]],["^15",[930,"^Q","Rust can follow the deref chain so if ``&A``->``&B`` is ``&A``->``&C``->``&B`` then coercion will still work.",536909587]],["^15",[930,"^O","^16",536909540]],["^15",[930,"^@",false,536909540]],["^15",[930,"^F",928,536909540]],["^15",[930,"^X",461,536909540]],["^15",[930,"^V",461,536909540]],["^15",[930,"^U",461,536909541]],["^15",[930,"^?",["^ "],536909587]],["^15",[930,"^17",true,536909540]],["^15",[930,"^;","~u64bbe5b8-96d5-43bf-95ce-ce9e06c40de9",536909540]],["^15",[931,"^Q","Deref coercion is resolved at compile-time itself. So there is no runtime cost.",536909605]],["^15",[931,"^O","^16",536909580]],["^15",[931,"^@",false,536909580]],["^15",[931,"^F",930,536909580]],["^15",[931,"^X",461,536909580]],["^15",[931,"^V",461,536909580]],["^15",[931,"^U",461,536909581]],["^15",[931,"^?",["^ "],536909605]],["^15",[931,"^17",true,536909580]],["^15",[931,"^;","~u64bbe5d4-e8b8-43b6-b8d6-1863bbe815fb",536909580]],["^15",[934,"^Q","~``Drop`` Trait\nThis trait needs implementation for the ``drop`` [[Method]] which takes a mutable [[Borrow]] of ``self`` and then runs some cleanup/deallocation code. The ``drop`` method is called automatically by the Rust compiler when the instance of the type goes out of [[Scope]]. ``Drop`` trait is included in the [[Prelude]]. Basically, the ``drop()`` method is much like a *Destructor* from other languages.\n\nFor ex.:\n```rust\nstruct MyT{ yo:i32 }\nimpl Drop for MyT {\n\tfn drop(&mut self) {\n\t//do something with self.yo. \n }\n}\n```\n\n* Smart-[[Pointer]]s implement this trait.\n\n* We can't explicitly call the ``drop()`` [[Method]] as it leads to the *Double Free* error. So, Rust provides a way to let the compiler know as well as call it early. It is the ``std::mem::drop(<value of type T that implements Drop>)`` [[Function]] in the [[Prelude]].\nFor ex.:\n```rust\nfn main() {\n let x = Box::new(2);\n drop(x); //works\n}\n```",536910790]],["^15",[934,"^O","^16",536909944]],["^15",[934,"^@",false,536909944]],["^15",[934,"^F",818,536909944]],["^15",[934,"^X",414,536909944]],["^15",[934,"^V",414,536909944]],["^15",[934,"^U",89,536910182]],["^15",[934,"^U",130,536910182]],["^15",[934,"^U",254,536910182]],["^15",[934,"^U",414,536910182]],["^15",[934,"^U",497,536910182]],["^15",[934,"^U",525,536910182]],["^15",[934,"^U",878,536910182]],["^15",[934,"^H",89,536916346]],["^15",[934,"^H",130,536916346]],["^15",[934,"^H",254,536916346]],["^15",[934,"^H",497,536916346]],["^15",[934,"^H",525,536916346]],["^15",[934,"^H",878,536916346]],["^15",[934,"^17",true,536909944]],["^15",[934,"^;","~u64bbf0d2-a382-4da8-b3a3-aaf8eb23728b",536909944]],["^15",[935,"^U",414,536909956]],["^15",[936,"^U",414,536909956]],["^15",[937,"^U",414,536909956]],["^15",[938,"^U",414,536909956]],["^15",[939,"^U",414,536909956]],["^15",[940,"^U",414,536909956]],["^15",[941,"^U",414,536909956]],["^15",[942,"^U",414,536909956]],["^15",[943,"^U",414,536909956]],["^15",[944,"^Q","~``Send`` and ``Sync`` Traits\nDefined in ``std::marker``.\n\nThe send trait indicates the [[Ownership]] of the [[Data Type]] that implements it can be transferred between threads. Almost all types in Rust implement it, but not types such as [[Rc<T>]]. \n\nSimilarly, the sync trait indicates the type implementing it is safe to be accessed from multiple threads. \n\n* Both of these are known as marker traits as they are in the marker Module and they have no [[Method]]s to implement either, they just mark a type and are used to indicate rust's concurrency rules are followed. \nStill, we can have custom implementation for both but that is part of [[unsafe]] Rust. \n* All primitive types implement both of these. \n* If a type is composed only of Send Trait implementing types then that type implicitly implements the send trait as well. Same with Sync trait as well.\n* These traits are [[unsafe]].",536916346]],["^15",[944,"^O","^16",536910071]],["^15",[944,"^@",false,536910071]],["^15",[944,"^F",934,536910071]],["^15",[944,"^X",414,536910071]],["^15",[944,"^V",414,536910071]],["^15",[944,"^U",148,536914793]],["^15",[944,"^U",255,536914793]],["^15",[944,"^U",414,536914793]],["^15",[944,"^U",497,536914793]],["^15",[944,"^U",906,536914793]],["^15",[944,"^U",953,536914793]],["^15",[944,"^H",148,536916346]],["^15",[944,"^H",255,536916346]],["^15",[944,"^H",497,536916346]],["^15",[944,"^H",906,536916346]],["^15",[944,"^H",953,536916346]],["^15",[944,"^17",true,536910071]],["^15",[944,"^;","~u64bbf20f-3b99-4c4e-87b2-0d3f62607be4",536910071]],["^15",[946,"^Q","Aka *Reference Counting*. This [[Data Type]] is a [[Pointer]] that is meant to give [[Ownership]] to multiple owners. Like a graph node might have multiple parents.\n\nDefined in ``std::rc::Rc`` [[Module]] in the [[Standard Library]]\n\nFor ex.:\n```rust\nuse std::rc::Rc;\n\nfn main() {\n let a= Rc::new(10);\n let b = Rc::clone(&a); //is the same as a.clone();\n}\n```\nWe use the ``clone()`` [[Method]] in the ``Rc`` [[Struct]] directly instead of using the ``.clone()`` instance method just for convention. It helps show that the Rc's clone is called and not a normal clone as on other types, they do the same thing for ``Rc``. The reason we do this is also because a normal clone on other [[Data Type]]s deep copies the values, but for an ``Rc``, this method returns an ``Rc`` and internally points to the same [[Reference Type]]. It also mutably increases an internal reference count to know how many references of the data are alive.\nThe ``Drop`` [[Trait]] then reduces the references counter and when it reaches 0, clears up the data.",536910560]],["^15",[946,"^O","^16",536910275]],["^15",[946,"^@",false,536910275]],["^15",[946,"^F",906,536910275]],["^15",[946,"^X",906,536910275]],["^15",[946,"^V",906,536910275]],["^15",[946,"^U",93,536910548]],["^15",[946,"^U",148,536910548]],["^15",[946,"^U",242,536910548]],["^15",[946,"^U",253,536910548]],["^15",[946,"^U",255,536910548]],["^15",[946,"^U",414,536910548]],["^15",[946,"^U",497,536910548]],["^15",[946,"^U",530,536910548]],["^15",[946,"^U",878,536910548]],["^15",[946,"^U",906,536910548]],["^15",[946,"^?",["^ "],536910560]],["^15",[946,"^H",93,536910560]],["^15",[946,"^H",148,536910560]],["^15",[946,"^H",242,536910560]],["^15",[946,"^H",253,536910560]],["^15",[946,"^H",255,536910560]],["^15",[946,"^H",414,536910560]],["^15",[946,"^H",497,536910560]],["^15",[946,"^H",530,536910560]],["^15",[946,"^H",878,536910560]],["^15",[946,"^17",true,536910275]],["^15",[946,"^;","~u64bbf430-303c-41ad-9188-371815492d7c",536910275]],["^15",[947,"^3","- Aka *Reference Counting*. This [[Data Type]] is a [[Pointer]] that is meant to give [[Ownership]] to multiple owners. Like a graph node might have multiple parents.\n  \n  Defined in ``std::rc::Rc`` [[Module]] in the [[Standard Library]]\n  \n  For ex.:\n  ```rust\n  use std::rc::Rc;\n  \n  fn main() {\n   let a= Rc::new(10);\n   let b = Rc::clone(&a); //is the same as a.clone();\n  }\n  ```\n  We use the ``clone()`` [[Method]] in the ``Rc`` [[Struct]] directly instead of using the ``.clone()`` instance method just for convention. It helps show that the Rc's clone is called and not a normal clone as on other types, they do the same thing for ``Rc``. The reason we do this is also because a normal clone on other [[Data Type]]s deep copies the values, but for an ``Rc``, this method returns an ``Rc`` and internally points to the same [[Reference Type]]. It also mutably increases an internal reference count to know how many references of the data are alive.\n  The ``Drop`` [[Trait]] then reduces the references counter and when it reaches 0, clears up the data.\n- Strong Reference ``strong_count`` and  Weak Reference``weak_count``\n  Just like *Shared Pointer* in *C++* has a weak and a strong reference, so does ``Rc``. The strong count prevents cleanup of the data whereas weak count doesn't so if we have a weak clone of ``Rc`` , it may become have an invalid [[Reference Type]] if the strong count drops to 0.\n  \n  Using ``Rc::clone(&<Rc instance>)`` we get a strong reference of type ``Rc<T>``, and that shares the [[Ownership]] of the data within, it also bumps the ``strong_count`` by 1. With ``Rc::downgrade(&<Rc instance>)``  we instead get a value of type [[Weak<T>]] and the ``weak_count`` of ``Rc`` is increased by 1. \n  Since it is not guaranteed if the value referenced by the [[Weak<T>]] will be valid, we have to explicitly check. We do so with ``<Weak<T> instance>.upgrade()`` which returns an [[Option Type]] ``Option<Rc<T>>`` which is ``Some`` if the reference is still valid or ``None`` otherwise. \n  \n  \n  * The ``Rc::strong_count(&<Rc Type instance>)`` returns the strong count of the given ``Rc`` instance.\n  \n  * Similarly, ``Rc::weak_count(&<Rc Type instance>)`` returns the weak count.\n  \n  For ex.:\n  ```rust\n  use std::rc::Rc;\n  fn main() {\n      let a= Rc::new(2);\n      let b= Rc::downgrade(&a);\n      let c= b.upgrade();\n      match c {\n       Some(value)=> println!(\"{}\", *value), //prints 2\n       None=> println!(\"na\");\n      };\n  }\n  ```\n-\n-",536911873]],["^15",[947,"^18","~m1690043542911",536911872]],["^15",[947,"^Z","pages/Rc%3CT%3E.md",536910279]],["^15",[948,"^Q","",536910342]],["^15",[948,"^O","^16",536910342]],["^15",[948,"^@",false,536910342]],["^15",[948,"^F",950,536911864]],["^15",[948,"^X",906,536910342]],["^15",[948,"^V",906,536910342]],["^15",[948,"^U",906,536910343]],["^15",[948,"^?",["^ "],536910342]],["^15",[948,"^17",true,536910342]],["^15",[948,"^;","~u64bbf4d0-7b28-48c0-bcb9-eb4a49e84ac0",536910342]],["^15",[949,"^Q","Strong Reference ``strong_count`` and  Weak Reference``weak_count``\nJust like *Shared Pointer* in *C++* has a weak and a strong reference, so does ``Rc``. The strong count prevents cleanup of the data whereas weak count doesn't so if we have a weak clone of ``Rc`` , it may become have an invalid [[Reference Type]] if the strong count drops to 0.\n\nUsing ``Rc::clone(&<Rc instance>)`` we get a strong reference of type ``Rc<T>``, and that shares the [[Ownership]] of the data within, it also bumps the ``strong_count`` by 1. With ``Rc::downgrade(&<Rc instance>)``  we instead get a value of type [[Weak<T>]] and the ``weak_count`` of ``Rc`` is increased by 1. \nSince it is not guaranteed if the value referenced by the [[Weak<T>]] will be valid, we have to explicitly check. We do so with ``<Weak<T> instance>.upgrade()`` which returns an [[Option Type]] ``Option<Rc<T>>`` which is ``Some`` if the reference is still valid or ``None`` otherwise. \n\n\n* The ``Rc::strong_count(&<Rc Type instance>)`` returns the strong count of the given ``Rc`` instance.\n\n* Similarly, ``Rc::weak_count(&<Rc Type instance>)`` returns the weak count.\n\nFor ex.:\n```rust\nuse std::rc::Rc;\nfn main() {\n    let a= Rc::new(2);\n    let b= Rc::downgrade(&a);\n    let c= b.upgrade();\n    match c {\n     Some(value)=> println!(\"{}\", *value), //prints 2\n     None=> println!(\"na\");\n    };\n}\n```",536911871]],["^15",[949,"^O","^16",536910563]],["^15",[949,"^@",false,536910563]],["^15",[949,"^F",946,536910563]],["^15",[949,"^X",906,536910563]],["^15",[949,"^V",906,536910563]],["^15",[949,"^U",228,536911753]],["^15",[949,"^U",253,536911753]],["^15",[949,"^U",255,536911753]],["^15",[949,"^U",906,536911753]],["^15",[949,"^U",968,536911753]],["^15",[949,"^?",["^ "],536911871]],["^15",[949,"^H",228,536911871]],["^15",[949,"^H",253,536911871]],["^15",[949,"^H",255,536911871]],["^15",[949,"^H",968,536911871]],["^15",[949,"^17",true,536910563]],["^15",[949,"^;","~u64bbf629-d099-4f40-a165-9c0ffa889b76",536910563]],["^15",[950,"^Q","",536910752]],["^15",[950,"^O","^16",536910752]],["^15",[950,"^@",false,536910752]],["^15",[950,"^F",949,536910752]],["^15",[950,"^X",906,536910752]],["^15",[950,"^V",906,536911864]],["^15",[950,"^U",228,536911865]],["^15",[950,"^U",253,536911865]],["^15",[950,"^U",255,536911865]],["^15",[950,"^U",906,536911865]],["^15",[950,"^U",968,536911865]],["^15",[950,"^?",["^ "],536910752]],["^15",[950,"^17",true,536910752]],["^15",[950,"^;","~u64bbf758-614b-4740-85fa-db88e29fed87",536910752]],["^15",[953,"^K",1690041729737,536910916]],["^15",[953,"^[",955,536910943]],["^15",[953,"^O","^16",536910938]],["^15",[953,"^@",false,536910916]],["^15",[953,"^Y","unsafe",536910916]],["^15",[953,"^11","unsafe",536910916]],["^15",[953,"^B",1690042129513,536911132]],["^15",[953,"^;","~u64c20233-0724-4855-8481-6b7becae2791",536916352]],["^15",[954,"^Q","Many of Rust's compile-time checks can be bypassed by unsafe rust. This allows more control over the behavior of the code however the checks aren't even performed and it's the duty of the programmers to ensure the code does not cause issues at runtime.\n\nRust is inherently conservative with its rules at compile-time. That is, it would rather fail a correct program than allow a potentially error-causing code to run. By using unsafe rust, we disable these checks at compile time and taking the various guarantees in our hands.\n\nTo use unsafe rust, we have a [[Scope]] block that starts with the ``unsafe`` keyword. \nFor ex.:\n```rust\nunsafe fn foo() {}\nfn main() {\n    unsafe {\n        foo();\n    }\n}\n\n```\n\nThe unsafe blocks don't completely disable Rust's compile-time rules, they simply allow the unsafe superpowers to execute which would be disallowed in normal blocks.",536916349]],["^15",[954,"^O","^16",536910939]],["^15",[954,"^@",false,536910939]],["^15",[954,"^F",953,536910939]],["^15",[954,"^X",953,536910939]],["^15",[954,"^V",953,536910939]],["^15",[954,"^U",89,536916349]],["^15",[954,"^U",953,536910940]],["^15",[954,"^H",89,536916349]],["^15",[954,"^17",true,536910939]],["^15",[954,"^;","~u64bbfd9c-ec10-42d1-ae88-24a00728e1d6",536910939]],["^15",[955,"^3","- Many of Rust's compile-time checks can be bypassed by unsafe rust. This allows more control over the behavior of the code however the checks aren't even performed and it's the duty of the programmers to ensure the code does not cause issues at runtime.\n  \n  Rust is inherently conservative with its rules at compile-time. That is, it would rather fail a correct program than allow a potentially error-causing code to run. By using unsafe rust, we disable these checks at compile time and taking the various guarantees in our hands.\n  \n  To use unsafe rust, we have a [[Scope]] block that starts with the ``unsafe`` keyword. \n  For ex.:\n  ```rust\n  unsafe fn foo() {}\n  fn main() {\n      unsafe {\n          foo();\n      }\n  }\n  \n  ```\n  \n  The unsafe blocks don't completely disable Rust's compile-time rules, they simply allow the unsafe superpowers to execute which would be disallowed in normal blocks.\n- unsafe superpowers\n  5 actions can be done in unsafe rust (inside the unsafe block), they are\n  * Dereferencing a Raw [[Pointer]] \n  * Calling an unsafe [[Function]]/ [[Method]]: \n  We declare [[Function]]s/ [[Method]]s as ``unsafe``. Then the entire function body is unsafe. We can only call these functions from unsafe blocks.\n  \n  For ex.:\n  ```rust\n  unsafe fn foo() {}\n  fn main() {\n      unsafe {\n          foo();\n      }\n  }\n  \n  ```\n  It is advisable to not mark functions as ``unsafe``, rather use unsafe blocks inside them. This way we create a safe abstraction over an unsafe code. \n  \n  This is required with [[extern]] methods.\n  * Access/Modify mutable static [[Variable]]s:\n  * Implement an unsafe [[Trait]]\n  * Access fields of [[union]]s\n-",536916349]],["^15",[955,"^18","~m1690335976541",536916350]],["^15",[955,"^Z","pages/unsafe.md",536910943]],["^15",[956,"^Q","",536910995]],["^15",[956,"^O","^16",536910995]],["^15",[956,"^@",false,536910995]],["^15",[956,"^F",1046,536916349]],["^15",[956,"^X",953,536910995]],["^15",[956,"^V",953,536910995]],["^15",[956,"^U",953,536910996]],["^15",[956,"^17",true,536910995]],["^15",[956,"^;","~u64bbfde2-7e77-44c7-b107-acb057339fe4",536910995]],["^15",[957,"^Q","",536911045]],["^15",[957,"^O","^16",536911045]],["^15",[957,"^F",874,536911045]],["^15",[957,"^X",254,536911045]],["^15",[957,"^V",254,536911045]],["^15",[957,"^U",254,536911046]],["^15",[957,"^?",["^ "],536911045]],["^15",[957,"^17",true,536911045]],["^15",[957,"^;","~u64bbfe0a-1541-414c-9910-1e9ca43ecb0d",536911045]],["^15",[958,"^Q","Much like [[Rc<T>]]. However it uses the [[Interior Mutability Pattern]] to do something other [[Pointer]]s can't. It allows immutable references from mutable [[Reference Type]]s. \nDefined in the ``std::cell::RefCell`` [[Module]] in the [[Standard Library]].\n \nFor ex.:\n```rust\nuse std::cell::RefCell;\nfn main() {\n    let a= RefCell::new(2);\n    let b= &a;\n    let mut c= b.borrow_mut();\n    *c=3; //works\n}\n```\n\nThe ``.borrow()`` [[Method]] returns a ``Ref<T>`` instance and ``.borrow_mut()`` returns a ``RefMut<T>`` instance, this instance has mutable [[Reference Type]] to the data inside ``RefCell``.",536914505]],["^15",[958,"^O","^16",536911137]],["^15",[958,"^@",false,536911137]],["^15",[958,"^F",903,536911137]],["^15",[958,"^X",903,536911137]],["^15",[958,"^V",903,536911137]],["^15",[958,"^U",93,536914506]],["^15",[958,"^U",253,536914506]],["^15",[958,"^U",497,536914506]],["^15",[958,"^U",530,536914506]],["^15",[958,"^U",878,536914506]],["^15",[958,"^U",903,536914506]],["^15",[958,"^U",906,536914506]],["^15",[958,"^U",1011,536914506]],["^15",[958,"^?",["^ "],536914505]],["^15",[958,"^H",93,536914505]],["^15",[958,"^H",253,536914505]],["^15",[958,"^H",497,536914505]],["^15",[958,"^H",530,536914505]],["^15",[958,"^H",878,536914505]],["^15",[958,"^H",906,536914505]],["^15",[958,"^H",1011,536914505]],["^15",[958,"^17",true,536911137]],["^15",[958,"^;","~u64bbff62-02e1-4e45-8ee6-1844f03576eb",536911137]],["^15",[959,"^3","- Much like [[Rc<T>]]. However it uses the [[Interior Mutability Pattern]] to do something other [[Pointer]]s can't. It allows immutable references from mutable [[Reference Type]]s. \n  Defined in the ``std::cell::RefCell`` [[Module]] in the [[Standard Library]].\n   \n  For ex.:\n  ```rust\n  use std::cell::RefCell;\n  fn main() {\n      let a= RefCell::new(2);\n      let b= &a;\n      let mut c= b.borrow_mut();\n      *c=3; //works\n  }\n  ```\n  \n  The ``.borrow()`` [[Method]] returns a ``Ref<T>`` instance and ``.borrow_mut()`` returns a ``RefMut<T>`` instance, this instance has mutable [[Reference Type]] to the data inside ``RefCell``.\n- ``RefCell`` keeps a track of all its immutable and mutable [[Reference Type]]s like [[Rc<T>]].\n  This allows there to be any number of immutable references, or a single mutable reference to a value at any time. This is exactly like [[Reference Type]] mutability rules. However, a big difference is that instead of the compiler failing to compile code that violates this rule, we get [[Panic]] at runtime instead.\n-",536914508]],["^15",[959,"^18","~m1690127614264",536914507]],["^15",[959,"^Z","pages/RefCell%3CT%3E.md",536911141]],["^15",[960,"^Q","",536911310]],["^15",[960,"^O","^16",536911310]],["^15",[960,"^@",false,536911310]],["^15",[960,"^F",962,536911360]],["^15",[960,"^X",903,536911310]],["^15",[960,"^V",903,536911310]],["^15",[960,"^U",903,536911311]],["^15",[960,"^?",["^ "],536911310]],["^15",[960,"^17",true,536911310]],["^15",[960,"^;","~u64bc004a-4ad4-402b-b91b-e3021568d634",536911310]],["^15",[961,"^U",903,536911354]],["^15",[962,"^Q","~``RefCell`` keeps a track of all its immutable and mutable [[Reference Type]]s like [[Rc<T>]].\nThis allows there to be any number of immutable references, or a single mutable reference to a value at any time. This is exactly like [[Reference Type]] mutability rules. However, a big difference is that instead of the compiler failing to compile code that violates this rule, we get [[Panic]] at runtime instead.",536911472]],["^15",[962,"^O","^16",536911360]],["^15",[962,"^@",false,536911360]],["^15",[962,"^F",958,536911360]],["^15",[962,"^X",903,536911360]],["^15",[962,"^V",903,536911360]],["^15",[962,"^U",219,536911454]],["^15",[962,"^U",253,536911454]],["^15",[962,"^U",903,536911454]],["^15",[962,"^U",906,536911454]],["^15",[962,"^?",["^ "],536911472]],["^15",[962,"^H",219,536911472]],["^15",[962,"^H",253,536911472]],["^15",[962,"^H",906,536911472]],["^15",[962,"^17",true,536911360]],["^15",[962,"^;","~u64bc00a3-6a04-4d2a-820a-28cfe970a241",536911360]],["^15",[963,"^K",1690042720313,536911475]],["^15",[963,"^[",965,536911493]],["^15",[963,"^O","^16",536911479]],["^15",[963,"^@",false,536911475]],["^15",[963,"^Y","cell<t>",536911475]],["^15",[963,"^11","Cell<T>",536911475]],["^15",[963,"^B",1690042788656,536911539]],["^15",[963,"^;","~u64c20233-3035-4a55-8907-01505c2c845f",536916340]],["^15",[964,"^Q","Just like [[RefCell<T>]] but instead of a [[Reference Type]] to the same data, it internally creates new copies instead.",536911539]],["^15",[964,"^O","^16",536911480]],["^15",[964,"^@",false,536911480]],["^15",[964,"^F",963,536911480]],["^15",[964,"^X",963,536911480]],["^15",[964,"^V",963,536911480]],["^15",[964,"^U",253,536911527]],["^15",[964,"^U",903,536911527]],["^15",[964,"^U",963,536911527]],["^15",[964,"^?",["^ "],536911539]],["^15",[964,"^H",253,536911539]],["^15",[964,"^H",903,536911539]],["^15",[964,"^17",true,536911480]],["^15",[964,"^;","~u64bc0165-903b-4ae8-8e21-247e965a179a",536911480]],["^15",[965,"^3","- Just like [[RefCell<T>]] but instead of a [[Reference Type]] to the same data, it internally creates new copies instead.",536911541]],["^15",[965,"^18","~m1690042788737",536911540]],["^15",[965,"^Z","pages/Cell%3CT%3E.md",536911493]],["^15",[967,"^Q","",536911523]],["^15",[967,"^O","^16",536911523]],["^15",[967,"^@",false,536911523]],["^15",[967,"^?",["^ "],536911523]],["^15",[967,"^17",true,536911523]],["^15",[967,"^;","~u64bc0194-0b50-4bab-a3e2-163023a9dfc2",536911523]],["^15",[968,"^K",1690043252959,536911664]],["^15",[968,"^@",false,536911664]],["^15",[968,"^Y","weak<t>",536911664]],["^15",[968,"^11","Weak<T>",536911664]],["^15",[968,"^B",1690043252959,536911664]],["^15",[968,"^;","~u64bc0374-37b0-4a08-b348-75ea428f17f6",536911664]],["^15",[971,"^K",1690064216073,536911878]],["^15",[971,"^[",973,536911888]],["^15",[971,"^O","^16",536911880]],["^15",[971,"^@",false,536911878]],["^15",[971,"^Y","concurrency or parallelism",536914289]],["^15",[971,"^11","Concurrency or Parallelism",536914289]],["^15",[971,"^B",1690895771847,536921553]],["^15",[971,"^;","~u64c20233-1f73-4a4f-ab99-f63d272fb087",536916343]],["^15",[972,"^Q","Concurrency, many tasks ran independently of each other. Parallelism, many tasks ran parallelly.\ntitle:: Concurrency or Parallelism\nRust supports both types of asynchronous programming. The compile-time rules such as [[Ownership]], [[Borrow]] Checking, etc. help with async programming as well in Rust, making them less error prone.",536914289]],["^15",[972,"^O","^16",536911881]],["^15",[972,"^@",false,536911881]],["^15",[972,"^F",971,536911881]],["^15",[972,"^X",971,536911881]],["^15",[972,"^V",971,536911881]],["^15",[972,"^U",254,536912027]],["^15",[972,"^U",255,536912027]],["^15",[972,"^U",971,536912027]],["^15",[972,"^?",["^ "],536912064]],["^15",[972,"^H",254,536912064]],["^15",[972,"^H",255,536912064]],["^15",[972,"^17",true,536911881]],["^15",[972,"^;","~u64bc5558-b443-4af4-be6e-831592d0b39c",536911881]],["^15",[973,"^3","- Concurrency, many tasks ran independently of each other. Parallelism, many tasks ran parallelly.\n  title:: Concurrency or Parallelism\n  Rust supports both types of asynchronous programming. The compile-time rules such as [[Ownership]], [[Borrow]] Checking, etc. help with async programming as well in Rust, making them less error prone.\n- *Process*\n  An OS runs a single program in a single *Process*, this is managed and scheduled by it as well. A single program can have multiple parts which run independently, these are known as [[Thread]]s.\n- [[Channel]]s\n- [[Mutex<T>]]\n- [[Async and Await]]",536921556]],["^15",[973,"^18","~m1690895772005",536921555]],["^15",[973,"^Z","pages/Concurrency or Parallelism.md",536914290]],["^15",[974,"^Q","*Process*\nAn OS runs a single program in a single *Process*, this is managed and scheduled by it as well. A single program can have multiple parts which run independently, these are known as [[Thread]]s.",536912022]],["^15",[974,"^O","^16",536911950]],["^15",[974,"^@",false,536911950]],["^15",[974,"^F",972,536911950]],["^15",[974,"^X",971,536911950]],["^15",[974,"^V",971,536911950]],["^15",[974,"^U",822,536911955]],["^15",[974,"^U",971,536911955]],["^15",[974,"^?",["^ "],536912022]],["^15",[974,"^H",822,536912022]],["^15",[974,"^17",true,536911950]],["^15",[974,"^;","~u64bc5598-13e6-4d77-94b2-7ca80effdf06",536911950]],["^15",[975,"^Q","Rust follows a 1:1 threading model, meaning 1 Rust thread will take exactly 1 thread in the OS.\n\nDefined in ``std::Thread``.\nFor ex.:\n```rust\nuse std::{thread, time::Duration};\nfn main(){\n    \n    let handle= thread::spawn(|| {\n        println!(\"yo\");\n        for i in 1..20 {\n            println!(\"{}\",i);\n        }\n    });\n \n    println!(\"enddd\");\n    thread::sleep(Duration::from_millis(10));\n }\n\n```\n* ``thread::spawn(<closure>)`` to spawn a thread and execute the given [[Closure]]. \n\nReturns a ``JoinHandle<T>`` [[Data Type]]. Here ``T`` is the return type of the closure, so if nothing is returned by the closure it is the [[Unit Type]].\n\n* ``JoinHandle`` has a ``join()`` [[Method]] which stops the current thread's execution until the thread handled by the handle finishes execution.\nThe thread that spawns another thread does not wait for the other thread to finish, and if it's the *Main Thread* that finishes without waiting for all its spawned threads then it might die before them and the OS kills the process when the *MT* dies so they may never finish as all of them are cleared up.\n\n``join()`` returns an [[Result Type]] which represents the value of closure if the thread finishes successfully and an error otherwise. \n\nFor ex.:\n```rust\nuse std::{thread, time::Duration};\nfn main(){\n    \n    let handle= thread::spawn(|| {\n        println!(\"yo\");\n        for i in 1..20 {\n            println!(\"{}\",i);\n        }\n    });\n   handle.join().unwrap(); //waits and returns the value of the closure.\n    \n    \n\n }\n``` \n\n* [[Closure]]'s passed to other threads must be ``move``d if they capture some variable from thread, this is because it may be that the [[Lifetime]] of the [[Variable]] is over before the spawned thread can use the captured value. \n* ``thread::sleep(<Duration instance>)`` to sleep a thread with the given ``Duration``.",536912754]],["^15",[975,"^O","^16",536911959]],["^15",[975,"^@",false,536911959]],["^15",[975,"^F",822,536911959]],["^15",[975,"^X",822,536911959]],["^15",[975,"^V",822,536911959]],["^15",[975,"^U",99,536912739]],["^15",[975,"^U",148,536912739]],["^15",[975,"^U",211,536912739]],["^15",[975,"^U",280,536912739]],["^15",[975,"^U",497,536912739]],["^15",[975,"^U",687,536912739]],["^15",[975,"^U",714,536912739]],["^15",[975,"^U",822,536912739]],["^15",[975,"^?",["^ "],536912754]],["^15",[975,"^H",99,536912754]],["^15",[975,"^H",148,536912754]],["^15",[975,"^H",211,536912754]],["^15",[975,"^H",280,536912754]],["^15",[975,"^H",497,536912754]],["^15",[975,"^H",687,536912754]],["^15",[975,"^H",714,536912754]],["^15",[975,"^17",true,536911959]],["^15",[975,"^;","~u64bc55c0-8fc2-4c70-931b-34c5c98b754b",536911959]],["^15",[976,"^3","- Rust follows a 1:1 threading model, meaning 1 Rust thread will take exactly 1 thread in the OS.\n  \n  Defined in ``std::Thread``.\n  For ex.:\n  ```rust\n  use std::{thread, time::Duration};\n  fn main(){\n      \n      let handle= thread::spawn(|| {\n          println!(\"yo\");\n          for i in 1..20 {\n              println!(\"{}\",i);\n          }\n      });\n   \n      println!(\"enddd\");\n      thread::sleep(Duration::from_millis(10));\n   }\n  \n  ```\n  * ``thread::spawn(<closure>)`` to spawn a thread and execute the given [[Closure]]. \n  \n  Returns a ``JoinHandle<T>`` [[Data Type]]. Here ``T`` is the return type of the closure, so if nothing is returned by the closure it is the [[Unit Type]].\n  \n  * ``JoinHandle`` has a ``join()`` [[Method]] which stops the current thread's execution until the thread handled by the handle finishes execution.\n  The thread that spawns another thread does not wait for the other thread to finish, and if it's the *Main Thread* that finishes without waiting for all its spawned threads then it might die before them and the OS kills the process when the *MT* dies so they may never finish as all of them are cleared up.\n  \n  ``join()`` returns an [[Result Type]] which represents the value of closure if the thread finishes successfully and an error otherwise. \n  \n  For ex.:\n  ```rust\n  use std::{thread, time::Duration};\n  fn main(){\n      \n      let handle= thread::spawn(|| {\n          println!(\"yo\");\n          for i in 1..20 {\n              println!(\"{}\",i);\n          }\n      });\n     handle.join().unwrap(); //waits and returns the value of the closure.\n      \n      \n  \n   }\n  ``` \n  \n  * [[Closure]]'s passed to other threads must be ``move``d if they capture some variable from thread, this is because it may be that the [[Lifetime]] of the [[Variable]] is over before the spawned thread can use the captured value. \n  * ``thread::sleep(<Duration instance>)`` to sleep a thread with the given ``Duration``.\n-\n-",536912756]],["^15",[976,"^18","~m1690065661209",536912755]],["^15",[976,"^Z","pages/Thread.md",536912071]],["^15",[978,"^Q","",536912126]],["^15",[978,"^O","^16",536912126]],["^15",[978,"^@",false,536912126]],["^15",[978,"^F",980,536912189]],["^15",[978,"^X",822,536912126]],["^15",[978,"^V",822,536912126]],["^15",[978,"^U",822,536912127]],["^15",[978,"^?",["^ "],536912126]],["^15",[978,"^17",true,536912126]],["^15",[978,"^;","~u64bc570e-f2c3-4e9d-ad14-ad1d6d46d424",536912126]],["^15",[980,"^Q","",536912615]],["^15",[980,"^O","^16",536912189]],["^15",[980,"^@",false,536912189]],["^15",[980,"^F",975,536912326]],["^15",[980,"^X",822,536912189]],["^15",[980,"^V",822,536912189]],["^15",[980,"^U",822,536912190]],["^15",[980,"^?",["^ "],536912615]],["^15",[980,"^17",true,536912189]],["^15",[980,"^;","~u64bc575f-5d72-47e0-a6c4-4639a3e42dd5",536912189]],["^15",[981,"^12",2,536912758]],["^15",[984,"^Q","[[Channel]]s",536912781]],["^15",[984,"^O","^16",536912777]],["^15",[984,"^@",false,536912777]],["^15",[984,"^F",974,536912777]],["^15",[984,"^X",971,536912777]],["^15",[984,"^V",971,536912777]],["^15",[984,"^U",971,536912782]],["^15",[984,"^U",985,536912782]],["^15",[984,"^?",["^ "],536912781]],["^15",[984,"^H",985,536912781]],["^15",[984,"^17",true,536912777]],["^15",[984,"^;","~u64bd3f3c-552b-44fe-98f9-1936fa3202f9",536912777]],["^15",[985,"^K",1690124098114,536912781]],["^15",[985,"^[",987,536912790]],["^15",[985,"^O","^16",536912785]],["^15",[985,"^@",false,536912781]],["^15",[985,"^Y","channel",536912781]],["^15",[985,"^11","Channel",536912781]],["^15",[985,"^B",1690125480185,536913565]],["^15",[985,"^;","~u64bd3f42-d37d-4d5c-8478-252dfd13e081",536912781]],["^15",[986,"^Q","Just like Go, Rust has the concept of passing messages between [[Thread]]s using channels. These are defined in ``std::sync``. Every channel has 2 ends, a *Transmitter* (let's call it tx) which we use to send some data and a *Receiver* (rx), which we use to receive the sent data.",536913469]],["^15",[986,"^O","^16",536912786]],["^15",[986,"^@",false,536912786]],["^15",[986,"^F",985,536912786]],["^15",[986,"^X",985,536912786]],["^15",[986,"^V",985,536912786]],["^15",[986,"^U",822,536913470]],["^15",[986,"^U",985,536913470]],["^15",[986,"^?",["^ "],536913469]],["^15",[986,"^H",822,536913469]],["^15",[986,"^17",true,536912786]],["^15",[986,"^;","~u64bd3f42-bac8-4953-9989-239d3d813b1f",536912786]],["^15",[987,"^3","- Just like Go, Rust has the concept of passing messages between [[Thread]]s using channels. These are defined in ``std::sync``. Every channel has 2 ends, a *Transmitter* (let's call it tx) which we use to send some data and a *Receiver* (rx), which we use to receive the sent data.\n- ``mpsc``\n  ``mpsc`` is a multiple-producer single-consumer channel. It allows multiple txs but only a single rx. \n  \n  For ex.:\n  ```rust\n  use std::sync::mpsc;\n  use std::thread;\n  \n  fn main() {\n      let (tx, rx) = mpsc::channel();\n  \n      thread::spawn(move || {\n          let val = String::from(\"hi\");\n          tx.send(val).unwrap();\n      });\n       let received = rx.recv().unwrap();\n      println!(\"Got: {}\", received);\n  }\n  ```\n  We use [[Destructuring]] here to get them from the [[Tuple]] returned by ``channel()`` [[Method]].\n  \n  * The sender thread needs [[Ownership]] of both the tx and the value it is sending.\n  ``<tx>.send(<obj>)`` returns a [[Result Type]] which has denotes if the sending was successful or not.\n  \n  Similarly, the receiver thread needs ownership of the rx. Calling ``<rx>.recv()`` pauses the thread until the receiver receives the data. It then returns a [[Result Type]] if it got a value or an error (when a tx dies, all rx's receive an err attached to those tx's). There's a ``try_recv()`` variant which checks the channel and immediately returns without pausing the thread, it's receives an err if there was no value.\n  \n  * ``mpsc`` allows multiple tx's, these can be passed to different threads. But the same single receiver would receive them. We get multiple txs by calling ``<tx>.clone()`` on any tx.\n- Multiple values in the channel\n  For ex.:\n  ```rust\n  use std::sync::mpsc;\n  use std::{thread, time::Duration};\n  fn main() {\n      let (tx, rx) = mpsc::channel();\n      thread::spawn(move || {\n          for i in 1..10 {\n              tx.send(i).unwrap();\n              thread::sleep(Duration::from_millis(10))\n          }\n      });\n      for i in rx {\n          println!(\"{}\", i);\n     }\n  } \n  \n  ```\n  tx's and rx's of Rust channels implement [[Iterator]] and the rx loop waits for all values being sent to it. Then when the tx dies, the rx loop also finishes.\n-",536913568]],["^15",[987,"^18","~m1690125481208",536913569]],["^15",[987,"^Z","pages/Channel.md",536912790]],["^15",[990,"^Q","Multiple values in the channel\nFor ex.:\n```rust\nuse std::sync::mpsc;\nuse std::{thread, time::Duration};\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    thread::spawn(move || {\n        for i in 1..10 {\n            tx.send(i).unwrap();\n            thread::sleep(Duration::from_millis(10))\n        }\n    });\n    for i in rx {\n        println!(\"{}\", i);\n   }\n} \n\n```\ntx's and rx's of Rust channels implement [[Iterator]] and the rx loop waits for all values being sent to it. Then when the tx dies, the rx loop also finishes.",536913420]],["^15",[990,"^O","^16",536913315]],["^15",[990,"^@",false,536913315]],["^15",[990,"^F",992,536913484]],["^15",[990,"^X",985,536913315]],["^15",[990,"^V",985,536913315]],["^15",[990,"^U",692,536913362]],["^15",[990,"^U",985,536913362]],["^15",[990,"^?",["^ "],536913420]],["^15",[990,"^H",692,536913420]],["^15",[990,"^17",true,536913315]],["^15",[990,"^;","~u64bd4300-9941-4e0a-b86a-3951b566abcd",536913315]],["^15",[991,"^Q","",536913421]],["^15",[991,"^O","^16",536913421]],["^15",[991,"^@",false,536913421]],["^15",[991,"^F",990,536913421]],["^15",[991,"^X",985,536913421]],["^15",[991,"^V",985,536913421]],["^15",[991,"^U",985,536913422]],["^15",[991,"^?",["^ "],536913421]],["^15",[991,"^17",true,536913421]],["^15",[991,"^;","~u64bd43a8-1d76-4c2c-a587-d00b82bc2c1d",536913421]],["^15",[992,"^Q","~``mpsc``\n``mpsc`` is a multiple-producer single-consumer channel. It allows multiple txs but only a single rx. \n\nFor ex.:\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n     let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n```\nWe use [[Destructuring]] here to get them from the [[Tuple]] returned by ``channel()`` [[Method]].\n\n* The sender thread needs [[Ownership]] of both the tx and the value it is sending.\n``<tx>.send(<obj>)`` returns a [[Result Type]] which has denotes if the sending was successful or not.\n\nSimilarly, the receiver thread needs ownership of the rx. Calling ``<rx>.recv()`` pauses the thread until the receiver receives the data. It then returns a [[Result Type]] if it got a value or an error (when a tx dies, all rx's receive an err attached to those tx's). There's a ``try_recv()`` variant which checks the channel and immediately returns without pausing the thread, it's receives an err if there was no value.\n\n* ``mpsc`` allows multiple tx's, these can be passed to different threads. But the same single receiver would receive them. We get multiple txs by calling ``<tx>.clone()`` on any tx.",536913562]],["^15",[992,"^O","^16",536913471]],["^15",[992,"^@",false,536913471]],["^15",[992,"^F",986,536913471]],["^15",[992,"^X",985,536913471]],["^15",[992,"^V",985,536913471]],["^15",[992,"^U",194,536913541]],["^15",[992,"^U",204,536913541]],["^15",[992,"^U",255,536913541]],["^15",[992,"^U",497,536913541]],["^15",[992,"^U",687,536913541]],["^15",[992,"^U",985,536913541]],["^15",[992,"^?",["^ "],536913562]],["^15",[992,"^H",194,536913562]],["^15",[992,"^H",204,536913562]],["^15",[992,"^H",255,536913562]],["^15",[992,"^H",497,536913562]],["^15",[992,"^H",687,536913562]],["^15",[992,"^17",true,536913471]],["^15",[992,"^;","~u64bd4454-2bf3-4701-8e47-192c1495487a",536913471]],["^15",[993,"^U",985,536913485]],["^15",[994,"^Q","[[Mutex<T>]]",536913575]],["^15",[994,"^O","^16",536913571]],["^15",[994,"^@",false,536913571]],["^15",[994,"^F",984,536913571]],["^15",[994,"^X",971,536913571]],["^15",[994,"^V",971,536913571]],["^15",[994,"^U",971,536913576]],["^15",[994,"^U",995,536913576]],["^15",[994,"^?",["^ "],536913575]],["^15",[994,"^H",995,536913575]],["^15",[994,"^17",true,536913571]],["^15",[994,"^;","~u64bd45ce-c076-4ff1-9472-63cfa358f8ab",536913571]],["^15",[995,"^K",1690125782499,536913575]],["^15",[995,"^[",997,536913584]],["^15",[995,"^O","^16",536913579]],["^15",[995,"^@",false,536913575]],["^15",[995,"^Y","mutex<t>",536913575]],["^15",[995,"^11","Mutex<T>",536913575]],["^15",[995,"^B",1690127561572,536914465]],["^15",[995,"^;","~u64c20233-f554-4a20-8a0d-c51b6aaea240",536916340]],["^15",[996,"^Q","~``Mutex<T>``\nA mutex, stands for ``Mutual Exclusion`` is a concept that allows the same region of memory to be accessed by multiple [[Thread]]s. The way mutex achieves this is by *guarding* the data by only allowing a single thread to be able to access it at once.\n\nFor a thread to access data behind a mutex, it must \n* First acquire the lock to the mutex, this will be immediate if no other thread is using it, or the thread will have to wait till the using thread unlocks it.\n* Then it must unlock the mutex once it is done using it.\n\nIn Rust, it is defined in ``std::sync::Mutex`` and is a Smart-[[Pointer]] \nFor ex.:\n```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5); //type of m is Mutex<i32>\n\n    {\n        let mut num = m.lock().unwrap(); //num's type is MutexGuard\n        *num = 6;\n    }\n\n    println!(\"m = {:?}\", m); //prints 6\n}\n```\n\n``.lock()`` returns an [[Enum]] like [[Result Type]] called ``LockResult``, which returns an ``Err`` if acquiring the lock fails, which can be if the thread that originally had the lock [[Panic]]ked or died without unlocking the mutex. It's ``Ok(T)`` equivalent is a [[Data Type]] [[MutexGuard<T>]] which is a smart- [[Pointer]] to the data behind the mutex.\n\n[[MutexGuard<T>]] implements the ``Drop`` [[Trait]] to drop the lock of the mutex along with itself.\n\nAs we can see, mutex in Rust uses the [[Interior Mutability Pattern]]",536914465]],["^15",[996,"^O","^16",536913580]],["^15",[996,"^@",false,536913580]],["^15",[996,"^F",995,536913580]],["^15",[996,"^X",995,536913580]],["^15",[996,"^V",995,536913580]],["^15",[996,"^U",148,536914462]],["^15",[996,"^U",219,536914462]],["^15",[996,"^U",414,536914462]],["^15",[996,"^U",511,536914462]],["^15",[996,"^U",687,536914462]],["^15",[996,"^U",822,536914462]],["^15",[996,"^U",878,536914462]],["^15",[996,"^U",995,536914462]],["^15",[996,"^U",999,536914462]],["^15",[996,"^U",1011,536914462]],["^15",[996,"^?",["^ "],536914465]],["^15",[996,"^H",148,536914465]],["^15",[996,"^H",219,536914465]],["^15",[996,"^H",414,536914465]],["^15",[996,"^H",511,536914465]],["^15",[996,"^H",687,536914465]],["^15",[996,"^H",822,536914465]],["^15",[996,"^H",878,536914465]],["^15",[996,"^H",999,536914465]],["^15",[996,"^H",1011,536914465]],["^15",[996,"^17",true,536913580]],["^15",[996,"^;","~u64bd45d7-91d4-49e1-8c65-36a124380add",536913580]],["^15",[997,"^3","- ``Mutex<T>``\n  A mutex, stands for ``Mutual Exclusion`` is a concept that allows the same region of memory to be accessed by multiple [[Thread]]s. The way mutex achieves this is by *guarding* the data by only allowing a single thread to be able to access it at once.\n  \n  For a thread to access data behind a mutex, it must \n  * First acquire the lock to the mutex, this will be immediate if no other thread is using it, or the thread will have to wait till the using thread unlocks it.\n  * Then it must unlock the mutex once it is done using it.\n  \n  In Rust, it is defined in ``std::sync::Mutex`` and is a Smart-[[Pointer]] \n  For ex.:\n  ```rust\n  use std::sync::Mutex;\n  \n  fn main() {\n      let m = Mutex::new(5); //type of m is Mutex<i32>\n  \n      {\n          let mut num = m.lock().unwrap(); //num's type is MutexGuard\n          *num = 6;\n      }\n  \n      println!(\"m = {:?}\", m); //prints 6\n  }\n  ```\n  \n  ``.lock()`` returns an [[Enum]] like [[Result Type]] called ``LockResult``, which returns an ``Err`` if acquiring the lock fails, which can be if the thread that originally had the lock [[Panic]]ked or died without unlocking the mutex. It's ``Ok(T)`` equivalent is a [[Data Type]] [[MutexGuard<T>]] which is a smart- [[Pointer]] to the data behind the mutex.\n  \n  [[MutexGuard<T>]] implements the ``Drop`` [[Trait]] to drop the lock of the mutex along with itself.\n  \n  As we can see, mutex in Rust uses the [[Interior Mutability Pattern]]\n- Passing Mutex to multiple [[Thread]]s\n  This requires another smart [[Pointer]] as the [[Ownership]] to the ``Mutex`` is required for a thread to acquire a lock to it, and moving it to a different thread in a [[Closure]] is a one-way thing.\n  Furthermore we have to use pointers that can be safely shared across threads, such as [[Arc<T>]].\n  \n  For ex.:\n  ```rust\n  use std::sync::{Arc, Mutex};\n  use std::thread;\n  \n  fn main() {\n  let a= Arc::new(Mutex::new(3));\n  let b= Arc.clone(&a);\n  thread.spawn(move|| {\n  \tlet mut c= b.lock().unwrap();\n  \t*c= 5;\n  })\n  println!(“{}”, *b.lock().unwrap());\n  }\n  ```\n-",536914467]],["^15",[997,"^18","~m1690127561996",536914466]],["^15",[997,"^Z","pages/Mutex%3CT%3E.md",536913584]],["^15",[998,"^Q","Passing Mutex to multiple [[Thread]]s\nThis requires another smart [[Pointer]] as the [[Ownership]] to the ``Mutex`` is required for a thread to acquire a lock to it, and moving it to a different thread in a [[Closure]] is a one-way thing.\nFurthermore we have to use pointers that can be safely shared across threads, such as [[Arc<T>]].\n\nFor ex.:\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\nlet a= Arc::new(Mutex::new(3));\nlet b= Arc.clone(&a);\nthread.spawn(move|| {\n\tlet mut c= b.lock().unwrap();\n\t*c= 5;\n})\nprintln!(“{}”, *b.lock().unwrap());\n}\n```",536914424]],["^15",[998,"^O","^16",536913627]],["^15",[998,"^@",false,536913627]],["^15",[998,"^F",996,536913627]],["^15",[998,"^X",995,536913627]],["^15",[998,"^V",995,536913627]],["^15",[998,"^U",255,536914397]],["^15",[998,"^U",714,536914397]],["^15",[998,"^U",822,536914397]],["^15",[998,"^U",878,536914397]],["^15",[998,"^U",995,536914397]],["^15",[998,"^U",1002,536914396]],["^15",[998,"^?",["^ "],536914424]],["^15",[998,"^H",255,536914424]],["^15",[998,"^H",714,536914424]],["^15",[998,"^H",822,536914424]],["^15",[998,"^H",878,536914424]],["^15",[998,"^H",1002,536914424]],["^15",[998,"^17",true,536913627]],["^15",[998,"^;","~u64bd4621-025d-488d-aeb0-79308208a9c8",536913627]],["^15",[999,"^K",1690126448549,536913954]],["^15",[999,"^O","^16",536913976]],["^15",[999,"^@",false,536913954]],["^15",[999,"^Y","mutexguard<t>",536913980]],["^15",[999,"^11","MutexGuard<T>",536913980]],["^15",[999,"^B",1690126448549,536913954]],["^15",[999,"^;","~u64c20233-5020-43f2-be3b-107bcccb4fe8",536916340]],["^15",[1000,"^Q","",536913977]],["^15",[1000,"^O","^16",536913977]],["^15",[1000,"^@",false,536913977]],["^15",[1000,"^F",999,536913977]],["^15",[1000,"^X",999,536913977]],["^15",[1000,"^V",999,536913977]],["^15",[1000,"^U",999,536913978]],["^15",[1000,"^?",["^ "],536913977]],["^15",[1000,"^17",true,536913977]],["^15",[1000,"^;","~u64bd48f9-da16-4baa-ae89-567bf18d4b32",536913977]],["^15",[1002,"^K",1690126938629,536914184]],["^15",[1002,"^[",1004,536914193]],["^15",[1002,"^O","^16",536914188]],["^15",[1002,"^@",false,536914184]],["^15",[1002,"^Y","arc<t>",536914184]],["^15",[1002,"^11","Arc<T>",536914184]],["^15",[1002,"^B",1690127682207,536914528]],["^15",[1002,"^;","~u64c20233-cb49-4467-a09e-afadf8c4c452",536916340]],["^15",[1003,"^Q","Just like [[Rc<T>]] but can be shared across [[Thread]]s safely as it implements the ``Send`` [[Trait]] and ``Sync`` trait, and uses [[Atomic]]s to handle its internal reference counters.",536914528]],["^15",[1003,"^O","^16",536914189]],["^15",[1003,"^@",false,536914189]],["^15",[1003,"^F",1002,536914189]],["^15",[1003,"^X",1002,536914189]],["^15",[1003,"^V",1002,536914189]],["^15",[1003,"^U",414,536914221]],["^15",[1003,"^U",822,536914221]],["^15",[1003,"^U",906,536914221]],["^15",[1003,"^U",1002,536914221]],["^15",[1003,"^U",1005,536914221]],["^15",[1003,"^?",["^ "],536914528]],["^15",[1003,"^H",414,536914528]],["^15",[1003,"^H",822,536914528]],["^15",[1003,"^H",906,536914528]],["^15",[1003,"^H",1005,536914528]],["^15",[1003,"^17",true,536914189]],["^15",[1003,"^;","~u64bd4a5c-e356-477e-8e7b-d9651a739e3e",536914189]],["^15",[1004,"^3","- Just like [[Rc<T>]] but can be shared across [[Thread]]s safely as it implements the ``Send`` [[Trait]] and ``Sync`` trait, and uses [[Atomic]]s to handle its internal reference counters.",536914530]],["^15",[1004,"^18","~m1690127682467",536914529]],["^15",[1004,"^Z","pages/Arc%3CT%3E.md",536914193]],["^15",[1005,"^K",1690126974762,536914220]],["^15",[1005,"^[",1007,536914248]],["^15",[1005,"^O","^16",536914242]],["^15",[1005,"^@",false,536914220]],["^15",[1005,"^Y","atomic",536914220]],["^15",[1005,"^11","Atomic",536914220]],["^15",[1005,"^B",1690127189420,536914376]],["^15",[1005,"^;","~u64bd4a7e-ded8-4db7-b9eb-abf5624ef30f",536914220]],["^15",[1006,"^Q","Atomic [[Data Type]]s are safe to be shared across [[Thread]]s and are meant to be handled by multiple threads at once in [[Concurrency or Parallelism]]. \nThey are defined in [``std::sync::atomic``](https://doc.rust-lang.org/std/sync/atomic/index.html).\nHowever, the cost is atomic types have a huge performance overhead with all the concurrency checks in place so they must only be used when they are required.",536914376]],["^15",[1006,"^O","^16",536914243]],["^15",[1006,"^@",false,536914243]],["^15",[1006,"^F",1005,536914243]],["^15",[1006,"^X",1005,536914243]],["^15",[1006,"^V",1005,536914243]],["^15",[1006,"^U",148,536914282]],["^15",[1006,"^U",822,536914282]],["^15",[1006,"^U",971,536914282]],["^15",[1006,"^U",1005,536914282]],["^15",[1006,"^?",["^ "],536914376]],["^15",[1006,"^H",148,536914376]],["^15",[1006,"^H",822,536914376]],["^15",[1006,"^H",971,536914376]],["^15",[1006,"^17",true,536914243]],["^15",[1006,"^;","~u64bd4a8e-6d1a-44d9-a5c7-bd361f345b14",536914243]],["^15",[1007,"^3","- Atomic [[Data Type]]s are safe to be shared across [[Thread]]s and are meant to be handled by multiple threads at once in [[Concurrency or Parallelism]]. \n  They are defined in [``std::sync::atomic``](https://doc.rust-lang.org/std/sync/atomic/index.html).\n  However, the cost is atomic types have a huge performance overhead with all the concurrency checks in place so they must only be used when they are required.",536914380]],["^15",[1007,"^18","~m1690127190404",536914379]],["^15",[1007,"^Z","pages/Atomic.md",536914248]],["^15",[1008,"^K",1690127107963,536914315]],["^15",[1008,"^O","^16",536914315]],["^15",[1008,"^N",20230723,536914315]],["^15",[1008,"^@",true,536914315]],["^15",[1008,"^Y","jul 23rd, 2023",536914315]],["^15",[1008,"^11","Jul 23rd, 2023",536914315]],["^15",[1008,"^B",1690127107963,536914315]],["^15",[1008,"^;","~u64bd4b03-8db3-4d20-9add-6d473640ba51",536914315]],["^15",[1009,"^Q","",536914316]],["^15",[1009,"^O","^16",536914316]],["^15",[1009,"^N",20230723,536914316]],["^15",[1009,"^@",true,536914316]],["^15",[1009,"^F",1008,536914316]],["^15",[1009,"^X",1008,536914316]],["^15",[1009,"^V",1008,536914316]],["^15",[1009,"^U",1008,536914317]],["^15",[1009,"^?",["^ "],536914316]],["^15",[1009,"^17",true,536914316]],["^15",[1009,"^;","~u64bd4b03-6f30-4664-b60e-46bde3d14960",536914316]],["^15",[1010,"^Q","",536914427]],["^15",[1010,"^O","^16",536914427]],["^15",[1010,"^@",false,536914427]],["^15",[1010,"^F",998,536914427]],["^15",[1010,"^X",995,536914427]],["^15",[1010,"^V",995,536914427]],["^15",[1010,"^U",995,536914428]],["^15",[1010,"^?",["^ "],536914427]],["^15",[1010,"^17",true,536914427]],["^15",[1010,"^;","~u64bd4bbf-733a-4519-a82c-5175d47e8426",536914427]],["^15",[1011,"^K",1690127559186,536914461]],["^15",[1011,"^[",1013,536914496]],["^15",[1011,"^O","^16",536914468]],["^15",[1011,"^@",false,536914461]],["^15",[1011,"^Y","interior mutability pattern",536914461]],["^15",[1011,"^11","Interior Mutability Pattern",536914461]],["^15",[1011,"^B",1690127589230,536914494]],["^15",[1011,"^;","~u64bd4cc7-53ee-42af-ad9d-81d1c7a35d82",536914461]],["^15",[1012,"^Q","Mutating immutably borrowed values is disallowed by Rust due to the Borrow Checker Rules. However, it is possible to bypass them in [[unsafe]] Rust.\nMany of Rust's concepts already use this pattern, such as ``for`` [[Loop]]s.",536914494]],["^15",[1012,"^O","^16",536914469]],["^15",[1012,"^@",false,536914469]],["^15",[1012,"^F",1011,536914469]],["^15",[1012,"^X",1011,536914469]],["^15",[1012,"^V",1011,536914469]],["^15",[1012,"^U",259,536914495]],["^15",[1012,"^U",953,536914495]],["^15",[1012,"^U",1011,536914495]],["^15",[1012,"^?",["^ "],536914494]],["^15",[1012,"^H",259,536914494]],["^15",[1012,"^H",953,536914494]],["^15",[1012,"^17",true,536914469]],["^15",[1012,"^;","~u64bd4ccb-8b45-4879-bf0d-11a9587180cc",536914469]],["^15",[1013,"^3","- Mutating immutably borrowed values is disallowed by Rust due to the Borrow Checker Rules. However, it is possible to bypass them in [[unsafe]] Rust.\n  Many of Rust's concepts already use this pattern, such as ``for`` [[Loop]]s.",536914498]],["^15",[1013,"^18","~m1690127590077",536914497]],["^15",[1013,"^Z","pages/Interior Mutability Pattern.md",536914496]],["^15",[1014,"^12",2,536914797]],["^15",[1015,"^Q","*Object Oriented Programming*\nRust isn't strictly OOP in the sense languages like *C++* are. Instead, it focuses on bringing all important aspects from OOP languages. By definition, OOP languages should provide *objects* that are packages of data and methods, and the methods operate on said data in their own packages. Rust does this using ``impl`` blocks and [[Struct]]/ [[Enum]]s. Encapsulation is handled through [[Access Modifier]]s.\nInheritance isn't wholly used, but it's most important aspects, abstract classes, which is done using [[Trait]]s and their implementers, and Polymorphism where an abstract type is used and at runtime replaced with a more concrete type, which is handled through [[Trait Object]]s, are covered.",536915032]],["^15",[1015,"^O","^16",536914799]],["^15",[1015,"^@",false,536914799]],["^15",[1015,"^F",869,536914799]],["^15",[1015,"^X",28,536914799]],["^15",[1015,"^V",28,536914799]],["^15",[1015,"^U",28,536915005]],["^15",[1015,"^U",242,536915005]],["^15",[1015,"^U",262,536915005]],["^15",[1015,"^U",414,536915005]],["^15",[1015,"^U",511,536915005]],["^15",[1015,"^U",583,536915005]],["^15",[1015,"^H",242,536916343]],["^15",[1015,"^H",262,536916343]],["^15",[1015,"^H",414,536916343]],["^15",[1015,"^H",511,536916343]],["^15",[1015,"^H",583,536916343]],["^15",[1015,"^17",true,536914799]],["^15",[1015,"^;","~u64bd6f35-fceb-4b0e-80e4-9930a19bd0ac",536914799]],["^15",[1016,"^3","- Trait Objects are much like [[Generic Type]]s where we define a [[Trait]] and instead of providing a concrete type at compile-time we provide it at runtime. So rust knows at compile-time only 2 things, that it should wait for the types till runtime and at compile time just ensure that any provided types do implement the given trait. \n  However, as we know, Rust requires a fixed size at compile time for every definition, this is why we have to make use of [[Pointer]]s. And the pointers theirselves need to know the size of the type, they can use ``dyn`` keyword which allows [[Dynamically Sized Type]]s. \n  Finally we get a [[Data Type]] definition that looks like ``Box<dyn someTrait>``.\n  \n  For ex.:\n  ```rust\n  fn main() {\n   /*\n  let bag = Bag {\n          stuff: vec![Box::new(1i32), Box::new(2u32)], \n      }; // //would be an error, because Box<T> for Bag resolves to i32, but we provide a u32 for the next element. \n  */\n      let bigger_bag = BigBag {\n          stuff: vec![Box::new(1i32), Box::new(2u32)],\n      }; //works\n  }\n   \n  struct Bag<T: Tiffin> {\n      stuff: Vec<Box<T>>,\n  }\n   \n  struct BigBag {\n      stuff: Vec<Box<dyn Tiffin>>,\n  }\n   \n  trait Tiffin {}\n   \n  impl Tiffin for i32 {}\n  impl Tiffin for u32 {}\n  \n  ```\n- With Trait Objects, Rust must use [[Dynamic Dispatch]].\n  This is in contrast to [[Static Dispatch]], where the compiler knows at compile-time all the methods and addresses to call. Here, it doesn't and instead internal pointers are used to denote where the actual method is at runtime. This prevents some optimizations, and also incurs a small lookup cost at runtime. \n  This is why Trait Objects must be used sparingly.",536915488]],["^15",[1016,"^18","~m1690137599272",536915487]],["^15",[1016,"^Z","pages/Trait Object.md",536915037]],["^15",[1017,"^K",1690137003953,536915144]],["^15",[1017,"^O","^16",536915144]],["^15",[1017,"^N",20230724,536915144]],["^15",[1017,"^@",true,536915144]],["^15",[1017,"^Y","jul 24th, 2023",536915144]],["^15",[1017,"^11","Jul 24th, 2023",536915144]],["^15",[1017,"^B",1690137003953,536915144]],["^15",[1017,"^;","~u64bd71ab-fe42-4f8e-a934-833b068c5209",536915144]],["^15",[1018,"^Q","",536915145]],["^15",[1018,"^O","^16",536915145]],["^15",[1018,"^N",20230724,536915145]],["^15",[1018,"^@",true,536915145]],["^15",[1018,"^F",1017,536915145]],["^15",[1018,"^X",1017,536915145]],["^15",[1018,"^V",1017,536915145]],["^15",[1018,"^U",1017,536915146]],["^15",[1018,"^?",["^ "],536915145]],["^15",[1018,"^17",true,536915145]],["^15",[1018,"^;","~u64bd71ab-f4b1-4ae6-9254-65f24e3deada",536915145]],["^15",[1019,"^Q","With Trait Objects, Rust must use [[Dynamic Dispatch]].\nThis is in contrast to [[Static Dispatch]], where the compiler knows at compile-time all the methods and addresses to call. Here, it doesn't and instead internal pointers are used to denote where the actual method is at runtime. This prevents some optimizations, and also incurs a small lookup cost at runtime. \nThis is why Trait Objects must be used sparingly.",536915486]],["^15",[1019,"^O","^16",536915417]],["^15",[1019,"^@",false,536915417]],["^15",[1019,"^F",500,536915417]],["^15",[1019,"^X",262,536915417]],["^15",[1019,"^V",262,536915417]],["^15",[1019,"^U",262,536915432]],["^15",[1019,"^U",744,536915432]],["^15",[1019,"^U",1020,536915432]],["^15",[1019,"^?",["^ "],536915486]],["^15",[1019,"^H",744,536915486]],["^15",[1019,"^H",1020,536915486]],["^15",[1019,"^17",true,536915417]],["^15",[1019,"^;","~u64bd7373-c3b2-4527-903c-8fc35256ae5a",536915417]],["^15",[1020,"^K",1690137483860,536915424]],["^15",[1020,"^@",false,536915424]],["^15",[1020,"^Y","dynamic dispatch",536915424]],["^15",[1020,"^11","Dynamic Dispatch",536915424]],["^15",[1020,"^B",1690137483860,536915424]],["^15",[1020,"^;","~u64bd738b-395b-4982-ba02-6ab6159aa0c4",536915424]],["^15",[1021,"^Q","Patterns are everywhere in Rust. Even a simple [[Variable]] assignment is a pattern.\nAs we know from ``while let`` [[Loop]] and ``if-let`` [[Conditional]], ``let`` denotes a pattern and expression assignment.\nThe simple ``let <varname>= <some value>`` is actually ``let <Pattern> = <Expression>``, which is why [[Tuple]] [[Destructuring]] also works.",536915606]],["^15",[1021,"^O","^16",536915497]],["^15",[1021,"^@",false,536915497]],["^15",[1021,"^F",537,536915497]],["^15",[1021,"^X",202,536915497]],["^15",[1021,"^V",202,536915497]],["^15",[1021,"^U",99,536915607]],["^15",[1021,"^U",194,536915607]],["^15",[1021,"^U",202,536915607]],["^15",[1021,"^U",204,536915607]],["^15",[1021,"^U",259,536915607]],["^15",[1021,"^U",316,536915607]],["^15",[1021,"^H",99,536916337]],["^15",[1021,"^H",194,536916337]],["^15",[1021,"^H",204,536916337]],["^15",[1021,"^H",259,536916337]],["^15",[1021,"^H",316,536916337]],["^15",[1021,"^17",true,536915497]],["^15",[1021,"^;","~u64bd7481-159d-48ab-b861-67722413c530",536915497]],["^15",[1023,"^Q","Pattern Types\n\nThere are 2\n\n* *Refutable Pattern*: Patterns that can fail to match an expression.\nFor ex.:\n```rust\nfn main() {\n let x: Option<i32> = None;\n if let Some(value) = x { //will fail to match\n  } \n}\n```\n* *Irrefutable Pattern*: Patterns that will match any value passed to the expression. Such as [[Variable]] assignment ``let <some var>=<some value>``.",536915810]],["^15",[1023,"^O","^16",536915610]],["^15",[1023,"^@",false,536915610]],["^15",[1023,"^F",1021,536915610]],["^15",[1023,"^X",202,536915610]],["^15",[1023,"^V",202,536915610]],["^15",[1023,"^U",99,536915675]],["^15",[1023,"^U",202,536915675]],["^15",[1023,"^H",99,536916337]],["^15",[1023,"^17",true,536915610]],["^15",[1023,"^;","~u64bd7573-4cf9-4ab2-95ef-d1ea212da77d",536915610]],["^15",[1024,"^Q","",536916184]],["^15",[1024,"^O","^16",536916184]],["^15",[1024,"^@",false,536916184]],["^15",[1024,"^F",547,536916184]],["^15",[1024,"^X",202,536916184]],["^15",[1024,"^V",202,536916184]],["^15",[1024,"^U",202,536916185]],["^15",[1024,"^17",true,536916184]],["^15",[1024,"^;","~u64bd790d-22be-4806-9ae5-d69a02fb964b",536916184]],["^15",[1025,"^12",2,536916319]],["^15",[1026,"^K",1690436146364,536916320]],["^15",[1026,"^O","^16",536916320]],["^15",[1026,"^N",20230727,536916320]],["^15",[1026,"^@",true,536916320]],["^15",[1026,"^Y","jul 27th, 2023",536916320]],["^15",[1026,"^11","Jul 27th, 2023",536916320]],["^15",[1026,"^B",1690436146364,536916320]],["^15",[1026,"^;","~u64c20232-e3d2-4ff8-b25a-5a593bcda834",536916320]],["^15",[1027,"^Q","",536916321]],["^15",[1027,"^O","^16",536916321]],["^15",[1027,"^N",20230727,536916321]],["^15",[1027,"^@",true,536916321]],["^15",[1027,"^F",1026,536916321]],["^15",[1027,"^X",1026,536916321]],["^15",[1027,"^V",1026,536916321]],["^15",[1027,"^U",1026,536916322]],["^15",[1027,"^?",["^ "],536916321]],["^15",[1027,"^17",true,536916321]],["^15",[1027,"^;","~u64c20232-afaa-4bad-93f9-e7411de7aab8",536916321]],["^15",[1028,"^3","- The names should follow snake_case and not camelCase or PascalCase. This is applied to all names, folder names, file names, variables, functions etc. However, it is not applied to things like type names where we need to follow CamelCase.",536916324]],["^15",[1028,"^1=",1690436146610,536916324]],["^15",[1028,"^18","~m1690335016762",536916325]],["^15",[1028,"^Z","pages/Default Linter Rule.md",536916324]],["^15",[1029,"^K",1690436146609,536916324]],["^15",[1029,"^[",1028,536916324]],["^15",[1029,"^@",false,536916324]],["^15",[1029,"^Y","default linter rule",536916324]],["^15",[1029,"^11","Default Linter Rule",536916324]],["^15",[1029,"^B",1690436146609,536916324]],["^15",[1029,"^;","~u64c20233-2111-4669-9468-32e65e53cabb",536916352]],["^15",[1030,"^Q","The names should follow snake_case and not camelCase or PascalCase. This is applied to all names, folder names, file names, variables, functions etc. However, it is not applied to things like type names where we need to follow CamelCase.",536916324]],["^15",[1030,"^O","^16",536916324]],["^15",[1030,"^F",1029,536916324]],["^15",[1030,"^X",1029,536916324]],["^15",[1030,"^V",1029,536916324]],["^15",[1030,"^U",1029,536916324]],["^15",[1030,"^17",true,536916324]],["^15",[1030,"^;","~u64c20232-e00a-4201-a104-094a1bdfd350",536916324]],["^15",[1031,"^3","- ``extern``\n  Rust also supports *FFI* (Foreign Function Interface) where Rust code can call a function written in another language, and other languages can call Rust code as well. We declare these external functions inside Rust within extern blocks and then call the functions using [[unsafe]] blocks. They are marked unsafe because other languages don’t employ Rust’s Safety system and hence they are always unsafe in Rust’s eyes.\n  We do so with the ``extern \"<ABI name>\" { <function declarations> }``.\n  \n  For ex.:\n  ```rust\n  extern \"C\" {\n      fn abs(input: i32) -> i32;\n  }\n  \n  fn main() {\n      unsafe {\n          println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n      }\n  }\n  ``` \n  Here ``extern \"C\"`` defines the external [[ABI]] (Application Binary Interface) rust uses to locate the provided [[Function]]s in. ``abs()`` is part of *C*'s Standard Library so it will find it directly. \n  \n  Similarly, rust can allow other languages to pick up its [[Function]]s. We do so using almost the same syntax.\n  \n  For ex.:\n  ```rust\n  #[no_mangle]\n  pub extern \"C\" fn call_from_c() {\n      println!(\"Just called a Rust function from C!\");\n  }\n  ```\n  ``#[no_mangle]`` is a [[Macro]] which disables name mangling for the given [[Function]]/ [[Method]], ignoring the optimization to reduce the binary size by a bit but allowing the name to remain the same and hence be picked up by external linkers easily. This isn't [[unsafe]]. \n  Compiling this generates a ``.pdb`` file in the ``target/`` directory which can be linked with a *C* program and hence be picked up there.",536916326]],["^15",[1031,"^1=",1690436146644,536916326]],["^15",[1031,"^18","~m1690336005745",536916327]],["^15",[1031,"^Z","pages/extern.md",536916326]],["^15",[1032,"^K",1690436146643,536916326]],["^15",[1032,"^[",1031,536916326]],["^15",[1032,"^@",false,536916326]],["^15",[1032,"^Y","extern",536916326]],["^15",[1032,"^11","extern",536916326]],["^15",[1032,"^B",1690436146643,536916326]],["^15",[1032,"^;","~u64c20233-2f5c-4358-a961-52e79cbacdae",536916349]],["^15",[1033,"^K",1690436146640,536916326]],["^15",[1033,"^@",false,536916326]],["^15",[1033,"^Y","abi",536916326]],["^15",[1033,"^11","ABI",536916326]],["^15",[1033,"^B",1690436146640,536916326]],["^15",[1033,"^;","~u64c20232-76ee-4002-bce2-f61e9fe0cc34",536916328]],["^15",[1034,"^Q","~``extern``\nRust also supports *FFI* (Foreign Function Interface) where Rust code can call a function written in another language, and other languages can call Rust code as well. We declare these external functions inside Rust within extern blocks and then call the functions using [[unsafe]] blocks. They are marked unsafe because other languages don’t employ Rust’s Safety system and hence they are always unsafe in Rust’s eyes.\nWe do so with the ``extern \"<ABI name>\" { <function declarations> }``.\n\nFor ex.:\n```rust\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n``` \nHere ``extern \"C\"`` defines the external [[ABI]] (Application Binary Interface) rust uses to locate the provided [[Function]]s in. ``abs()`` is part of *C*'s Standard Library so it will find it directly. \n\nSimilarly, rust can allow other languages to pick up its [[Function]]s. We do so using almost the same syntax.\n\nFor ex.:\n```rust\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n```\n``#[no_mangle]`` is a [[Macro]] which disables name mangling for the given [[Function]]/ [[Method]], ignoring the optimization to reduce the binary size by a bit but allowing the name to remain the same and hence be picked up by external linkers easily. This isn't [[unsafe]]. \nCompiling this generates a ``.pdb`` file in the ``target/`` directory which can be linked with a *C* program and hence be picked up there.",536916326]],["^15",[1034,"^O","^16",536916326]],["^15",[1034,"^F",1032,536916326]],["^15",[1034,"^X",1032,536916326]],["^15",[1034,"^V",1032,536916326]],["^15",[1034,"^U",130,536916326]],["^15",[1034,"^U",246,536916326]],["^15",[1034,"^U",497,536916326]],["^15",[1034,"^U",953,536916326]],["^15",[1034,"^U",1032,536916326]],["^15",[1034,"^U",1033,536916326]],["^15",[1034,"^H",130,536916326]],["^15",[1034,"^H",246,536916326]],["^15",[1034,"^H",497,536916326]],["^15",[1034,"^H",953,536916326]],["^15",[1034,"^H",1033,536916326]],["^15",[1034,"^17",true,536916326]],["^15",[1034,"^;","~u64c20232-3623-436d-b782-ac3fb509000c",536916326]],["^15",[1035,"^3","- ``union``\n  The same from the *C* or *C++* world. \n  That is, they are like [[Struct]]s but they can only have 1 field active at any time.\n  \n  For ex.:\n  ```rust\n  #[repr(C)]\n  union MyUnion {\n      f1: u32,\n      f2: f32,\n  }\n  \n  fn main() {\n  let u = MyUnion { f1: 1 };\n  let f = unsafe { u.f1 };\n  }\n  ```\n  It is [[unsafe]] to access a union as Rust can't ensure which field is active at compile-time and accessing an inactive field is an error.\n  \n  ``#[repr(C)]`` [[Macro]] says ``Do what this language does`` with data layout and everything about the structure. By using ``C`` as a value to it, we ensure the data layout used in ``C`` [[ABI]] is used here. Data layout refers to how data is structured in the memory.",536916328]],["^15",[1035,"^1=",1690436146741,536916328]],["^15",[1035,"^18","~m1690336048454",536916329]],["^15",[1035,"^Z","pages/union.md",536916328]],["^15",[1036,"^K",1690436146740,536916328]],["^15",[1036,"^[",1035,536916328]],["^15",[1036,"^@",false,536916328]],["^15",[1036,"^Y","union",536916328]],["^15",[1036,"^11","union",536916328]],["^15",[1036,"^B",1690436146740,536916328]],["^15",[1036,"^;","~u64c20233-d013-474e-afc6-a8ee82b3625d",536916349]],["^15",[1037,"^Q","~``union``\nThe same from the *C* or *C++* world. \nThat is, they are like [[Struct]]s but they can only have 1 field active at any time.\n\nFor ex.:\n```rust\n#[repr(C)]\nunion MyUnion {\n    f1: u32,\n    f2: f32,\n}\n\nfn main() {\nlet u = MyUnion { f1: 1 };\nlet f = unsafe { u.f1 };\n}\n```\nIt is [[unsafe]] to access a union as Rust can't ensure which field is active at compile-time and accessing an inactive field is an error.\n\n``#[repr(C)]`` [[Macro]] says ``Do what this language does`` with data layout and everything about the structure. By using ``C`` as a value to it, we ensure the data layout used in ``C`` [[ABI]] is used here. Data layout refers to how data is structured in the memory.",536916328]],["^15",[1037,"^O","^16",536916328]],["^15",[1037,"^F",1036,536916328]],["^15",[1037,"^X",1036,536916328]],["^15",[1037,"^V",1036,536916328]],["^15",[1037,"^U",242,536916328]],["^15",[1037,"^U",246,536916328]],["^15",[1037,"^U",953,536916328]],["^15",[1037,"^U",1033,536916328]],["^15",[1037,"^U",1036,536916328]],["^15",[1037,"^H",242,536916328]],["^15",[1037,"^H",246,536916328]],["^15",[1037,"^H",953,536916328]],["^15",[1037,"^H",1033,536916328]],["^15",[1037,"^17",true,536916328]],["^15",[1037,"^;","~u64c20232-879a-4c60-a4ce-e47117421ab0",536916328]],["^15",[1038,"^Q","General Generic Syntax\nFor [[Function]]s / [[Method]]s \n``\nfn <fn name><<lifetime><generic name 1>: Trait 1 + Trait 2 +,...,+ Trait n = <Optional Type>, <lifetime><generic name 2>: Trait 1 + Trait 2 +,...,+ Trait n = <Optional Type>,....,<lifetime><generic name k>: Trait 1 + Trait 2 +,...,+ Trait n = <Optional Type>>(<params>) -> <Return Type, default is Unit Type> { \n...\n}\n``\nAnd the other definitions are kind of the same. \nHere [[Lifetime]]s and [[Trait]]s are optional but restrict usage of the function with only types that satisfy the requirements.\nMultiple ``trait``s are defined with the ``+`` [[Operator]]. \n\n* There's another syntax specific to [[Function]]s/ [[Method]]s to make this definition soup more readable. It uses the ``where`` keyword and is hence called the *Where Clause*.\n\nSyntax\n``\nfn <fn name><<generic name 1>, <generic name 2>...<<generic name n>>(<params>) -> <Return Type> where <generic name 1> : <traits>, <generic name 2>: <traits>, <generic name n>:<traits> { }\n``\n\n```rust\n//fn yo<T: X, R: X+Y>(…) -> String {…}\n//can be written as\n\nfn yo<T,R>(…)-> String \nwhere T: X,\n\tR: X+Y \n{ } \n```",536916331]],["^15",[1038,"^O","^16",536916331]],["^15",[1038,"^F",735,536916331]],["^15",[1038,"^X",131,536916331]],["^15",[1038,"^V",131,536916331]],["^15",[1038,"^U",130,536916331]],["^15",[1038,"^U",131,536916331]],["^15",[1038,"^U",206,536916331]],["^15",[1038,"^U",280,536916331]],["^15",[1038,"^U",414,536916331]],["^15",[1038,"^U",497,536916331]],["^15",[1038,"^H",130,536916331]],["^15",[1038,"^H",206,536916331]],["^15",[1038,"^H",280,536916331]],["^15",[1038,"^H",414,536916331]],["^15",[1038,"^H",497,536916331]],["^15",[1038,"^17",true,536916331]],["^15",[1038,"^;","~u64c20232-dad3-4624-91fd-fc91b5ec5a98",536916331]],["^15",[1039,"^Q","There's a difference between a generic name and generic type.\nFor ex.:\n```rust\nuse std::fmt::Display;\ntrait X<T>{\n    fn whoa(&self, x:T);\n}\n\nstruct A{}\n\nimpl<i32:Display> X<i32> for A {\n    fn whoa(&self, x: i32) {\n        println!(\"tf {}\", x);\n    }\n}\n\nfn main() {\n    let a= A{};\n    a.whoa(2); //as expected\n    a.whoa(\"hm\"); //is it weird ?\n} //works!\n```\nHere we may think ``i32`` is the [[Number]] ``i32`` but in-fact it is just a name for the generic type. The definition for conditionally implementing ``X<i32>`` for [[Trait]] ``A`` here is ``impl X<i32> for A{...}``.",536916331]],["^15",[1039,"^O","^16",536916331]],["^15",[1039,"^F",746,536916331]],["^15",[1039,"^X",131,536916331]],["^15",[1039,"^V",131,536916331]],["^15",[1039,"^U",119,536916331]],["^15",[1039,"^U",131,536916331]],["^15",[1039,"^U",414,536916331]],["^15",[1039,"^H",119,536916331]],["^15",[1039,"^H",414,536916331]],["^15",[1039,"^17",true,536916331]],["^15",[1039,"^;","~u64c20232-7cef-4e5d-8815-3a2fbc7237c5",536916331]],["^15",[1040,"^Q","",536916337]],["^15",[1040,"^O","^16",536916337]],["^15",[1040,"^F",1041,536916337]],["^15",[1040,"^X",202,536916337]],["^15",[1040,"^V",202,536916337]],["^15",[1040,"^U",202,536916337]],["^15",[1040,"^17",true,536916337]],["^15",[1040,"^;","~u64c20232-cb09-4b9a-ad25-3f3de674b8ff",536916337]],["^15",[1041,"^Q","",536916337]],["^15",[1041,"^O","^16",536916337]],["^15",[1041,"^F",548,536916337]],["^15",[1041,"^X",202,536916337]],["^15",[1041,"^V",202,536916337]],["^15",[1041,"^U",202,536916337]],["^15",[1041,"^17",true,536916337]],["^15",[1041,"^;","~u64c20232-7295-47d4-a12b-1decb05544d2",536916337]],["^15",[1042,"^Q","*Raw Pointer*s\nRust allows raw pointers. They're allowed to ignore [[Borrow]]ing rules and have multiple pointers (immutable + mutable) to the same  value, aren't required to point to valid memory, can be null, and don't implement any automatic cleanup.\nCreating raw pointers and pointing them to any value is allowed in normal rust. However, dereferencing a raw pointer is [[unsafe]]. \n\nThere's 2 of these\n* immutable Raw Pointer: ``*const T`` where ``*`` is in the type name and not the deref [[Operator]]. These pointers can't be reassigned. \n\n* mutable Raw Pointer: ``*mut T``. Can be reassigned to point to a different value.\n\nFor ex.:\n```rust\nfn main() {\n    let mut num = 5;\n\n    let r1 = &num as *const i32;\n    let r2 = &mut num as *mut i32;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n \n} //works\n```\nWe use [[as]] to [[Cast]] a [[Reference Type]] to a Raw Pointer.",536916340]],["^15",[1042,"^O","^16",536916340]],["^15",[1042,"^F",908,536916340]],["^15",[1042,"^X",878,536916340]],["^15",[1042,"^V",878,536916340]],["^15",[1042,"^U",206,536916340]],["^15",[1042,"^U",253,536916340]],["^15",[1042,"^U",254,536916340]],["^15",[1042,"^U",878,536916340]],["^15",[1042,"^U",922,536916340]],["^15",[1042,"^U",923,536916340]],["^15",[1042,"^U",953,536916340]],["^15",[1042,"^H",206,536916340]],["^15",[1042,"^H",253,536916340]],["^15",[1042,"^H",254,536916340]],["^15",[1042,"^H",922,536916340]],["^15",[1042,"^H",923,536916340]],["^15",[1042,"^H",953,536916340]],["^15",[1042,"^17",true,536916340]],["^15",[1042,"^;","~u64c20233-bd95-4ec6-b905-581852151156",536916340]],["^15",[1043,"^Q","[[Supertrait]]",536916907]],["^15",[1043,"^O","^16",536916346]],["^15",[1043,"^F",1044,536916346]],["^15",[1043,"^X",414,536916346]],["^15",[1043,"^V",414,536916346]],["^15",[1043,"^U",414,536916908]],["^15",[1043,"^U",1052,536916908]],["^15",[1043,"^?",["^ "],536916907]],["^15",[1043,"^H",1052,536916907]],["^15",[1043,"^17",true,536916346]],["^15",[1043,"^;","~u64c20233-855e-4ea3-aba8-793d25e54b03",536916346]],["^15",[1044,"^Q","[[unsafe]] Traits\nTraits which have some [[unsafe]] [[Method]]s. \nWe declare these traits with ``unsafe`` and same for their ``impl`` blocks .\n\nFor ex.:\n```rust\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}\n```",536916346]],["^15",[1044,"^O","^16",536916346]],["^15",[1044,"^F",944,536916346]],["^15",[1044,"^X",414,536916346]],["^15",[1044,"^V",414,536916346]],["^15",[1044,"^U",414,536916346]],["^15",[1044,"^U",497,536916346]],["^15",[1044,"^U",953,536916346]],["^15",[1044,"^H",497,536916346]],["^15",[1044,"^H",953,536916346]],["^15",[1044,"^17",true,536916346]],["^15",[1044,"^;","~u64c20233-ad46-434d-8861-0368d4966391",536916346]],["^15",[1045,"^Q","[[Generic Type]]s can use traits, and traits can use generics too.\nFor ex.:\n```rust\npub trait X<T> {\n    fn yo(x: T);\n    fn no(&self, x: T);\n    fn ok() -> Option<T>;\n    fn lol(&self) -> Option<T>;\n}\n\nstruct A {}\n\nimpl<T> X<T> for A {\n    fn yo(x: T) {}\n    fn no(&self, x: T) {}\n    fn ok() -> Option<T> {\n        None\n    }\n    fn lol(&self) -> Option<T> {\n        None\n    }\n}\n\nstruct B {}\n\nimpl X<i32> for B {\n    fn yo(x: i32) {}\n    fn no(&self, x: i32) {\n        println!(\"yo no\");\n    }\n    fn ok() -> Option<i32> {\n        println!(\"ok\");\n        None\n    }\n    fn lol(&self) -> Option<i32> {\n        None\n    }\n}\n\nfn main() {\n    let a = A {};\n    a.no(2);\n    A::yo(4);\n    A::ok() as Option<i32>;\n    a.lol() as Option<i32>;\n\n    let b = B {};\n    b.no(2);\n    //b.no(\"ab\"); //error\n    //B::ok() as Option<f64>; //error\n} // works\n\n```\nJust like [[Method]] ``impl`` blocks we can conditionally define traits for [[Data Type]]s too. \nHowever, generics or not, a trait can only be implemented once for any [[Data Type]]. So if we conditionally define a trait for a type, then it's methods are only available for that type.\n\n* [[Associated Type]]s provide an alternative to using traits with generics. The benefit of using associated types is that the caller code has no need of knowing the type or defining it, it is all handled by the type implementing the trait itself.",536916901]],["^15",[1045,"^O","^16",536916346]],["^15",[1045,"^F",776,536916346]],["^15",[1045,"^X",414,536916346]],["^15",[1045,"^V",414,536916346]],["^15",[1045,"^U",131,536916356]],["^15",[1045,"^U",148,536916356]],["^15",[1045,"^U",414,536916356]],["^15",[1045,"^U",497,536916356]],["^15",[1045,"^U",894,536916356]],["^15",[1045,"^?",["^ "],536916901]],["^15",[1045,"^H",131,536916901]],["^15",[1045,"^H",148,536916901]],["^15",[1045,"^H",497,536916901]],["^15",[1045,"^H",894,536916901]],["^15",[1045,"^17",true,536916346]],["^15",[1045,"^;","~u64c20233-9997-4d30-84cf-dd020b1d6a84",536916346]],["^15",[1046,"^Q","unsafe superpowers\n5 actions can be done in unsafe rust (inside the unsafe block), they are\n* Dereferencing a Raw [[Pointer]] \n* Calling an unsafe [[Function]]/ [[Method]]: \nWe declare [[Function]]s/ [[Method]]s as ``unsafe``. Then the entire function body is unsafe. We can only call these functions from unsafe blocks.\n\nFor ex.:\n```rust\nunsafe fn foo() {}\nfn main() {\n    unsafe {\n        foo();\n    }\n}\n\n```\nIt is advisable to not mark functions as ``unsafe``, rather use unsafe blocks inside them. This way we create a safe abstraction over an unsafe code. \n\nThis is required with [[extern]] methods.\n* Access/Modify mutable static [[Variable]]s:\n* Implement an unsafe [[Trait]]\n* Access fields of [[union]]s",536916349]],["^15",[1046,"^O","^16",536916349]],["^15",[1046,"^F",954,536916349]],["^15",[1046,"^X",953,536916349]],["^15",[1046,"^V",953,536916349]],["^15",[1046,"^U",99,536916349]],["^15",[1046,"^U",130,536916349]],["^15",[1046,"^U",414,536916349]],["^15",[1046,"^U",497,536916349]],["^15",[1046,"^U",878,536916349]],["^15",[1046,"^U",953,536916349]],["^15",[1046,"^U",1032,536916349]],["^15",[1046,"^U",1036,536916349]],["^15",[1046,"^H",99,536916349]],["^15",[1046,"^H",130,536916349]],["^15",[1046,"^H",414,536916349]],["^15",[1046,"^H",497,536916349]],["^15",[1046,"^H",878,536916349]],["^15",[1046,"^H",1032,536916349]],["^15",[1046,"^H",1036,536916349]],["^15",[1046,"^17",true,536916349]],["^15",[1046,"^;","~u64c20233-3437-4cad-a696-5896a3cdc1e8",536916349]],["^15",[1047,"^Q","*Static Variable*s\nRust allows global variables, i.e., variables in the global [[Scope]]. They have be to declared with the ``static`` keyword. However, using them isn't a best practice as if we use them with [[Thread]]s, multiple threads accessing the same Global variables can cause *Data Race*.\nStatic variables can only have static [[Lifetime]]s and hence can only have values given at compile-time.\n\n\nSyntax:\n``\nstatic <optional mut> <varname>:<vartype>= <value>;\n``\nFor ex.\n```rust\nstatic HELLO_WORLD: &str = \"Hello, world!\";\nstatic mut YO: u32=0; \nfn main() {\n    println!(\"name is: {}\", HELLO_WORLD);\n    unsafe {\n    YO= 2;\n     println!(\"yo: {}\", YO);\n  }\n}\n```\nIt is in [[Default Linter Rule]]s to define static variables in *SCREAMING_SNAKE_CASE*.\nAccessing/Mutating static variables is [[unsafe]] as it could lead to *Data Race*.\n\n* ``static`` variables are different from ``const`` variables as they have a fixed address throughout the runtime, however const variables depend on their [[Scope]] and can have any address as they are initialized/destroyed each time the scope starts/ends.",536916352]],["^15",[1047,"^O","^16",536916352]],["^15",[1047,"^F",120,536916352]],["^15",[1047,"^X",99,536916352]],["^15",[1047,"^V",99,536916352]],["^15",[1047,"^U",89,536916352]],["^15",[1047,"^U",99,536916352]],["^15",[1047,"^U",280,536916352]],["^15",[1047,"^U",822,536916352]],["^15",[1047,"^U",953,536916352]],["^15",[1047,"^U",1029,536916352]],["^15",[1047,"^H",89,536916352]],["^15",[1047,"^H",280,536916352]],["^15",[1047,"^H",822,536916352]],["^15",[1047,"^H",953,536916352]],["^15",[1047,"^H",1029,536916352]],["^15",[1047,"^17",true,536916352]],["^15",[1047,"^;","~u64c20233-c09f-4a02-a538-fc857b1e04f0",536916352]],["^15",[1050,"^3","- Just like [[Generic Type]]s on [[Trait]]s, we can define types in trait definitions which the implementors would then define and hence we get something similar to a generic type but without using generics and a more concise trait definition.\n  \n  Syntax:\n  ``\n  trait <trait name> {\n   type <some type name 1>;\n   type <some type name 2>; \n    //and so on\n    //then use them as types in any following methods, as they are part of Self, we need to use Self::<some type name> \n  }\n  \n  impl <trait name> for <type name> {\n     type <some type name 1> = <some type>;\n     type <some type name 2> = <some type>;\n    //and define the methods with either <some type> or Self::<some type name> \n  }\n  ``\n  [[Method]] definitions can use ``Self::<type name>`` in trait definition.\n  \n  For ex.:\n  ```rust\n  trait X {\n      type A;\n      type B;\n      fn yo(a: Self::A, b: Self::B);\n      fn no(&self, a: Self::A, b: Self::B);\n  }\n  \n  struct M {}\n  \n  impl X for M {\n      type A = i32;\n      type B = f64;\n      fn yo(a: Self::A, b: f64) {}\n      fn no(&self, a: Self::A, b: Self::B) {}\n  }\n  \n  fn main() {\n      let m = M {};\n      M::yo(2, 4.0);\n      m.no(5, 6.0);\n  } \n  ```",536916870]],["^15",[1050,"^18","~m1690436921730",536916869]],["^15",[1050,"^Z","pages/Associated Type.md",536916389]],["^15",[1051,"^Q","Just like [[Generic Type]]s on [[Trait]]s, we can define types in trait definitions which the implementors would then define and hence we get something similar to a generic type but without using generics and a more concise trait definition.\n\nSyntax:\n``\ntrait <trait name> {\n type <some type name 1>;\n type <some type name 2>; \n  //and so on\n  //then use them as types in any following methods, as they are part of Self, we need to use Self::<some type name> \n}\n\nimpl <trait name> for <type name> {\n   type <some type name 1> = <some type>;\n   type <some type name 2> = <some type>;\n  //and define the methods with either <some type> or Self::<some type name> \n}\n``\n[[Method]] definitions can use ``Self::<type name>`` in trait definition.\n\nFor ex.:\n```rust\ntrait X {\n    type A;\n    type B;\n    fn yo(a: Self::A, b: Self::B);\n    fn no(&self, a: Self::A, b: Self::B);\n}\n\nstruct M {}\n\nimpl X for M {\n    type A = i32;\n    type B = f64;\n    fn yo(a: Self::A, b: f64) {}\n    fn no(&self, a: Self::A, b: Self::B) {}\n}\n\nfn main() {\n    let m = M {};\n    M::yo(2, 4.0);\n    m.no(5, 6.0);\n} \n```",536916868]],["^15",[1051,"^O","^16",536916404]],["^15",[1051,"^@",false,536916404]],["^15",[1051,"^F",894,536916408]],["^15",[1051,"^X",894,536916404]],["^15",[1051,"^V",894,536916404]],["^15",[1051,"^U",131,536916847]],["^15",[1051,"^U",414,536916847]],["^15",[1051,"^U",497,536916847]],["^15",[1051,"^U",894,536916847]],["^15",[1051,"^?",["^ "],536916868]],["^15",[1051,"^H",131,536916868]],["^15",[1051,"^H",414,536916868]],["^15",[1051,"^H",497,536916868]],["^15",[1051,"^17",true,536916404]],["^15",[1051,"^;","~u64c202d9-a3b8-46e0-a599-948fb3228ee2",536916404]],["^15",[1052,"^K",1690437236131,536916907]],["^15",[1052,"^[",1054,536916916]],["^15",[1052,"^O","^16",536916911]],["^15",[1052,"^@",false,536916907]],["^15",[1052,"^Y","supertrait",536916907]],["^15",[1052,"^11","Supertrait",536916907]],["^15",[1052,"^B",1690438048782,536917337]],["^15",[1052,"^;","~u64c20674-63e9-4d01-b6d0-054daa821a6f",536916907]],["^15",[1053,"^Q","[[Trait]]s can use other traits too.\nA [[Trait]] that gets implemented by another [[Trait]] is called a supertrait. And if we wish to implement this child trait, we are required to implement the supertrait itself as well. The benefit is that since this is a requirement, the child trait can use [[Method]]s of the supertrait and it is guaranteed they will be defined by the implementor [[Data Type]].\n\nSyntax:\n``\ntrait <some name> {\n //some methods\n}\n\ntrait <some other name>: <some name> {\n //some methods\n}\n\n//then implement both for a data type\n``\n\nFor ex.:\n```rust\ntrait X {\n    fn yo();\n    fn no(&self);\n}\n\ntrait Y: X {\n    fn hello() {\n        Self::yo();\n        //no(); error as no() is defined for the instance and we have no access to instance here\n    }\n\n    fn ho(&self) {\n        Self::yo();\n        self.no();\n    }\n}\n\nstruct A {}\n\nimpl X for A {\n    //required\n    fn yo() {}\n    fn no(&self) {}\n}\n\nimpl Y for A {}\n\nfn main() {\n    let a = A {};\n    A::hello(); //ok\n    a.ho(); //also ok\n}\n\n```",536917334]],["^15",[1053,"^O","^16",536916912]],["^15",[1053,"^@",false,536916912]],["^15",[1053,"^F",1052,536916912]],["^15",[1053,"^X",1052,536916912]],["^15",[1053,"^V",1052,536916912]],["^15",[1053,"^U",148,536917021]],["^15",[1053,"^U",414,536917021]],["^15",[1053,"^U",497,536917021]],["^15",[1053,"^U",1052,536917021]],["^15",[1053,"^?",["^ "],536917334]],["^15",[1053,"^H",148,536917334]],["^15",[1053,"^H",414,536917334]],["^15",[1053,"^H",497,536917334]],["^15",[1053,"^17",true,536916912]],["^15",[1053,"^;","~u64c20675-c556-4ec4-bbfe-80b2095654f5",536916912]],["^15",[1054,"^3","- [[Trait]]s can use other traits too.\n  A [[Trait]] that gets implemented by another [[Trait]] is called a supertrait. And if we wish to implement this child trait, we are required to implement the supertrait itself as well. The benefit is that since this is a requirement, the child trait can use [[Method]]s of the supertrait and it is guaranteed they will be defined by the implementor [[Data Type]].\n  \n  Syntax:\n  ``\n  trait <some name> {\n   //some methods\n  }\n  \n  trait <some other name>: <some name> {\n   //some methods\n  }\n  \n  //then implement both for a data type\n  ``\n  \n  For ex.:\n  ```rust\n  trait X {\n      fn yo();\n      fn no(&self);\n  }\n  \n  trait Y: X {\n      fn hello() {\n          Self::yo();\n          //no(); error as no() is defined for the instance and we have no access to instance here\n      }\n  \n      fn ho(&self) {\n          Self::yo();\n          self.no();\n      }\n  }\n  \n  struct A {}\n  \n  impl X for A {\n      //required\n      fn yo() {}\n      fn no(&self) {}\n  }\n  \n  impl Y for A {}\n  \n  fn main() {\n      let a = A {};\n      A::hello(); //ok\n      a.ho(); //also ok\n  }\n  \n  ```\n- If the child [[Trait]] implements [[Method]]s with the same name as the supertrait, they aren't defining implementation for the supertrait's method, rather they are shadowing them. \n  Then the child trait must use [[Fully Qualified Syntax For Disambiguation]] if its methods call this method.\n  \n  For ex.:\n  ```rust\n  trait X {\n      fn yo();\n  }\n  \n  trait Y: X {\n      fn ho() {\n          //Self::yo(); //error\n          <Self as X>::yo(); //ok\n      }\n      fn yo() {} //same name method\n  }\n  \n  struct A {}\n  \n  impl X for A {\n      fn yo() {}\n  }\n  \n  impl Y for A {}\n  \n  fn main() {\n      let a = A {};\n      A::ho();\n      //A::yo(); //error\n      <A as Y>::yo(); //ok\n  }\n  \n  ```",536917339]],["^15",[1054,"^18","~m1690438049365",536917338]],["^15",[1054,"^Z","pages/Supertrait.md",536916916]],["^15",[1055,"^Q","If the child [[Trait]] implements [[Method]]s with the same name as the supertrait, they aren't defining implementation for the supertrait's method, rather they are shadowing them. \nThen the child trait must use [[Fully Qualified Syntax For Disambiguation]] if its methods call this method.\n\nFor ex.:\n```rust\ntrait X {\n    fn yo();\n}\n\ntrait Y: X {\n    fn ho() {\n        //Self::yo(); //error\n        <Self as X>::yo(); //ok\n    }\n    fn yo() {} //same name method\n}\n\nstruct A {}\n\nimpl X for A {\n    fn yo() {}\n}\n\nimpl Y for A {}\n\nfn main() {\n    let a = A {};\n    A::ho();\n    //A::yo(); //error\n    <A as Y>::yo(); //ok\n}\n\n```",536917337]],["^15",[1055,"^O","^16",536917219]],["^15",[1055,"^@",false,536917219]],["^15",[1055,"^F",1053,536917219]],["^15",[1055,"^X",1052,536917219]],["^15",[1055,"^V",1052,536917219]],["^15",[1055,"^U",414,536917262]],["^15",[1055,"^U",497,536917262]],["^15",[1055,"^U",1052,536917262]],["^15",[1055,"^U",1056,536917262]],["^15",[1055,"^?",["^ "],536917337]],["^15",[1055,"^H",414,536917337]],["^15",[1055,"^H",497,536917337]],["^15",[1055,"^H",1056,536917337]],["^15",[1055,"^17",true,536917219]],["^15",[1055,"^;","~u64c20837-242d-44b6-a542-54e4ce2751b1",536917219]],["^15",[1056,"^K",1690437801809,536917261]],["^15",[1056,"^[",1060,536917352]],["^15",[1056,"^O","^16",536917346]],["^15",[1056,"^@",false,536917261]],["^15",[1056,"^Y","fully qualified syntax for disambiguation",536917261]],["^15",[1056,"^11","Fully Qualified Syntax For Disambiguation",536917261]],["^15",[1056,"^B",1690438119120,536917384]],["^15",[1056,"^;","~u64c208a9-19f8-48e0-bbea-1ddd58bccc36",536917261]],["^15",[1057,"^Q","We can define [[Method]]s and [[Trait]] methods with same names for a [[Data Type]] as long as they aren’t defined in same [[Scope]]. Then we call them with their full syntax. \n\nFor ex.:\n```rust\nstruct Human {}\n\ntrait Pilot {\n    fn fly();\n}\n \ntrait Wizard {\n    fn fly(&self);\n}\n  \nimpl Pilot for Human {\n    fn fly() {\n        println!(\"This is your captain speaking.\");\n    }\n}\n \nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n \nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n\nfn main() {\n let x= Human{};\n x.fly(); //prints waving arms furiously\n Wizard::fly(&x); //prints up\n <Human as Pilot>::fly(); //prints This is your captain speaking\n}\n```\nSince ``fly()`` is ambiguous, Rust defaults to calling the [[Method]] on the [[Data Type]] directly, if it is not available then that's an error. \nWe have to explicitly call the [[Method]] that we wish to invoke in ambiguities like these. \nMethods that take ``self`` as a parameter can be explicitly given an instance, given the [[Data Type]] of instance implements the type for which the method is called. \n\nIn case of [[Method]]s without ``self`` we would need to [[Cast]] the [[Data Type]] , we can do so using [[as]].",536917384]],["^15",[1057,"^O","^16",536917347]],["^15",[1057,"^@",false,536917347]],["^15",[1057,"^F",1056,536917347]],["^15",[1057,"^X",1056,536917347]],["^15",[1057,"^V",1056,536917347]],["^15",[1057,"^U",89,536917385]],["^15",[1057,"^U",148,536917385]],["^15",[1057,"^U",414,536917385]],["^15",[1057,"^U",497,536917385]],["^15",[1057,"^U",922,536917385]],["^15",[1057,"^U",923,536917385]],["^15",[1057,"^U",1056,536917385]],["^15",[1057,"^?",["^ "],536917384]],["^15",[1057,"^H",89,536917384]],["^15",[1057,"^H",148,536917384]],["^15",[1057,"^H",414,536917384]],["^15",[1057,"^H",497,536917384]],["^15",[1057,"^H",922,536917384]],["^15",[1057,"^H",923,536917384]],["^15",[1057,"^17",true,536917347]],["^15",[1057,"^;","~u64c209b9-1458-4830-878e-6a9241fd3936",536917350]],["^15",[1058,"^U",1056,536917351]],["^15",[1059,"^U",1056,536917351]],["^15",[1060,"^3","- We can define [[Method]]s and [[Trait]] methods with same names for a [[Data Type]] as long as they aren’t defined in same [[Scope]]. Then we call them with their full syntax. \n  \n  For ex.:\n  ```rust\n  struct Human {}\n  \n  trait Pilot {\n      fn fly();\n  }\n   \n  trait Wizard {\n      fn fly(&self);\n  }\n    \n  impl Pilot for Human {\n      fn fly() {\n          println!(\"This is your captain speaking.\");\n      }\n  }\n   \n  impl Wizard for Human {\n      fn fly(&self) {\n          println!(\"Up!\");\n      }\n  }\n   \n  impl Human {\n      fn fly(&self) {\n          println!(\"*waving arms furiously*\");\n      }\n  }\n  \n  fn main() {\n   let x= Human{};\n   x.fly(); //prints waving arms furiously\n   Wizard::fly(&x); //prints up\n   <Human as Pilot>::fly(); //prints This is your captain speaking\n  }\n  ```\n  Since ``fly()`` is ambiguous, Rust defaults to calling the [[Method]] on the [[Data Type]] directly, if it is not available then that's an error. \n  We have to explicitly call the [[Method]] that we wish to invoke in ambiguities like these. \n  Methods that take ``self`` as a parameter can be explicitly given an instance, given the [[Data Type]] of instance implements the type for which the method is called. \n  \n  In case of [[Method]]s without ``self`` we would need to [[Cast]] the [[Data Type]] , we can do so using [[as]].",536917387]],["^15",[1060,"^18","~m1690438119144",536917386]],["^15",[1060,"^Z","pages/Fully Qualified Syntax For Disambiguation.md",536917352]],["^15",[1061,"^Q","[[Type Alias]]",536917397]],["^15",[1061,"^O","^16",536917390]],["^15",[1061,"^@",false,536917390]],["^15",[1061,"^F",435,536917390]],["^15",[1061,"^X",148,536917390]],["^15",[1061,"^V",148,536917390]],["^15",[1061,"^U",148,536917398]],["^15",[1061,"^U",1062,536917398]],["^15",[1061,"^?",["^ "],536917397]],["^15",[1061,"^H",1062,536917397]],["^15",[1061,"^17",true,536917390]],["^15",[1061,"^;","~u64c20a4a-e5e5-4590-a298-ef80ff56d1af",536917390]],["^15",[1062,"^K",1690438228955,536917397]],["^15",[1062,"^[",1064,536917406]],["^15",[1062,"^O","^16",536917401]],["^15",[1062,"^@",false,536917397]],["^15",[1062,"^Y","type alias",536917397]],["^15",[1062,"^11","Type Alias",536917397]],["^15",[1062,"^B",1690438364736,536917518]],["^15",[1062,"^;","~u64c20a54-8f7f-42c0-b04a-d595231711ed",536917397]],["^15",[1063,"^Q","Just like *typedef* in *C++*, we can have aliases for [[Data Type]]s in Rust.\nThe syntax is much like [[Associated Type]]s.\n\nFor ex.:\n```rust\nfn main() {\n type yo= i32;\n let x: i32= 2;\n let y: yo = 4;\n println!(\"{}\",x+y ); \n} //works\n```",536917518]],["^15",[1063,"^O","^16",536917402]],["^15",[1063,"^@",false,536917402]],["^15",[1063,"^F",1062,536917402]],["^15",[1063,"^X",1062,536917402]],["^15",[1063,"^V",1062,536917402]],["^15",[1063,"^U",148,536917519]],["^15",[1063,"^U",894,536917519]],["^15",[1063,"^U",1062,536917519]],["^15",[1063,"^?",["^ "],536917518]],["^15",[1063,"^H",148,536917518]],["^15",[1063,"^H",894,536917518]],["^15",[1063,"^17",true,536917402]],["^15",[1063,"^;","~u64c20a55-0cc4-472a-9f87-733f1162f7fc",536917402]],["^15",[1064,"^3","- Just like *typedef* in *C++*, we can have aliases for [[Data Type]]s in Rust.\n  The syntax is much like [[Associated Type]]s.\n  \n  For ex.:\n  ```rust\n  fn main() {\n   type yo= i32;\n   let x: i32= 2;\n   let y: yo = 4;\n   println!(\"{}\",x+y ); \n  } //works\n  ```",536917521]],["^15",[1064,"^18","~m1690438365448",536917520]],["^15",[1064,"^Z","pages/Type Alias.md",536917406]],["^15",[1065,"^Q","[[Never Type]]",536917526]],["^15",[1065,"^O","^16",536917522]],["^15",[1065,"^@",false,536917522]],["^15",[1065,"^F",1076,536917559]],["^15",[1065,"^X",148,536917522]],["^15",[1065,"^V",148,536917522]],["^15",[1065,"^U",148,536917527]],["^15",[1065,"^U",1066,536917527]],["^15",[1065,"^?",["^ "],536917526]],["^15",[1065,"^H",1066,536917526]],["^15",[1065,"^17",true,536917522]],["^15",[1065,"^;","~u64c20adf-0caf-481e-bc1a-0f9550375c99",536917522]],["^15",[1066,"^5",1068,536917534]],["^15",[1066,"^K",1690438372438,536917526]],["^15",[1066,"^[",1069,536917536]],["^15",[1066,"^O","^16",536917530]],["^15",[1066,"^@",false,536917526]],["^15",[1066,"^Y","never type",536917526]],["^15",[1066,"^11","Never Type",536917526]],["^15",[1066,"^?",["^ ","^19",["^1:",["Empty Type"]]],536917534]],["^15",[1066,"^4",["^ ","^19","Empty Type"],536917534]],["^15",[1066,"^B",1690968895630,536926070]],["^15",[1066,"^;","~u64c20ae4-e85b-4aef-8a62-81de782ee54a",536917526]],["^15",[1067,"^Q","alias:: Empty Type",536917534]],["^15",[1067,"^O","^16",536917531]],["^15",[1067,"^1;",["^1:",[]],536917534]],["^15",[1067,"^@",false,536917531]],["^15",[1067,"^F",1066,536917531]],["^15",[1067,"^X",1066,536917531]],["^15",[1067,"^V",1066,536917531]],["^15",[1067,"^U",1066,536917535]],["^15",[1067,"^U",1068,536917535]],["^15",[1067,"^:",true,536917534]],["^15",[1067,"^?",["^ ","^19",["^1:",["Empty Type"]]],536917534]],["^15",[1067,"^J",["^14",["^19"]],536917534]],["^15",[1067,"^4",["^ ","^19","Empty Type"],536917534]],["^15",[1067,"^H",1068,536917534]],["^15",[1067,"^17",true,536917531]],["^15",[1067,"^;","~u64c20ae5-fa72-491d-8b2d-287d8bcaa8c6",536917531]],["^15",[1068,"^K",1690438378830,536917534]],["^15",[1068,"^@",false,536917534]],["^15",[1068,"^Y","empty type",536917534]],["^15",[1068,"^11","Empty Type",536917534]],["^15",[1068,"^B",1690438378830,536917534]],["^15",[1069,"^3","alias:: Empty Type\n\n- A [[Data Type]] represented with ``!`` and has no values. \n  So it is kind of like *void* in *C++*, but not exactly, as blocks that denote return type ``!`` never return, so the control flow never actually returns back to the caller.\n  ``fn yo() -> ! {…}``\n  Although a syntax error, it says [[Function]] ``yo`` returns never. This type of function is called a *Diverging* [[Function]] as control never returns from this function. [[Scope]] blocks always return something, or [[Unit Type]] if nothing explicitly.\n  \n  The never type has some uses, namely, it tells Rust that a given piece of code never returns hence the only possible return types are others. \n  \n  For ex.:\n  ```rust\n  fn main(){\n  let x= Some(2);\n  /*\n  let y= match x {\n  \tSome(_) => 2,\n  \tNone => “ye”\n  };\n  */\n  //is an error as match needs to return the same type for all arms, however,\n  let y= match x {\n  \tSome(_) => 2,\n  \tNone => panic!(…)\n   };\n  } // works!\n  ```\n  The never type can be coerced into any type.\n  \n  For ex.:\n  ```rust\n  let x: ! = panic!();\n  // Can be coerced into any type.\n  let y: u32 = x;\n  ```\n  \n  Rust knows if the never type is returned then the control flow has changed and hence it doesn’t need to worry about the arm’s type.\n  \n  * ``continue`` also returns a never type.\n-",536926076]],["^15",[1069,"^18","~m1690968899692",536926075]],["^15",[1069,"^Z","pages/Never Type.md",536917536]],["^15",[1070,"^Q","A [[Data Type]] represented with ``!`` and has no values. \nSo it is kind of like *void* in *C++*, but not exactly, as blocks that denote return type ``!`` never return, so the control flow never actually returns back to the caller.\n``fn yo() -> ! {…}``\nAlthough a syntax error, it says [[Function]] ``yo`` returns never. This type of function is called a *Diverging* [[Function]] as control never returns from this function. [[Scope]] blocks always return something, or [[Unit Type]] if nothing explicitly.\n\nThe never type has some uses, namely, it tells Rust that a given piece of code never returns hence the only possible return types are others. \n\nFor ex.:\n```rust\nfn main(){\nlet x= Some(2);\n/*\nlet y= match x {\n\tSome(_) => 2,\n\tNone => “ye”\n};\n*/\n//is an error as match needs to return the same type for all arms, however,\nlet y= match x {\n\tSome(_) => 2,\n\tNone => panic!(…)\n };\n} // works!\n```\nThe never type can be coerced into any type.\n\nFor ex.:\n```rust\nlet x: ! = panic!();\n// Can be coerced into any type.\nlet y: u32 = x;\n```\n\nRust knows if the never type is returned then the control flow has changed and hence it doesn’t need to worry about the arm’s type.\n\n* ``continue`` also returns a never type.",536926070]],["^15",[1070,"^O","^16",536917539]],["^15",[1070,"^@",false,536917539]],["^15",[1070,"^F",1067,536917539]],["^15",[1070,"^X",1066,536917539]],["^15",[1070,"^V",1066,536917539]],["^15",[1070,"^U",89,536925971]],["^15",[1070,"^U",130,536925971]],["^15",[1070,"^U",148,536925971]],["^15",[1070,"^U",211,536925971]],["^15",[1070,"^U",1066,536925971]],["^15",[1070,"^?",["^ "],536926070]],["^15",[1070,"^H",89,536926070]],["^15",[1070,"^H",130,536926070]],["^15",[1070,"^H",148,536926070]],["^15",[1070,"^H",211,536926070]],["^15",[1070,"^17",true,536917539]],["^15",[1070,"^;","~u64c20aee-8dff-4fd7-a26b-92d2c4172851",536917539]],["^15",[1071,"^12",2,536917544]],["^15",[1072,"^K",1690513919266,536917545]],["^15",[1072,"^O","^16",536917545]],["^15",[1072,"^N",20230728,536917545]],["^15",[1072,"^@",true,536917545]],["^15",[1072,"^Y","jul 28th, 2023",536917545]],["^15",[1072,"^11","Jul 28th, 2023",536917545]],["^15",[1072,"^B",1690513919266,536917545]],["^15",[1072,"^;","~u64c331ff-9863-4929-9093-015092447f6c",536917545]],["^15",[1073,"^Q","",536917546]],["^15",[1073,"^O","^16",536917546]],["^15",[1073,"^N",20230728,536917546]],["^15",[1073,"^@",true,536917546]],["^15",[1073,"^F",1072,536917546]],["^15",[1073,"^X",1072,536917546]],["^15",[1073,"^V",1072,536917546]],["^15",[1073,"^U",1072,536917547]],["^15",[1073,"^?",["^ "],536917546]],["^15",[1073,"^17",true,536917546]],["^15",[1073,"^;","~u64c331ff-c762-4951-8a4d-bf4353fc8f24",536917546]],["^15",[1074,"^Q","alias:: DST\naka Unsized Type",536917707]],["^15",[1074,"^O","^16",536917551]],["^15",[1074,"^1;",["^1:",[]],536917707]],["^15",[1074,"^@",false,536917551]],["^15",[1074,"^F",777,536917551]],["^15",[1074,"^X",777,536917551]],["^15",[1074,"^V",777,536917551]],["^15",[1074,"^U",777,536917694]],["^15",[1074,"^U",1079,536917694]],["^15",[1074,"^:",true,536917707]],["^15",[1074,"^?",["^ ","^19",["^1:",["DST"]]],536917707]],["^15",[1074,"^J",["^14",["^19"]],536917707]],["^15",[1074,"^4",["^ ","^19","DST"],536917707]],["^15",[1074,"^H",1079,536917707]],["^15",[1074,"^17",true,536917551]],["^15",[1074,"^;","~u64c3322b-cc1a-455e-8dcb-2869c2be5f95",536917551]],["^15",[1075,"^3","alias:: DST\naka Unsized Type\n\n- Rust needs to know the size of any [[Data Type]] used at compile time. But there are some types like [[str]] (``str``) whose size can't be known at compile time but only at runtime, these are known as DSTs. \n  Like the size of 2 ``str``s, ``\"abc\"`` and ``\"x\"`` isn't the same, but they would be represented by the same data type. \n  Rust solves this by using special [[Reference Type]]s. That is, normal ``&T``s are just single values which are memory addresses, but DSTs are ``&T``s with atleast 2 values, a memory address value and a ``usize`` size. So, DSTs are a reference to a starting address of a contiguous segment of memory and the number of contiguous addresses used is the size of a DST. \n  Meaning ``&str`` is not a normal [[Reference Type]], but a special reference type which actually stores 2 values internally. \n  \n  Since the initial size can be easily calculated, and the memory address size is known at compile time, DSTs are possible.\n- DSTs are required for storing unfixed size types on the stack, for the heap we can already use [[Pointer]]s. So ``&str`` and ``Box<str>`` are both valid.\n- [[Trait]]s are DSTs too, and traits as [[Trait Object]]s are also DSTs, this is why we use ``Box<dyn <trait>>`` syntax. And this is why ``&dyn <trait>`` is valid syntax too.\n- ``Sized`` [[Trait]]\n  is applied to all [[Generic Type]]s implicitly, this is why we can't pass DSTs to normal [[Generic Type]]s.\n  Using ``?Sized`` Trait on any generic type lifts this limitation.\n-",536918330]],["^15",[1075,"^18","~m1690515226572",536918329]],["^15",[1075,"^Z","pages/Dynamically Sized Type.md",536917555]],["^15",[1076,"^Q","[[Dynamically Sized Type]]",536917563]],["^15",[1076,"^O","^16",536917559]],["^15",[1076,"^@",false,536917559]],["^15",[1076,"^F",1061,536917559]],["^15",[1076,"^X",148,536917559]],["^15",[1076,"^V",148,536917559]],["^15",[1076,"^U",148,536917564]],["^15",[1076,"^U",777,536917564]],["^15",[1076,"^?",["^ "],536917563]],["^15",[1076,"^H",777,536917563]],["^15",[1076,"^17",true,536917559]],["^15",[1076,"^;","~u64c3323c-7a20-4ec6-9e94-fba2aed3ca9a",536917559]],["^15",[1078,"^Q","Rust needs to know the size of any [[Data Type]] used at compile time. But there are some types like [[str]] (``str``) whose size can't be known at compile time but only at runtime, these are known as DSTs. \nLike the size of 2 ``str``s, ``\"abc\"`` and ``\"x\"`` isn't the same, but they would be represented by the same data type. \nRust solves this by using special [[Reference Type]]s. That is, normal ``&T``s are just single values which are memory addresses, but DSTs are ``&T``s with atleast 2 values, a memory address value and a ``usize`` size. So, DSTs are a reference to a starting address of a contiguous segment of memory and the number of contiguous addresses used is the size of a DST. \nMeaning ``&str`` is not a normal [[Reference Type]], but a special reference type which actually stores 2 values internally. \n\nSince the initial size can be easily calculated, and the memory address size is known at compile time, DSTs are possible.",536918258]],["^15",[1078,"^O","^16",536917585]],["^15",[1078,"^@",false,536917585]],["^15",[1078,"^F",1074,536917717]],["^15",[1078,"^X",777,536917585]],["^15",[1078,"^V",777,536917585]],["^15",[1078,"^U",148,536918259]],["^15",[1078,"^U",253,536918259]],["^15",[1078,"^U",268,536918259]],["^15",[1078,"^U",777,536918259]],["^15",[1078,"^?",["^ "],536918258]],["^15",[1078,"^H",148,536918258]],["^15",[1078,"^H",253,536918258]],["^15",[1078,"^H",268,536918258]],["^15",[1078,"^17",true,536917585]],["^15",[1078,"^;","~u64c33261-1511-446a-a8d3-152e5e949e25",536917585]],["^15",[1079,"^K",1690514261584,536917693]],["^15",[1079,"^@",false,536917693]],["^15",[1079,"^Y","dst",536917693]],["^15",[1079,"^11","DST",536917693]],["^15",[1079,"^B",1690514261584,536917693]],["^15",[1082,"^Q","DSTs are required for storing unfixed size types on the stack, for the heap we can already use [[Pointer]]s. So ``&str`` and ``Box<str>`` are both valid.",536918262]],["^15",[1082,"^O","^16",536918258]],["^15",[1082,"^@",false,536918258]],["^15",[1082,"^F",1078,536918258]],["^15",[1082,"^X",777,536918258]],["^15",[1082,"^V",777,536918258]],["^15",[1082,"^U",777,536918263]],["^15",[1082,"^U",878,536918263]],["^15",[1082,"^?",["^ "],536918262]],["^15",[1082,"^H",878,536918262]],["^15",[1082,"^17",true,536918258]],["^15",[1082,"^;","~u64c3368c-56d0-431f-b21c-52c984878616",536918258]],["^15",[1083,"^Q","[[Trait]]s are DSTs too, and traits as [[Trait Object]]s are also DSTs, this is why we use ``Box<dyn <trait>>`` syntax. And this is why ``&dyn <trait>`` is valid syntax too.",536918262]],["^15",[1083,"^O","^16",536918262]],["^15",[1083,"^@",false,536918262]],["^15",[1083,"^F",1082,536918262]],["^15",[1083,"^X",777,536918262]],["^15",[1083,"^V",777,536918262]],["^15",[1083,"^U",262,536918263]],["^15",[1083,"^U",414,536918263]],["^15",[1083,"^U",777,536918263]],["^15",[1083,"^?",["^ "],536918262]],["^15",[1083,"^H",262,536918262]],["^15",[1083,"^H",414,536918262]],["^15",[1083,"^17",true,536918262]],["^15",[1083,"^;","~u64c3368e-cf8d-432d-97cd-e3025715f49a",536918262]],["^15",[1084,"^Q","~``Sized`` [[Trait]]\nis applied to all [[Generic Type]]s implicitly, this is why we can't pass DSTs to normal [[Generic Type]]s.\nUsing ``?Sized`` Trait on any generic type lifts this limitation.",536918327]],["^15",[1084,"^O","^16",536918266]],["^15",[1084,"^@",false,536918266]],["^15",[1084,"^F",1083,536918266]],["^15",[1084,"^X",777,536918266]],["^15",[1084,"^V",777,536918266]],["^15",[1084,"^U",131,536918291]],["^15",[1084,"^U",414,536918291]],["^15",[1084,"^U",777,536918291]],["^15",[1084,"^?",["^ "],536918327]],["^15",[1084,"^H",131,536918327]],["^15",[1084,"^H",414,536918327]],["^15",[1084,"^17",true,536918266]],["^15",[1084,"^;","~u64c33690-46e1-427f-9845-ae69d47ff8f5",536918266]],["^15",[1085,"^Q","",536918327]],["^15",[1085,"^O","^16",536918327]],["^15",[1085,"^@",false,536918327]],["^15",[1085,"^F",1084,536918327]],["^15",[1085,"^X",777,536918327]],["^15",[1085,"^V",777,536918327]],["^15",[1085,"^U",777,536918328]],["^15",[1085,"^?",["^ "],536918327]],["^15",[1085,"^17",true,536918327]],["^15",[1085,"^;","~u64c33719-538c-49ba-96ac-6d26468b44a9",536918327]],["^15",[1086,"^Q","Size of\nWe can know the size of any data type with ``core::mem::size_of::<T>();``.\nDefined in the ``core`` [[Crate]] which is in the [[Standard Library]].",536918369]],["^15",[1086,"^O","^16",536918332]],["^15",[1086,"^@",false,536918332]],["^15",[1086,"^F",1065,536918332]],["^15",[1086,"^X",148,536918332]],["^15",[1086,"^V",148,536918332]],["^15",[1086,"^U",93,536918370]],["^15",[1086,"^U",148,536918370]],["^15",[1086,"^U",577,536918370]],["^15",[1086,"^?",["^ "],536918369]],["^15",[1086,"^H",93,536918369]],["^15",[1086,"^H",577,536918369]],["^15",[1086,"^17",true,536918332]],["^15",[1086,"^;","~u64c33722-ad85-4df6-9779-47004a713901",536918332]],["^15",[1087,"^K",1690518279381,536918967]],["^15",[1087,"^[",1089,536919017]],["^15",[1087,"^O","^16",536919012]],["^15",[1087,"^@",false,536918967]],["^15",[1087,"^Y","range",536918967]],["^15",[1087,"^11","Range",536918967]],["^15",[1087,"^B",1690905131109,536922844]],["^15",[1087,"^;","~u64c34307-8d68-4f3d-8167-03953597e483",536918967]],["^15",[1088,"^Q","Defined in the ``std::ops`` [[Module]] of [[Standard Library]] .\nA range is a [[Struct]] defined like so\n\n```rust\npub struct Range<Idx> {\n    pub start: Idx,\n    pub end: Idx,\n}\n\npub struct RangeInclusive<Idx> {\n    pub start: Idx,\n    pub end: Idx,\n}\n```\n\nWe can create a ``Range`` in Rust with a special syntax\n``\n<start value, inclusive> .. <end value, exclusive>\n``\nor create a ``RangeInclusive`` with \n``\n<start value, inclusive> .. =<end value, inclusive>\n``\n\nThese syntaxes don't mean anything by theirselves, but other constructs in Rust understand they mean to represent a [[Collection]] of values like an array and they must iterate from start to end.\n\nFor ex.:\n```rust\nuse std::ops::Range;\n\nfn main() {\n    for i in 1..=5 {\n        //loops from 1 to 5 (inclusive)\n    }\n\n    let x: Range<i32> = 0..5;\n    let y: Vec<i32> = (0..=5).map(|x| x).collect();\n} //works\n```",536922844]],["^15",[1088,"^O","^16",536919013]],["^15",[1088,"^@",false,536919013]],["^15",[1088,"^F",1087,536919013]],["^15",[1088,"^X",1087,536919013]],["^15",[1088,"^V",1087,536919013]],["^15",[1088,"^U",93,536922845]],["^15",[1088,"^U",231,536922845]],["^15",[1088,"^U",242,536922845]],["^15",[1088,"^U",530,536922845]],["^15",[1088,"^U",1087,536922845]],["^15",[1088,"^?",["^ "],536922844]],["^15",[1088,"^H",93,536922844]],["^15",[1088,"^H",231,536922844]],["^15",[1088,"^H",242,536922844]],["^15",[1088,"^H",530,536922844]],["^15",[1088,"^17",true,536919013]],["^15",[1088,"^;","~u64c34352-3063-4b46-93f4-0c3351d81c6c",536919013]],["^15",[1089,"^3","- Defined in the ``std::ops`` [[Module]] of [[Standard Library]] .\n  A range is a [[Struct]] defined like so\n  \n  ```rust\n  pub struct Range<Idx> {\n      pub start: Idx,\n      pub end: Idx,\n  }\n  \n  pub struct RangeInclusive<Idx> {\n      pub start: Idx,\n      pub end: Idx,\n  }\n  ```\n  \n  We can create a ``Range`` in Rust with a special syntax\n  ``\n  <start value, inclusive> .. <end value, exclusive>\n  ``\n  or create a ``RangeInclusive`` with \n  ``\n  <start value, inclusive> .. =<end value, inclusive>\n  ``\n  \n  These syntaxes don't mean anything by theirselves, but other constructs in Rust understand they mean to represent a [[Collection]] of values like an array and they must iterate from start to end.\n  \n  For ex.:\n  ```rust\n  use std::ops::Range;\n  \n  fn main() {\n      for i in 1..=5 {\n          //loops from 1 to 5 (inclusive)\n      }\n  \n      let x: Range<i32> = 0..5;\n      let y: Vec<i32> = (0..=5).map(|x| x).collect();\n  } //works\n  ```\n-",536922847]],["^15",[1089,"^18","~m1690905131639",536922846]],["^15",[1089,"^Z","pages/Range.md",536919017]],["^15",[1090,"^Q","",536919097]],["^15",[1090,"^O","^16",536919090]],["^15",[1090,"^@",false,536919090]],["^15",[1090,"^F",1088,536919090]],["^15",[1090,"^X",1087,536919090]],["^15",[1090,"^V",1087,536919090]],["^15",[1090,"^U",1087,536919091]],["^15",[1090,"^?",["^ "],536919097]],["^15",[1090,"^17",true,536919090]],["^15",[1090,"^;","~u64c343ee-4373-4fdf-ae59-25fec38f64c8",536919090]],["^15",[1091,"^U",131,536919475]],["^15",[1092,"^U",131,536919475]],["^15",[1093,"^U",131,536919475]],["^15",[1094,"^U",131,536919475]],["^15",[1095,"^U",131,536919475]],["^15",[1096,"^U",131,536919475]],["^15",[1097,"^U",131,536919475]],["^15",[1098,"^U",131,536919475]],["^15",[1099,"^U",131,536919475]],["^15",[1100,"^U",131,536919475]],["^15",[1101,"^U",131,536919475]],["^15",[1102,"^U",131,536919475]],["^15",[1103,"^U",131,536919584]],["^15",[1104,"^U",131,536919584]],["^15",[1105,"^U",131,536919584]],["^15",[1106,"^U",131,536919584]],["^15",[1107,"^Q","",536925759]],["^15",[1107,"^O","^16",536919637]],["^15",[1107,"^@",false,536919637]],["^15",[1107,"^F",745,536919637]],["^15",[1107,"^X",131,536919637]],["^15",[1107,"^V",131,536919637]],["^15",[1107,"^U",131,536925760]],["^15",[1107,"^?",["^ "],536925759]],["^15",[1107,"^17",true,536919637]],["^15",[1107,"^;","~u64c34a0f-b02c-4b6d-adfd-7a55c958b7e6",536919641]],["^15",[1108,"^U",131,536919642]],["^15",[1109,"^U",131,536919642]],["^15",[1110,"^U",131,536919642]],["^15",[1111,"^12",2,536919769]],["^15",[1112,"^K",1690876511475,536919770]],["^15",[1112,"^O","^16",536919770]],["^15",[1112,"^N",20230801,536919770]],["^15",[1112,"^@",true,536919770]],["^15",[1112,"^Y","aug 1st, 2023",536919770]],["^15",[1112,"^11","Aug 1st, 2023",536919770]],["^15",[1112,"^B",1690876511475,536919770]],["^15",[1112,"^;","~u64c8ba5f-62c6-40ea-b425-ac6f50077dbf",536919770]],["^15",[1113,"^Q","",536919771]],["^15",[1113,"^O","^16",536919771]],["^15",[1113,"^N",20230801,536919771]],["^15",[1113,"^@",true,536919771]],["^15",[1113,"^F",1112,536919771]],["^15",[1113,"^X",1112,536919771]],["^15",[1113,"^V",1112,536919771]],["^15",[1113,"^U",1112,536919772]],["^15",[1113,"^?",["^ "],536919771]],["^15",[1113,"^17",true,536919771]],["^15",[1113,"^;","~u64c8ba5f-29d2-4d8b-b8cb-2afb75ea134f",536919771]],["^15",[1114,"^Q","Macros are special symbols that expand to more text in the source code.\nJust like *C++* has *#define* which can define a symbol which is expanded before compilation phase and modifies the code in the translation unit, Rust has macros which are symbols that get replaced with other text in the equivalent of translation unit in rust (not sure what it is [[TODO]]).\n\nThis means, we can use macros to define [[Function]]s and other code in a single place, and using the same symbol in different projects can allow us to skip writing a lot of boilerplate. \nThe only cost associated with Macros is the less simpler syntax and linter assistance making them harder to maintain and debug. As they use a slightly different syntax than normal Rust.\n\n* Unlike [[Function]]s, Macros must be defined/imported into a [[Scope]] before being used.\n\n* Rust has 2 main type, but 4 different sub-types of Macros\nDeclarative macros: Implemented with [[macro_rules!]]\nProcedural macros: They include [[Custom Derive Macro]]s, [[Macro Attribute]]s and [[Function Macro]]s.",536920627]],["^15",[1114,"^O","^16",536919774]],["^15",[1114,"^@",false,536919774]],["^15",[1114,"^F",246,536919774]],["^15",[1114,"^X",246,536919774]],["^15",[1114,"^V",246,536919774]],["^15",[1114,"^U",4,536920184]],["^15",[1114,"^U",89,536920184]],["^15",[1114,"^U",130,536920184]],["^15",[1114,"^U",246,536920184]],["^15",[1114,"^U",811,536920184]],["^15",[1114,"^U",1117,536920184]],["^15",[1114,"^U",1118,536920184]],["^15",[1114,"^U",1120,536920184]],["^15",[1114,"^?",["^ "],536920627]],["^15",[1114,"^H",4,536920627]],["^15",[1114,"^H",89,536920627]],["^15",[1114,"^H",130,536920627]],["^15",[1114,"^H",811,536920627]],["^15",[1114,"^H",1117,536920627]],["^15",[1114,"^H",1118,536920627]],["^15",[1114,"^H",1120,536920627]],["^15",[1114,"^17",true,536919774]],["^15",[1114,"^;","~u64c8babf-5fbe-4f7f-8578-19dbf5a1d604",536919774]],["^15",[1115,"^Q","Traits have to be implemented on [[Data Type]]s by the compile-time, Rust doesn't support dynamically implementing traits on types at runtime. So [[Function]]s can't implement Traits, but [[Macro]]s can.",536920001]],["^15",[1115,"^O","^16",536919987]],["^15",[1115,"^@",false,536919987]],["^15",[1115,"^F",749,536919987]],["^15",[1115,"^X",414,536919987]],["^15",[1115,"^V",414,536919987]],["^15",[1115,"^U",130,536919998]],["^15",[1115,"^U",148,536919998]],["^15",[1115,"^U",246,536919998]],["^15",[1115,"^U",414,536919998]],["^15",[1115,"^?",["^ "],536920001]],["^15",[1115,"^H",130,536920001]],["^15",[1115,"^H",148,536920001]],["^15",[1115,"^H",246,536920001]],["^15",[1115,"^17",true,536919987]],["^15",[1115,"^;","~u64c8bcb4-bffb-4776-91c7-1d1aa0e4e327",536919987]],["^15",[1116,"^Q","",536920108]],["^15",[1116,"^O","^16",536920108]],["^15",[1116,"^@",false,536920108]],["^15",[1116,"^F",1119,536920176]],["^15",[1116,"^X",246,536920108]],["^15",[1116,"^V",246,536920108]],["^15",[1116,"^U",246,536920109]],["^15",[1116,"^?",["^ "],536920108]],["^15",[1116,"^17",true,536920108]],["^15",[1116,"^;","~u64c8c64e-ad8b-47e6-a4ac-2f73febb7715",536920108]],["^15",[1117,"^K",1690879720104,536920176]],["^15",[1117,"^@",false,536920176]],["^15",[1117,"^Y","function macro",536920176]],["^15",[1117,"^11","Function Macro",536920176]],["^15",[1117,"^B",1690879720104,536920176]],["^15",[1117,"^;","~u64c8c6e8-3832-4b65-8b4d-258b4b25c905",536920176]],["^15",[1118,"^K",1690879720104,536920176]],["^15",[1118,"^@",false,536920176]],["^15",[1118,"^Y","custom derive macro",536920176]],["^15",[1118,"^11","Custom Derive Macro",536920176]],["^15",[1118,"^B",1690879720104,536920176]],["^15",[1118,"^;","~u64c8c6e8-78a6-4398-a483-c225ec39ff4a",536920176]],["^15",[1119,"^Q","Procedural Macros\nThese macros must be defined in their own special [[Crate]]s and then added as a dependency to the crate that needs to use them.\n\nFor ex.:\n```rust\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n```\n``TokenStream`` is a [[Data Type]] that is defined by Rust itself and holds the source code in text.\n\n* [[Procedural Macro Crate]]s are different from normal crates.\n* [[Custom Derive Macro]]s are macros like ``#[something_derive]`` applied only on either [[Struct]]s or [[Enum]]s. They need to have ``derive`` at the end of their name due to how [[Procedural Macro Crate]]s are defined, this is a known technical limitation.\n\nThese macros are defined with the ``#[proc_macro_derive]`` [[Macro Attribute]]. \n\nFor ex.:\n```rust\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&ast)\n}\n```\n* [[Macro Attribute]]s are like Custom Derive Macros but they don't have the limitation of ``derive`` name at their end and can be applied to other items such as [[Function]]s too. They take the whole item, such as a function, modify it, and return the newly modified function back. \nFor ex.:\n```rust\n#[route(GET, \"/\")]\nfn index() { }\n```\nThese macros are defined with ``#[proc_macro_attribute]``\nFor ex.:\n```rust\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {}\n```\n\n* [[Function Macro]]s define macros that look like functions and work kind of like [[macro_rules!]]. They can take any number of arguments and accept ``TokenStream`` as parameter so they take the code and modify it and return it, just like [[macro_rules!]] but without any pattern matching involved.\nThe syntax to call them is ``<some proc macro name>!(<some code>)`` which is slightly different from [[macro_rules!]].\n\nThese macros are defined with the ``#[proc_macro]`` syntax\n\nFor ex.:\n```rust\npub fn sql(input: TokenStream) -> TokenStream { }\n```",536921482]],["^15",[1119,"^O","^16",536920176]],["^15",[1119,"^@",false,536920176]],["^15",[1119,"^F",1114,536920176]],["^15",[1119,"^X",246,536920176]],["^15",[1119,"^V",246,536920176]],["^15",[1119,"^U",130,536921329]],["^15",[1119,"^U",148,536921329]],["^15",[1119,"^U",242,536921329]],["^15",[1119,"^U",246,536921329]],["^15",[1119,"^U",511,536921329]],["^15",[1119,"^U",577,536921329]],["^15",[1119,"^U",811,536921329]],["^15",[1119,"^U",1117,536921329]],["^15",[1119,"^U",1118,536921329]],["^15",[1119,"^U",1120,536921329]],["^15",[1119,"^U",1126,536921329]],["^15",[1119,"^?",["^ "],536921482]],["^15",[1119,"^H",130,536921482]],["^15",[1119,"^H",148,536921482]],["^15",[1119,"^H",242,536921482]],["^15",[1119,"^H",511,536921482]],["^15",[1119,"^H",577,536921482]],["^15",[1119,"^H",811,536921482]],["^15",[1119,"^H",1117,536921482]],["^15",[1119,"^H",1118,536921482]],["^15",[1119,"^H",1120,536921482]],["^15",[1119,"^H",1126,536921482]],["^15",[1119,"^17",true,536920176]],["^15",[1119,"^;","~u64c8c6e8-77ec-4185-b7b1-200703040c6f",536920176]],["^15",[1120,"^K",1690888285681,536920183]],["^15",[1120,"^[",1122,536920200]],["^15",[1120,"^O","^16",536920187]],["^15",[1120,"^@",false,536920183]],["^15",[1120,"^Y","macro_rules!",536920192]],["^15",[1120,"^11","macro_rules!",536920192]],["^15",[1120,"^B",1690890939558,536921039]],["^15",[1120,"^;","~u64c8e85d-7522-4f1b-a0e8-c77093001a72",536920183]],["^15",[1121,"^Q","~``macro_rules!``\nThese [[Macro]]s work much like ``Match`` and use [[Pattern Matching]]. \nA declarative macro like ``macro_rules!`` looks for given patterns in the passed source code, and replaces the matched code with provided code.\n\nFor ex.:\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n```\nThis is kind of how ``vec!`` declarative macro is defined for [[Vector]]s.\n\n``#[macro_export]`` is an [[Macro Attribute]] itself, and it defines this macro wherever it is imported. \n\n``macro_rules! <macro name>`` defines the declarative macro, for a ``<macro name>``, it is called with ``<macro name>!``, the ``!`` character denotes that a declarative macro is being used.\n\nThe ``(<pattern>) => {<expression>}`` syntax defines a single arm of this declarative macro, it means that only code that matches this pattern can be passed to this macro. If we define more patterns, we can have pass more variety of code to this macro. Other patterns can be found at [Docs](https://doc.rust-lang.org/reference/macros-by-example.html).\n\nIn the pattern, the outer ``()``  defines the whole value passed to the macro ``$()`` defines a [[Macro Variable]], this variable will be replaced with a value when the code matches the pattern, in it ``$x:expr`` matches any Rust expression and assigns its resultant value to x. Lastly the ``,*`` say that the literal character ``,`` will be followed by an expression and ``*`` says it can be any number of times. So ``vec![1,2,3]`` will pass ``1``, ``2`` and ``3`` to ``x`` [[Macro Variable]].\n\nIn the expression, we have normal Rust code and then the ``$()*`` block, this block indicates that it must be replaced itself with some concrete code after completing all patterns inside it, the pattern here is ``temp_vec.push($x)`` and here the ``$x`` is the macro variable which is replaced with its concrete value, the ``*`` means, it can be generated any number of times.",536921036]],["^15",[1121,"^O","^16",536920188]],["^15",[1121,"^@",false,536920188]],["^15",[1121,"^F",1120,536920188]],["^15",[1121,"^X",1120,536920188]],["^15",[1121,"^V",1120,536920188]],["^15",[1121,"^U",202,536920799]],["^15",[1121,"^U",238,536920799]],["^15",[1121,"^U",246,536920799]],["^15",[1121,"^U",811,536920799]],["^15",[1121,"^U",1120,536920799]],["^15",[1121,"^U",1125,536920799]],["^15",[1121,"^?",["^ "],536921039]],["^15",[1121,"^H",202,536921039]],["^15",[1121,"^H",238,536921039]],["^15",[1121,"^H",246,536921039]],["^15",[1121,"^H",811,536921039]],["^15",[1121,"^H",1125,536921039]],["^15",[1121,"^17",true,536920188]],["^15",[1121,"^;","~u64c8e860-9514-4bc7-8ce2-a9be615c874c",536920188]],["^15",[1122,"^3","- ``macro_rules!``\n  These [[Macro]]s work much like ``Match`` and use [[Pattern Matching]]. \n  A declarative macro like ``macro_rules!`` looks for given patterns in the passed source code, and replaces the matched code with provided code.\n  \n  For ex.:\n  ```rust\n  #[macro_export]\n  macro_rules! vec {\n      ( $( $x:expr ),* ) => {\n          {\n              let mut temp_vec = Vec::new();\n              $(\n                  temp_vec.push($x);\n              )*\n              temp_vec\n          }\n      };\n  }\n  ```\n  This is kind of how ``vec!`` declarative macro is defined for [[Vector]]s.\n  \n  ``#[macro_export]`` is an [[Macro Attribute]] itself, and it defines this macro wherever it is imported. \n  \n  ``macro_rules! <macro name>`` defines the declarative macro, for a ``<macro name>``, it is called with ``<macro name>!``, the ``!`` character denotes that a declarative macro is being used.\n  \n  The ``(<pattern>) => {<expression>}`` syntax defines a single arm of this declarative macro, it means that only code that matches this pattern can be passed to this macro. If we define more patterns, we can have pass more variety of code to this macro. Other patterns can be found at [Docs](https://doc.rust-lang.org/reference/macros-by-example.html).\n  \n  In the pattern, the outer ``()``  defines the whole value passed to the macro ``$()`` defines a [[Macro Variable]], this variable will be replaced with a value when the code matches the pattern, in it ``$x:expr`` matches any Rust expression and assigns its resultant value to x. Lastly the ``,*`` say that the literal character ``,`` will be followed by an expression and ``*`` says it can be any number of times. So ``vec![1,2,3]`` will pass ``1``, ``2`` and ``3`` to ``x`` [[Macro Variable]].\n  \n  In the expression, we have normal Rust code and then the ``$()*`` block, this block indicates that it must be replaced itself with some concrete code after completing all patterns inside it, the pattern here is ``temp_vec.push($x)`` and here the ``$x`` is the macro variable which is replaced with its concrete value, the ``*`` means, it can be generated any number of times.",536921041]],["^15",[1122,"^18","~m1690890940017",536921040]],["^15",[1122,"^Z","pages/macro_rules!.md",536920200]],["^15",[1125,"^K",1690890096602,536920798]],["^15",[1125,"^@",false,536920798]],["^15",[1125,"^Y","macro variable",536920798]],["^15",[1125,"^11","Macro Variable",536920798]],["^15",[1125,"^B",1690890096602,536920798]],["^15",[1125,"^;","~u64c8ef70-a079-4234-bff9-82f6b817b5cd",536920798]],["^15",[1126,"^K",1690892707050,536921177]],["^15",[1126,"^@",false,536921177]],["^15",[1126,"^Y","procedural macro crate",536921177]],["^15",[1126,"^11","Procedural Macro Crate",536921177]],["^15",[1126,"^B",1690892707050,536921177]],["^15",[1126,"^;","~u64c8f9a3-9502-4cb3-ac79-8803e3ce61b3",536921177]],["^15",[1127,"^Q","[[Async and Await]]",536921553]],["^15",[1127,"^O","^16",536921549]],["^15",[1127,"^@",false,536921549]],["^15",[1127,"^F",994,536921549]],["^15",[1127,"^X",971,536921549]],["^15",[1127,"^V",971,536921549]],["^15",[1127,"^U",971,536921554]],["^15",[1127,"^U",1128,536921554]],["^15",[1127,"^?",["^ "],536921553]],["^15",[1127,"^H",1128,536921553]],["^15",[1127,"^17",true,536921549]],["^15",[1127,"^;","~u64c90594-dfb9-4ca9-ac9b-f2da032bdfaa",536921549]],["^15",[1128,"^K",1690895771847,536921553]],["^15",[1128,"^[",1130,536921563]],["^15",[1128,"^O","^16",536921557]],["^15",[1128,"^@",false,536921553]],["^15",[1128,"^Y","async and await",536921553]],["^15",[1128,"^11","Async and Await",536921553]],["^15",[1128,"^B",1690967655281,536925754]],["^15",[1128,"^;","~u64c9059b-7a3e-46d8-87f7-5c2df2482116",536921553]],["^15",[1129,"^Q","Async/Await model in other languages is a high level method of working with concurrency. \nUnlike OS [[Thread]]s,  this model allows for things like Coroutines, Event driven programming (Callbacks) and the like. \nIn rust, Async/Await model is natively supported and has its own features. But it lacks a runtime, which is left upto community [[Crate]]s, meaning a model to actually handle async/await paradigm in rust at runtime has to be added manually.\n\nRust uses [[Future]]s, \nasync in Rust has 0 cost, meaning we have no dynamic dispatch or heap allocations for async [[Function]]s,\nand Futures are inert, meaning they are lazy and only execute when polled and don't use up additional resources until needed, and drop everything if they are dropped without going to completion.\n\n* Async vs [[Thread]]s: Threads incur a memory and CPU overhead when they have to be spawned, and they consume the same even at runtime and even they are idle. \nAsync overcomes this by having a few threads and managed by a state machine, this means the binary size is greater as this added construct handles tasks at runtime but the overhead is smaller and that allows for greater number of concurrent tasks. \nHence, Async paradigm is better than thread paradigm but also more complex, introduces more sources for bugs and requires a slightly different programming model than synchronous code which goes well even with threads.\n\n* Async/Await and ``Future`` [[Trait]] are provided by Rust and its [[Standard Library]]. However, many utility [[Data Type]]s, [[Macro]]s and [[Function]]s to work with these are provided by the ``futures`` [[Crate]]. Then the execution of async code, IO and task spawning is provided by the async runtime which is provided by any external crate, such as ``Tokio``.",536922383]],["^15",[1129,"^O","^16",536921558]],["^15",[1129,"^@",false,536921558]],["^15",[1129,"^F",1128,536921558]],["^15",[1129,"^X",1128,536921558]],["^15",[1129,"^V",1128,536921558]],["^15",[1129,"^U",93,536922384]],["^15",[1129,"^U",130,536922384]],["^15",[1129,"^U",148,536922384]],["^15",[1129,"^U",246,536922384]],["^15",[1129,"^U",414,536922384]],["^15",[1129,"^U",577,536922384]],["^15",[1129,"^U",822,536922384]],["^15",[1129,"^U",1128,536922384]],["^15",[1129,"^U",1131,536922384]],["^15",[1129,"^?",["^ "],536922383]],["^15",[1129,"^H",93,536922383]],["^15",[1129,"^H",130,536922383]],["^15",[1129,"^H",148,536922383]],["^15",[1129,"^H",246,536922383]],["^15",[1129,"^H",414,536922383]],["^15",[1129,"^H",577,536922383]],["^15",[1129,"^H",822,536922383]],["^15",[1129,"^H",1131,536922383]],["^15",[1129,"^17",true,536921558]],["^15",[1129,"^;","~u64c9059c-3bfb-481a-86e4-53c199c8657b",536921558]],["^15",[1130,"^3","- Async/Await model in other languages is a high level method of working with concurrency. \n  Unlike OS [[Thread]]s,  this model allows for things like Coroutines, Event driven programming (Callbacks) and the like. \n  In rust, Async/Await model is natively supported and has its own features. But it lacks a runtime, which is left upto community [[Crate]]s, meaning a model to actually handle async/await paradigm in rust at runtime has to be added manually.\n  \n  Rust uses [[Future]]s, \n  async in Rust has 0 cost, meaning we have no dynamic dispatch or heap allocations for async [[Function]]s,\n  and Futures are inert, meaning they are lazy and only execute when polled and don't use up additional resources until needed, and drop everything if they are dropped without going to completion.\n  \n  * Async vs [[Thread]]s: Threads incur a memory and CPU overhead when they have to be spawned, and they consume the same even at runtime and even they are idle. \n  Async overcomes this by having a few threads and managed by a state machine, this means the binary size is greater as this added construct handles tasks at runtime but the overhead is smaller and that allows for greater number of concurrent tasks. \n  Hence, Async paradigm is better than thread paradigm but also more complex, introduces more sources for bugs and requires a slightly different programming model than synchronous code which goes well even with threads.\n  \n  * Async/Await and ``Future`` [[Trait]] are provided by Rust and its [[Standard Library]]. However, many utility [[Data Type]]s, [[Macro]]s and [[Function]]s to work with these are provided by the ``futures`` [[Crate]]. Then the execution of async code, IO and task spawning is provided by the async runtime which is provided by any external crate, such as ``Tokio``.\n- Async [[Function]]: ``async`` on functions turn them into state machines, and they implement the ``Future`` [[Trait]] automatically. [[Future]] are like normal functions but they don't block the caller [[Thread]] like normal functions when they are called, they yield the control back and are continued by the async runtime when the value from the future is needed.\n  \n  For ex.:\n  First we add ``Future`` trait as a dependency in [[cargo.toml]] ,\n  ```toml\n  [dependencies]\n  futures = \"0.3\"\n  ```\n  Then we can use ``block_on``, \n  ```rust\n  // `block_on` blocks the current thread until the provided future has run to\n  // completion. Other executors provide more complex behavior, like scheduling\n  // multiple futures onto the same thread.\n  use futures::executor::block_on;\n  \n  async fn hello_world() {\n      println!(\"hello, world!\");  \n  }\n  \n  fn main() {\n      let future = hello_world(); // Immediately returns a future but doesn't execute the function.\n      block_on(future); // `future` is run and \"hello, world!\" is printed\n  }\n  ```\n  ``block_on`` is an [[Executor]], meaning it executes the given future [[Data Type]].\n  \n  * ``.await``: Awaits a future concurrently, as we know a ``Future<T>`` [[Data Type]] is returned immediately when an async function is called, ``await`` on the ``Future<T>`` concurrently waits on the ``Future`` and executes the function whenever the async runtime has time to do so or if the return value is required.\n  For ex.:\n  ```rust\n  async fn learn_song() -> i32 {\n   2\n   }\n  async fn sing_song(x: i32) {  }\n  async fn dance() { }\n  \n  async fn learn_and_sing() {\n      \n      // We use `.await` here rather than `block_on` to prevent blocking the\n      // thread, which makes it possible to `dance` at the same time.\n      let song = learn_song().await; //returns a future, then await on it returns the value i32\n      sing_song(song).await; //ok, whilst both are started at same time, since this needs the return value of learn_song, it is ran to completion\n  }\n  \n  async fn async_main() {\n      let f1 = learn_and_sing();\n      let f2 = dance();\n  \n      // `join!` is like `.await` but can wait for multiple futures concurrently.\n      // If we're temporarily blocked in the `learn_and_sing` future, the `dance`\n      // future will take over the current thread. If `dance` becomes blocked,\n      // `learn_and_sing` can take back over. If both futures are blocked, then\n      // `async_main` is blocked and will yield to the executor.\n      futures::join!(f1, f2);\n  }\n  \n  fn main() {\n      block_on(async_main());\n  }\n  ```\n- Async [[Function]]s with explicit return type and async block\n  Async functions are normal functions that return a ``Future<T>``, it is optional to write the whole syntax as we can just write ``T`` for the return and it means the same thing.\n  \n  Async can also be applied to [[Scope]] blocks, these blocks also return a ``Future<T>``. \n  For ex.:\n  ```rust\n  // `foo()` returns a type that implements `Future<Output = u8>`.\n  // `foo().await` will result in a value of type `u8`.\n  async fn foo() -> u8 { 5 }\n   \n  fn bar() -> impl Future<Output = u8> {\n      // This `async` block results in a type that implements\n      // `Future<Output = u8>`.\n      async {\n          let x: u8 = foo().await;\n          x + 5\n      }\n  }\n  \n  \n  fn main() {\n   block_on(bar());\n  }\n  \n  ```\n  \n  * Async [[Lifetime]]\n  \n  Async [[Function]]s that take [[Reference Type]]s (with non static lifetimes) and have no explicit return type automatically use the lifetime of the return type.\n  \n  For ex.:\n  ```rust\n  // This function:\n  async fn foo(x: &u8) -> u8 { *x }\n  \n  // Is equivalent to this function:\n  fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n      async move { *x }\n  }\n  ```\n  Here, if the ``Future<T>`` returned from ``foo_expanded`` used reference ``x`` and passed it as a reference again to the async block, then the async block won't have access to x as the rest of the function scope is over and future's aren't executed right away, so ``x`` is automatically ``move``d into the returned ``Future<T>``. And since the returned ``Future<T>`` uses a reference, it needs to define the lifetime as well.\n  \n  This also means, that if our async function passes a reference created inside it to another async function/block and returns it, then it must move it otherwise the same issue would occur.\n  \n  For ex.:\n  ```rust\n  async fn borrow_x(x: &i32) -> u8 {\n   2\n  }\n  \n  fn bad() -> impl Future<Output = u8> {\n      let x = 5;\n      //borrow_x(&x) // ERROR: `x` does not live long enough\n  }\n  \n  fn good() -> impl Future<Output = u8> {\n      async {\n          let x = 5;\n          borrow_x(&x).await //ok, since the async block has the reference and doesn't rely on the body of good() to be in scope\n      }\n  }\n  ```\n- Async ``move``\n  Used async blocks.\n  Just like the ``move`` in [[Closure]]s. Moves the references into the block.\n  \n  For ex.:\n  ```rust\n  fn yo() -> impl Future<Output= i32>{\n    let x= 20;\n  async move{\n     *(&x) //moves x into this closure\n    }\n  }\n  ```\n- [[Pointer]]s from the [[Standard Library]] such as [[Rc<T>]], [[Mutex<T>]] etc. don't necessarily implement the ``Send`` [[Trait]]. This can cause one thread to lock up a value and another to request it when using [[Future]]s. \n  This is why it is recommended to use ``Future``-aware [[Pointer]]s such as ``Mutex`` from ``futures::lock`` [[Module]] instead of ``std::sync``.\n- ``async_std`` is in [[Standard Library]]\n  It provides some async features such as ``async_std::task::spawn``. This allows task spawning. Meaning, we can pass a [[Future]] to ``spawn(...)`` [[Function]] and it is executed asynchronously, it returns a ``JoinHandle`` which can be ``.await``ed.\n- ``?`` with ``await`` on [[Result Type]]s\n  For ex.:\n  ```rust\n  let fut = async {\n      foo().await?;\n      bar().await?;\n      //Ok(()) //error\n      Ok::<(), MyError>(()) // <- note the explicit type annotation here\n  };\n  ```\n  We need to use the ``Turbofish`` [[Operator]] to explicitly define the return type with ``?``. This is a known limitation with Rust's compiler.",536925756]],["^15",[1130,"^18","~m1690967655707",536925755]],["^15",[1130,"^Z","pages/Async and Await.md",536921563]],["^15",[1131,"^K",1690896063723,536921741]],["^15",[1131,"^[",1172,536925047]],["^15",[1131,"^O","^16",536925042]],["^15",[1131,"^@",false,536921741]],["^15",[1131,"^Y","future",536921741]],["^15",[1131,"^11","Future",536921741]],["^15",[1131,"^B",1690967324916,536925574]],["^15",[1131,"^;","~u64c906bf-2cb8-425a-a519-a2716083d182",536921741]],["^15",[1132,"^Q","Async [[Function]]s with explicit return type and async block\nAsync functions are normal functions that return a ``Future<T>``, it is optional to write the whole syntax as we can just write ``T`` for the return and it means the same thing.\n\nAsync can also be applied to [[Scope]] blocks, these blocks also return a ``Future<T>``. \nFor ex.:\n```rust\n// `foo()` returns a type that implements `Future<Output = u8>`.\n// `foo().await` will result in a value of type `u8`.\nasync fn foo() -> u8 { 5 }\n \nfn bar() -> impl Future<Output = u8> {\n    // This `async` block results in a type that implements\n    // `Future<Output = u8>`.\n    async {\n        let x: u8 = foo().await;\n        x + 5\n    }\n}\n\n\nfn main() {\n block_on(bar());\n}\n\n```\n\n* Async [[Lifetime]]\n\nAsync [[Function]]s that take [[Reference Type]]s (with non static lifetimes) and have no explicit return type automatically use the lifetime of the return type.\n\nFor ex.:\n```rust\n// This function:\nasync fn foo(x: &u8) -> u8 { *x }\n\n// Is equivalent to this function:\nfn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n    async move { *x }\n}\n```\nHere, if the ``Future<T>`` returned from ``foo_expanded`` used reference ``x`` and passed it as a reference again to the async block, then the async block won't have access to x as the rest of the function scope is over and future's aren't executed right away, so ``x`` is automatically ``move``d into the returned ``Future<T>``. And since the returned ``Future<T>`` uses a reference, it needs to define the lifetime as well.\n\nThis also means, that if our async function passes a reference created inside it to another async function/block and returns it, then it must move it otherwise the same issue would occur.\n\nFor ex.:\n```rust\nasync fn borrow_x(x: &i32) -> u8 {\n 2\n}\n\nfn bad() -> impl Future<Output = u8> {\n    let x = 5;\n    //borrow_x(&x) // ERROR: `x` does not live long enough\n}\n\nfn good() -> impl Future<Output = u8> {\n    async {\n        let x = 5;\n        borrow_x(&x).await //ok, since the async block has the reference and doesn't rely on the body of good() to be in scope\n    }\n}\n```",536923884]],["^15",[1132,"^O","^16",536921852]],["^15",[1132,"^@",false,536921852]],["^15",[1132,"^F",1134,536922383]],["^15",[1132,"^X",1128,536921852]],["^15",[1132,"^V",1128,536921852]],["^15",[1132,"^U",89,536923479]],["^15",[1132,"^U",130,536923479]],["^15",[1132,"^U",253,536923479]],["^15",[1132,"^U",280,536923479]],["^15",[1132,"^U",1128,536923479]],["^15",[1132,"^?",["^ "],536923884]],["^15",[1132,"^H",89,536923884]],["^15",[1132,"^H",130,536923884]],["^15",[1132,"^H",253,536923884]],["^15",[1132,"^H",280,536923884]],["^15",[1132,"^17",true,536921852]],["^15",[1132,"^;","~u64c9074e-8806-436f-afaa-288dbdcc10fd",536921852]],["^15",[1134,"^Q","Async [[Function]]: ``async`` on functions turn them into state machines, and they implement the ``Future`` [[Trait]] automatically. [[Future]] are like normal functions but they don't block the caller [[Thread]] like normal functions when they are called, they yield the control back and are continued by the async runtime when the value from the future is needed.\n\nFor ex.:\nFirst we add ``Future`` trait as a dependency in [[cargo.toml]] ,\n```toml\n[dependencies]\nfutures = \"0.3\"\n```\nThen we can use ``block_on``, \n```rust\n// `block_on` blocks the current thread until the provided future has run to\n// completion. Other executors provide more complex behavior, like scheduling\n// multiple futures onto the same thread.\nuse futures::executor::block_on;\n\nasync fn hello_world() {\n    println!(\"hello, world!\");  \n}\n\nfn main() {\n    let future = hello_world(); // Immediately returns a future but doesn't execute the function.\n    block_on(future); // `future` is run and \"hello, world!\" is printed\n}\n```\n``block_on`` is an [[Executor]], meaning it executes the given future [[Data Type]].\n\n* ``.await``: Awaits a future concurrently, as we know a ``Future<T>`` [[Data Type]] is returned immediately when an async function is called, ``await`` on the ``Future<T>`` concurrently waits on the ``Future`` and executes the function whenever the async runtime has time to do so or if the return value is required.\nFor ex.:\n```rust\nasync fn learn_song() -> i32 {\n 2\n }\nasync fn sing_song(x: i32) {  }\nasync fn dance() { }\n\nasync fn learn_and_sing() {\n    \n    // We use `.await` here rather than `block_on` to prevent blocking the\n    // thread, which makes it possible to `dance` at the same time.\n    let song = learn_song().await; //returns a future, then await on it returns the value i32\n    sing_song(song).await; //ok, whilst both are started at same time, since this needs the return value of learn_song, it is ran to completion\n}\n\nasync fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n\n    // `join!` is like `.await` but can wait for multiple futures concurrently.\n    // If we're temporarily blocked in the `learn_and_sing` future, the `dance`\n    // future will take over the current thread. If `dance` becomes blocked,\n    // `learn_and_sing` can take back over. If both futures are blocked, then\n    // `async_main` is blocked and will yield to the executor.\n    futures::join!(f1, f2);\n}\n\nfn main() {\n    block_on(async_main());\n}\n```",536923339]],["^15",[1134,"^O","^16",536922383]],["^15",[1134,"^@",false,536922383]],["^15",[1134,"^F",1129,536922383]],["^15",[1134,"^X",1128,536922383]],["^15",[1134,"^V",1128,536922383]],["^15",[1134,"^U",43,536923025]],["^15",[1134,"^U",130,536923025]],["^15",[1134,"^U",148,536923025]],["^15",[1134,"^U",414,536923025]],["^15",[1134,"^U",822,536923025]],["^15",[1134,"^U",1128,536923025]],["^15",[1134,"^U",1131,536923025]],["^15",[1134,"^U",1135,536923025]],["^15",[1134,"^?",["^ "],536923339]],["^15",[1134,"^H",43,536923339]],["^15",[1134,"^H",130,536923339]],["^15",[1134,"^H",148,536923339]],["^15",[1134,"^H",414,536923339]],["^15",[1134,"^H",822,536923339]],["^15",[1134,"^H",1131,536923339]],["^15",[1134,"^H",1135,536923339]],["^15",[1134,"^17",true,536922383]],["^15",[1134,"^;","~u64c92558-b160-48d1-8f4b-16e86670258f",536922383]],["^15",[1135,"^@",false,536922383]],["^15",[1135,"^Y","executor",536922383]],["^15",[1135,"^11","Executor",536922383]],["^15",[1135,"^;","~u64c924a7-2a13-41e9-8c26-091dc6769c0c",536922383]],["^15",[1136,"^Q","Pointers and the address problem\nConsider a [[Struct]] like so\n```rust\n#[derive(Debug)]\nstruct Test {\n    a: String,\n    b: *const String,\n}\n//and the impl block is designed like pointer b always points to a\n//thereby creating a self-referencing struct\nimpl Test {\n    fn new(txt: &str) -> Self {\n        Test {\n            a: String::from(txt),\n            b: std::ptr::null(),\n        }\n    }\n\n    fn init(&mut self) {\n        let self_ref: *const String = &self.a;\n        self.b = self_ref;\n    }\n\n    fn a(&self) -> &str {\n        &self.a\n    }\n\n    fn b(&self) -> &String {\n        assert!(!self.b.is_null(), \"Test::b called without Test::init being called first\");\n        unsafe { &*(self.b) }\n    }\n}\n\n//Now somewhere we do  std::mem::swap(&mut test1, &mut test2); \n```\n Now if we print the value behind b after swapping the memory of 2 objects, that is we swap the memory where the object's reference is stored, then we swap each field's data at their memory addresses. But ``mem::swap`` [[Module]] doesn't modify the values in their addresses, so the pointers will still point to  their old addresses, thereby breaking the self-referential struct.\n\nThat is,\n![image.png](../assets/image_1690904345284_0.png)\n \nWhen we store a pointer as a [[Data Type]] and then do a ``mem::swap`` with another of the same type then the pointer's data is swapped. But, the values at the address theirselves aren't modified.\nThis isn't an issue with non self-referential types as it would be intended to have the pointers still point to the same address, but in self-referential types, it'd be a problem.\n \nFor this reason extra care must be taken with raw pointers.\nWe can resolve this with [[Pinning]].",536924396]],["^15",[1136,"^O","^16",536922600]],["^15",[1136,"^F",909,536922600]],["^15",[1136,"^X",878,536922600]],["^15",[1136,"^V",878,536922600]],["^15",[1136,"^U",148,536924397]],["^15",[1136,"^U",242,536924397]],["^15",[1136,"^U",530,536924397]],["^15",[1136,"^U",878,536924397]],["^15",[1136,"^U",1150,536924397]],["^15",[1136,"^?",["^ "],536924396]],["^15",[1136,"^H",148,536924396]],["^15",[1136,"^H",242,536924396]],["^15",[1136,"^H",530,536924396]],["^15",[1136,"^H",1150,536924396]],["^15",[1136,"^17",true,536922600]],["^15",[1136,"^;","~u64c926f3-e2b8-4c4d-a225-b77ac8a2a656",536922600]],["^15",[1137,"^Q","*Raw Identifier*s\nRust allows naming items such as [[Function]]s, [[Variable]]s etc. with the same name as keywords, but requires a special prefix to be used, ``r#``. This is applied to both the definition and the call-site.\n\nFor ex.:\n```rust\nfn r#match(){}\n\nfn yo() {}\n\nfn main() {\n r#match(); //works\n r#yo(); //also works\n}\n```\n\nThe benefit is that even if the definition isn't using ``r#``, the call-site would still work. It would call the ``r#`` version and if it doesn't exist, it'd call the normal version. Both can't be defined together in the same [[Scope]] so there's no ambiguity to which one will be called.",536922839]],["^15",[1137,"^O","^16",536922642]],["^15",[1137,"^@",false,536922642]],["^15",[1137,"^F",1015,536922642]],["^15",[1137,"^X",28,536922642]],["^15",[1137,"^V",28,536922642]],["^15",[1137,"^U",28,536922833]],["^15",[1137,"^U",89,536922833]],["^15",[1137,"^U",99,536922833]],["^15",[1137,"^U",130,536922833]],["^15",[1137,"^?",["^ "],536922839]],["^15",[1137,"^H",89,536922839]],["^15",[1137,"^H",99,536922839]],["^15",[1137,"^H",130,536922839]],["^15",[1137,"^17",true,536922642]],["^15",[1137,"^;","~u64c92866-bf37-42d7-afb1-7ad248b3ab27",536922642]],["^15",[1138,"^Q","",536922702]],["^15",[1138,"^O","^16",536922702]],["^15",[1138,"^@",false,536922702]],["^15",[1138,"^F",1137,536922702]],["^15",[1138,"^X",28,536922702]],["^15",[1138,"^V",28,536922702]],["^15",[1138,"^U",28,536922703]],["^15",[1138,"^?",["^ "],536922702]],["^15",[1138,"^17",true,536922702]],["^15",[1138,"^;","~u64c928a8-1567-4f16-8f0c-3768eb089116",536922702]],["^15",[1139,"^Q","Operator Overloading\nRust doesn’t allow operator overloading like *C++*. \nHowever we can define operator behavior using [[Trait]]s, these traits are defined in ``std::ops`` [[Module]] with the name of the operation they do.\n\nFor ex.:\n```rust\nuse std::ops::Add;\n\nstruct X {\n    Y: i32,\n}\nimpl Add for X {\n    type Output = i32;\n    fn add(self, other: X) -> Self::Output {\n        self.Y + other.Y\n    }\n}\nfn main() {\n    let a = X { Y: 2 };\n    let b = X { Y: 3 };\n    let c = a + b; //works\n}\n```",536923021]],["^15",[1139,"^O","^16",536922851]],["^15",[1139,"^@",false,536922851]],["^15",[1139,"^F",206,536922851]],["^15",[1139,"^X",206,536922851]],["^15",[1139,"^V",206,536922851]],["^15",[1139,"^U",206,536922973]],["^15",[1139,"^U",414,536922973]],["^15",[1139,"^U",530,536922973]],["^15",[1139,"^?",["^ "],536923021]],["^15",[1139,"^H",414,536923021]],["^15",[1139,"^H",530,536923021]],["^15",[1139,"^17",true,536922851]],["^15",[1139,"^;","~u64c92a3f-8b72-40cd-997b-ab6557e150ec",536922851]],["^15",[1140,"^3","- Operator Overloading\n  Rust doesn’t allow operator overloading like *C++*. \n  However we can define operator behavior using [[Trait]]s, these traits are defined in ``std::ops`` [[Module]] with the name of the operation they do.\n  \n  For ex.:\n  ```rust\n  use std::ops::Add;\n  \n  struct X {\n      Y: i32,\n  }\n  impl Add for X {\n      type Output = i32;\n      fn add(self, other: X) -> Self::Output {\n          self.Y + other.Y\n      }\n  }\n  fn main() {\n      let a = X { Y: 2 };\n      let b = X { Y: 3 };\n      let c = a + b; //works\n  }\n  ```\n- Explicit Type Annotation: \n  To explicitly give [[Data Type]] for any type annotation, such as in [[Generic Type]]s, we can use ``::<T>``. The ``::<>`` is called the [*Turbofish Operator*](https://turbo.fish/).\n  \n  For ex.:\n  ```rust\n  fn yo<T>(x:T){}\n  \n  fn main() {\n  let x= yo::<i32>(2); //works\n  }\n  ```",536925810]],["^15",[1140,"^18","~m1690967807841",536925809]],["^15",[1140,"^Z","pages/Operator.md",536922854]],["^15",[1141,"^Q","[[Future]]'s ``Future`` Trait\nThe future trait’s working helps us understand [[Async and Await]] Rust better.\n\nIt basically looks like this, \n```rust\ntrait SimpleFuture {\n    type Output;\n    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;\n}\n \nenum Poll<T> {\n    Ready(T),\n    Pending,\n}\n```\nFor ex. \n```rust\npub struct SocketRead<'a> {\n    socket: &'a Socket,\n}\n \nimpl SimpleFuture for SocketRead<'_> {\n    type Output = Vec<u8>;\n \n    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {\n        if self.socket.has_data_to_read() {\n            // The socket has data -- read it into a buffer and return it.\n            Poll::Ready(self.socket.read_buf())\n        } else {\n            // The socket does not yet have data.\n            //\n            // Arrange for `wake` to be called once data is available.\n            // When data becomes available, `wake` will be called, and the\n            // user of this `Future` will know to call `poll` again and\n            // receive data.\n            self.socket.set_readable_callback(wake);\n            Poll::Pending\n        }\n    }\n}\n```\nBasically, ``Future`` returns a ``Poll`` [[Enum]] from the ``poll`` [[Function]]. The [[Executor]] calls the ``poll`` function and the enum indicates if the future is complete or pending. \nThe poll function gets a [[Closure]] ``wake`` which tells the executor when it can wake and call the ``poll`` function again to forward the future towards completion. Using this functionality ``Future`` trait allows multiple Futures to be run in the same [[Thread]] as when one is pending other is run and so on for all of them.\n\nThe actual future trait looks like so\n```rust\ntrait Future {\n    type Output;\n    fn poll(\n        // Note the change from `&mut self` to `Pin<&mut Self>`:\n        self: Pin<&mut Self>,\n        // and the change from `wake: fn()` to `cx: &mut Context<'_>`:\n        cx: &mut Context<'_>,\n    ) -> Poll<Self::Output>;\n}\n```\nThey used [[Pinned Trait]] and the ``context`` [[Closure]] here. The ``context`` closure allows identifying which [[Function]] called the wake, otherwise it’s god’s plan as it is just a [[Pointer]] .\n\nA ``Future`` is stored inside a ``Waker`` [[Data Type]], this type provides the ``wake`` function and the future is also stored in this type. The executor receives this type and calls it a ``Task``. \n\nThe ``wake`` function is essentially called through integration with an *IO-aware* system blocking primitive, such as *epoll* on Linux, *kqueue* on FreeBSD and MacOS, *IOCP* on Windows, and *ports* on Fuchsia (all of which are exposed through the cross-platform Rust [[Crate]] ``mio``). These primitives all allow a thread to block on multiple asynchronous IO events, returning once one of the events completes.",536923260]],["^15",[1141,"^O","^16",536923029]],["^15",[1141,"^F",1043,536923029]],["^15",[1141,"^X",414,536923029]],["^15",[1141,"^V",414,536923029]],["^15",[1141,"^U",130,536923254]],["^15",[1141,"^U",148,536923254]],["^15",[1141,"^U",414,536923254]],["^15",[1141,"^U",511,536923254]],["^15",[1141,"^U",577,536923254]],["^15",[1141,"^U",714,536923254]],["^15",[1141,"^U",822,536923254]],["^15",[1141,"^U",878,536923254]],["^15",[1141,"^U",1128,536923254]],["^15",[1141,"^U",1131,536923254]],["^15",[1141,"^U",1135,536923254]],["^15",[1141,"^U",1142,536923254]],["^15",[1141,"^?",["^ "],536923260]],["^15",[1141,"^H",130,536923260]],["^15",[1141,"^H",148,536923260]],["^15",[1141,"^H",511,536923260]],["^15",[1141,"^H",577,536923260]],["^15",[1141,"^H",714,536923260]],["^15",[1141,"^H",822,536923260]],["^15",[1141,"^H",878,536923260]],["^15",[1141,"^H",1128,536923260]],["^15",[1141,"^H",1131,536923260]],["^15",[1141,"^H",1135,536923260]],["^15",[1141,"^H",1142,536923260]],["^15",[1141,"^17",true,536923029]],["^15",[1141,"^;","~u64c92bb7-58eb-4846-be8f-d5b832026080",536923029]],["^15",[1142,"^K",1690905680002,536923175]],["^15",[1142,"^@",false,536923175]],["^15",[1142,"^Y","pinned trait",536923175]],["^15",[1142,"^11","Pinned Trait",536923175]],["^15",[1142,"^B",1690905680002,536923175]],["^15",[1142,"^;","~u64c92c50-f1d2-40bb-a484-5bcbf712fb1b",536923175]],["^15",[1143,"^12",2,536923437]],["^15",[1145,"^Q","Async ``move``\nUsed async blocks.\nJust like the ``move`` in [[Closure]]s. Moves the references into the block.\n\nFor ex.:\n```rust\nfn yo() -> impl Future<Output= i32>{\n  let x= 20;\nasync move{\n   *(&x) //moves x into this closure\n  }\n}\n```",536924042]],["^15",[1145,"^O","^16",536923887]],["^15",[1145,"^@",false,536923887]],["^15",[1145,"^F",1132,536923887]],["^15",[1145,"^X",1128,536923887]],["^15",[1145,"^V",1128,536923887]],["^15",[1145,"^U",714,536923901]],["^15",[1145,"^U",1128,536923901]],["^15",[1145,"^?",["^ "],536924042]],["^15",[1145,"^H",714,536924042]],["^15",[1145,"^17",true,536923887]],["^15",[1145,"^;","~u64c947a0-85a5-4f6e-849d-73f7d1fcfc85",536923887]],["^15",[1146,"^Q","[[Pointer]]s from the [[Standard Library]] such as [[Rc<T>]], [[Mutex<T>]] etc. don't necessarily implement the ``Send`` [[Trait]]. This can cause one thread to lock up a value and another to request it when using [[Future]]s. \nThis is why it is recommended to use ``Future``-aware [[Pointer]]s such as ``Mutex`` from ``futures::lock`` [[Module]] instead of ``std::sync``.",536924133]],["^15",[1146,"^O","^16",536924045]],["^15",[1146,"^@",false,536924045]],["^15",[1146,"^F",1145,536924045]],["^15",[1146,"^X",1128,536924045]],["^15",[1146,"^V",1128,536924045]],["^15",[1146,"^U",93,536924115]],["^15",[1146,"^U",414,536924115]],["^15",[1146,"^U",530,536924115]],["^15",[1146,"^U",878,536924115]],["^15",[1146,"^U",906,536924115]],["^15",[1146,"^U",995,536924115]],["^15",[1146,"^U",1128,536924115]],["^15",[1146,"^U",1131,536924115]],["^15",[1146,"^?",["^ "],536924133]],["^15",[1146,"^H",93,536924133]],["^15",[1146,"^H",414,536924133]],["^15",[1146,"^H",530,536924133]],["^15",[1146,"^H",878,536924133]],["^15",[1146,"^H",906,536924133]],["^15",[1146,"^H",995,536924133]],["^15",[1146,"^H",1131,536924133]],["^15",[1146,"^17",true,536924045]],["^15",[1146,"^;","~u64c94849-ffb7-445c-9a34-b7f7e090b165",536924045]],["^15",[1147,"^12",2,536924137]],["^15",[1148,"^K",1690950368968,536924138]],["^15",[1148,"^O","^16",536924138]],["^15",[1148,"^N",20230802,536924138]],["^15",[1148,"^@",true,536924138]],["^15",[1148,"^Y","aug 2nd, 2023",536924138]],["^15",[1148,"^11","Aug 2nd, 2023",536924138]],["^15",[1148,"^B",1690950368968,536924138]],["^15",[1148,"^;","~u64c9dae0-3c44-4378-b935-05136a8d70ee",536924138]],["^15",[1149,"^Q","",536924139]],["^15",[1149,"^O","^16",536924139]],["^15",[1149,"^N",20230802,536924139]],["^15",[1149,"^@",true,536924139]],["^15",[1149,"^F",1148,536924139]],["^15",[1149,"^X",1148,536924139]],["^15",[1149,"^V",1148,536924139]],["^15",[1149,"^U",1148,536924140]],["^15",[1149,"^?",["^ "],536924139]],["^15",[1149,"^17",true,536924139]],["^15",[1149,"^;","~u64c9dae0-cd63-4706-bbfa-8ea6eca2dd2b",536924139]],["^15",[1150,"^K",1690952552086,536924396]],["^15",[1150,"^[",1152,536924406]],["^15",[1150,"^O","^16",536924400]],["^15",[1150,"^@",false,536924396]],["^15",[1150,"^Y","pinning",536924396]],["^15",[1150,"^11","Pinning",536924396]],["^15",[1150,"^B",1690956399118,536925035]],["^15",[1150,"^;","~u64c9e368-68e2-4664-af40-b26c558a3623",536924396]],["^15",[1151,"^Q","~``Pin``\nThis is a special [[Data Type]] defined in ``std::pin`` [[Module]]. This type wraps [[Pointer]] types and either allows or prevents the values pointed by the pointer to be moved.\n\nAll [[Pointer]] [[Data Type]]s implicitly implement ``Unpin`` [[Trait]], this means that if the Pin wraps the pointer, it will allow the value to be moved.\n\nBut if the [[Pointer]] explicitly implements the ``!Unpin`` [[Trait]] (defined in ``std::marker`` as ``PhantomPinned``), then Pin prohibits the value from being moved.\n\nFor ex.:\n```rust\nuse std::pin::Pin;\nuse std::marker::PhantomPinned;\n\n#[derive(Debug)]\nstruct Test {\n    a: String,\n    b: *const String,\n    _marker: PhantomPinned,\n}\n\n\nimpl Test {\n    fn new(txt: &str) -> Self {\n        Test {\n            a: String::from(txt),\n            b: std::ptr::null(),\n            _marker: PhantomPinned, // This makes our type `!Unpin`\n        }\n    }\n\n    fn init(self: Pin<&mut Self>) {\n        let self_ptr: *const String = &self.a;\n        let this = unsafe { self.get_unchecked_mut() };\n        this.b = self_ptr;\n    }\n\n    fn a(self: Pin<&Self>) -> &str {\n        &self.get_ref().a\n    }\n\n    fn b(self: Pin<&Self>) -> &String {\n        assert!(!self.b.is_null(), \"Test::b called without Test::init being called first\");\n        unsafe { &*(self.b) }\n    }\n}\n\n//And now if we try to move\n\npub fn main() {\n    // test1 is safe to move before we initialize it\n    let mut test1 = Test::new(\"test1\");\n    // Notice how we shadow `test1` to prevent it from being accessed again\n    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };\n    Test::init(test1.as_mut());\n\n    let mut test2 = Test::new(\"test2\");\n    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };\n    Test::init(test2.as_mut());\n\n    println!(\"a: {}, b: {}\", Test::a(test1.as_ref()), Test::b(test1.as_ref()));\n    //std::mem::swap(test1.get_mut(), test2.get_mut()); //error\n    println!(\"a: {}, b: {}\", Test::a(test2.as_ref()), Test::b(test2.as_ref()));\n}\n```\nHere, we have Pinned to the stack, meaning we create a Pin of a value on the stack. If we Pin a value on the heap like ``Pin<Box<T>>`` then it'd be heap pinning. Stack pinning is [[unsafe]].\nread more at [Docs](https://rust-lang.github.io/async-book/04_pinning/01_chapter.html).",536924867]],["^15",[1151,"^O","^16",536924401]],["^15",[1151,"^@",false,536924401]],["^15",[1151,"^F",1150,536924401]],["^15",[1151,"^X",1150,536924401]],["^15",[1151,"^V",1150,536924401]],["^15",[1151,"^U",148,536924731]],["^15",[1151,"^U",414,536924731]],["^15",[1151,"^U",530,536924731]],["^15",[1151,"^U",878,536924731]],["^15",[1151,"^U",953,536924731]],["^15",[1151,"^U",1150,536924731]],["^15",[1151,"^?",["^ "],536924867]],["^15",[1151,"^H",148,536924867]],["^15",[1151,"^H",414,536924867]],["^15",[1151,"^H",530,536924867]],["^15",[1151,"^H",878,536924867]],["^15",[1151,"^H",953,536924867]],["^15",[1151,"^17",true,536924401]],["^15",[1151,"^;","~u64c9e622-ff77-43ca-a0d9-5abc42a8ea95",536924401]],["^15",[1152,"^3","- ``Pin``\n  This is a special [[Data Type]] defined in ``std::pin`` [[Module]]. This type wraps [[Pointer]] types and either allows or prevents the values pointed by the pointer to be moved.\n  \n  All [[Pointer]] [[Data Type]]s implicitly implement ``Unpin`` [[Trait]], this means that if the Pin wraps the pointer, it will allow the value to be moved.\n  \n  But if the [[Pointer]] explicitly implements the ``!Unpin`` [[Trait]] (defined in ``std::marker`` as ``PhantomPinned``), then Pin prohibits the value from being moved.\n  \n  For ex.:\n  ```rust\n  use std::pin::Pin;\n  use std::marker::PhantomPinned;\n  \n  #[derive(Debug)]\n  struct Test {\n      a: String,\n      b: *const String,\n      _marker: PhantomPinned,\n  }\n  \n  \n  impl Test {\n      fn new(txt: &str) -> Self {\n          Test {\n              a: String::from(txt),\n              b: std::ptr::null(),\n              _marker: PhantomPinned, // This makes our type `!Unpin`\n          }\n      }\n  \n      fn init(self: Pin<&mut Self>) {\n          let self_ptr: *const String = &self.a;\n          let this = unsafe { self.get_unchecked_mut() };\n          this.b = self_ptr;\n      }\n  \n      fn a(self: Pin<&Self>) -> &str {\n          &self.get_ref().a\n      }\n  \n      fn b(self: Pin<&Self>) -> &String {\n          assert!(!self.b.is_null(), \"Test::b called without Test::init being called first\");\n          unsafe { &*(self.b) }\n      }\n  }\n  \n  //And now if we try to move\n  \n  pub fn main() {\n      // test1 is safe to move before we initialize it\n      let mut test1 = Test::new(\"test1\");\n      // Notice how we shadow `test1` to prevent it from being accessed again\n      let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };\n      Test::init(test1.as_mut());\n  \n      let mut test2 = Test::new(\"test2\");\n      let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };\n      Test::init(test2.as_mut());\n  \n      println!(\"a: {}, b: {}\", Test::a(test1.as_ref()), Test::b(test1.as_ref()));\n      //std::mem::swap(test1.get_mut(), test2.get_mut()); //error\n      println!(\"a: {}, b: {}\", Test::a(test2.as_ref()), Test::b(test2.as_ref()));\n  }\n  ```\n  Here, we have Pinned to the stack, meaning we create a Pin of a value on the stack. If we Pin a value on the heap like ``Pin<Box<T>>`` then it'd be heap pinning. Stack pinning is [[unsafe]].\n  read more at [Docs](https://rust-lang.github.io/async-book/04_pinning/01_chapter.html).\n- Primitives can be moved in and out of Pin, this is because they have no problem being moved around, so ``Pin<&mut u8>`` behaves the same as ``&mut u8``. Pin types can be defined simply with ``Pin<&T>``.\n- Heap Pinning\n  Meaning values on the heap won't be moved if they are pinned.\n  \n  For ex.:\n  ```rust\n  use std::pin::Pin;\n  \n  struct MyStruct {\n      value: u32,\n      _pin: PhantomPinned, //necessary, this tells the compiler this Struct implements !Unpin\n  }\n  \n  fn main() {\n      let mut my_struct: Pin<Box<MyStruct>> = Box::pin(MyStruct {\n          value: 10,\n          _pin: PhantomPinned,\n      });\n    //Box::pin returns a pinned type\n  \n      println!(\"{}\", my_struct.value);\n      \n      //and to modify the value behind a Pinned Type\n       unsafe {\n          let mut_ref: Pin<&mut MyStruct> = Pin::as_mut(&mut my_struct);\n          let mut_pinned: &mut MyStruct = Pin::get_unchecked_mut(mut_ref);\n          mut_pinned.value = 32;\n      }\n      println!(\"{}\", my_struct.value);\n  }\n  ```\n- ``pin_utils``\n  And other [[Crate]]s are external crates that simplify Pinning and provide [[Macro]]s that do the pinning and other things theirselves so we need to do is use the Pinned types.\n  For ex.:\n  ```rust\n  use pin_utils::pin_mut;\n  \n  fn main() {\n      let x= \"yo\";\n      pin_mut!(x);\n      let y= x;\t \n   \t//Here y’s type will be Pin<&mut &str>. It moves x into y and y is now wrapped in Pin’s safety. \n  }\n  \n  ```\n-",536925041]],["^15",[1152,"^18","~m1690956404224",536925040]],["^15",[1152,"^Z","pages/Pinning.md",536924406]],["^15",[1153,"^U",1150,536924641]],["^15",[1154,"^U",1150,536924641]],["^15",[1155,"^U",1150,536924641]],["^15",[1156,"^U",1150,536924646]],["^15",[1157,"^U",1150,536924646]],["^15",[1158,"^U",1150,536924646]],["^15",[1159,"^U",1150,536924652]],["^15",[1160,"^U",1150,536924652]],["^15",[1161,"^U",1150,536924652]],["^15",[1162,"^U",1150,536924659]],["^15",[1163,"^U",1150,536924659]],["^15",[1164,"^U",1150,536924659]],["^15",[1165,"^Q","Heap Pinning\nMeaning values on the heap won't be moved if they are pinned.\n\nFor ex.:\n```rust\nuse std::pin::Pin;\n\nstruct MyStruct {\n    value: u32,\n    _pin: PhantomPinned, //necessary, this tells the compiler this Struct implements !Unpin\n}\n\nfn main() {\n    let mut my_struct: Pin<Box<MyStruct>> = Box::pin(MyStruct {\n        value: 10,\n        _pin: PhantomPinned,\n    });\n  //Box::pin returns a pinned type\n\n    println!(\"{}\", my_struct.value);\n    \n    //and to modify the value behind a Pinned Type\n     unsafe {\n        let mut_ref: Pin<&mut MyStruct> = Pin::as_mut(&mut my_struct);\n        let mut_pinned: &mut MyStruct = Pin::get_unchecked_mut(mut_ref);\n        mut_pinned.value = 32;\n    }\n    println!(\"{}\", my_struct.value);\n}\n```",536924957]],["^15",[1165,"^O","^16",536924687]],["^15",[1165,"^@",false,536924687]],["^15",[1165,"^F",1168,536924867]],["^15",[1165,"^X",1150,536924687]],["^15",[1165,"^V",1150,536924888]],["^15",[1165,"^U",1150,536924688]],["^15",[1165,"^?",["^ "],536924957]],["^15",[1165,"^17",true,536924687]],["^15",[1165,"^;","~u64c9ecea-623a-4fc0-b984-79d6a2f3fb19",536924687]],["^15",[1166,"^Q","~``Stream`` \nJust like [[Iterator]]s, but uses [[Async and Await]] and [[Future]]s. \nFor ex.:\n```rust\nasync fn send_recv() {\n    const BUFFER_SIZE: usize = 10;\n    let (mut tx, mut rx) = mpsc::channel::<i32>(BUFFER_SIZE);\n \n    tx.send(1).await.unwrap();\n    tx.send(2).await.unwrap();\n    drop(tx);\n \n    // `StreamExt::next` is similar to `Iterator::next`, but returns a\n    // type that implements `Future<Output = Option<T>>`.\n    assert_eq!(Some(1), rx.next().await);\n    assert_eq!(Some(2), rx.next().await);\n    assert_eq!(None, rx.next().await);\n}\n```\nor \nwhen used in a [[Loop]],\n```rust\nasync fn sum_with_next(mut stream: Pin<&mut dyn Stream<Item = i32>>) -> i32 {\n    use futures::stream::StreamExt; // for `next`\n    let mut sum = 0;\n    while let Some(item) = stream.next().await {\n        sum += item;\n    }\n    sum\n}\n//for loop doesn’t work with stream. \n```",536924854]],["^15",[1166,"^O","^16",536924776]],["^15",[1166,"^F",1141,536924776]],["^15",[1166,"^X",414,536924776]],["^15",[1166,"^V",414,536924776]],["^15",[1166,"^U",259,536924851]],["^15",[1166,"^U",414,536924851]],["^15",[1166,"^U",692,536924851]],["^15",[1166,"^U",1128,536924851]],["^15",[1166,"^U",1131,536924851]],["^15",[1166,"^?",["^ "],536924854]],["^15",[1166,"^H",259,536924854]],["^15",[1166,"^H",692,536924854]],["^15",[1166,"^H",1128,536924854]],["^15",[1166,"^H",1131,536924854]],["^15",[1166,"^17",true,536924776]],["^15",[1166,"^;","~u64c9eeb8-cbbf-4ae3-9e4c-9435b7dc51d1",536924776]],["^15",[1167,"^Q","",536924837]],["^15",[1167,"^O","^16",536924837]],["^15",[1167,"^F",1166,536924837]],["^15",[1167,"^X",414,536924837]],["^15",[1167,"^V",414,536924837]],["^15",[1167,"^U",414,536924838]],["^15",[1167,"^?",["^ "],536924837]],["^15",[1167,"^17",true,536924837]],["^15",[1167,"^;","~u64c9eef1-b7fc-4280-b3b6-dbf3b616a2ca",536924837]],["^15",[1168,"^Q","Primitives can be moved in and out of Pin, this is because they have no problem being moved around, so ``Pin<&mut u8>`` behaves the same as ``&mut u8``. Pin types can be defined simply with ``Pin<&T>``.\n",536924867]],["^15",[1168,"^O","^16",536924867]],["^15",[1168,"^@",false,536924867]],["^15",[1168,"^F",1151,536924867]],["^15",[1168,"^X",1150,536924867]],["^15",[1168,"^V",1150,536924867]],["^15",[1168,"^U",1150,536924868]],["^15",[1168,"^?",["^ "],536924867]],["^15",[1168,"^17",true,536924867]],["^15",[1168,"^;","~u64c9f09f-f89c-414a-9fe3-8b529747ee61",536924867]],["^15",[1169,"^Q","~``pin_utils``\nAnd other [[Crate]]s are external crates that simplify Pinning and provide [[Macro]]s that do the pinning and other things theirselves so we need to do is use the Pinned types.\nFor ex.:\n```rust\nuse pin_utils::pin_mut;\n\nfn main() {\n    let x= \"yo\";\n    pin_mut!(x);\n    let y= x;\t \n \t//Here y’s type will be Pin<&mut &str>. It moves x into y and y is now wrapped in Pin’s safety. \n}\n\n```",536925035]],["^15",[1169,"^O","^16",536924960]],["^15",[1169,"^@",false,536924960]],["^15",[1169,"^F",1165,536924960]],["^15",[1169,"^X",1150,536924960]],["^15",[1169,"^V",1150,536924960]],["^15",[1169,"^U",246,536924984]],["^15",[1169,"^U",577,536924984]],["^15",[1169,"^U",1150,536924984]],["^15",[1169,"^?",["^ "],536925035]],["^15",[1169,"^H",246,536925035]],["^15",[1169,"^H",577,536925035]],["^15",[1169,"^17",true,536924960]],["^15",[1169,"^;","~u64c9f1f1-fb0d-43a9-a11e-fa082dbada49",536924960]],["^15",[1170,"^Q","",536925038]],["^15",[1170,"^O","^16",536925038]],["^15",[1170,"^@",false,536925038]],["^15",[1170,"^F",1169,536925038]],["^15",[1170,"^X",1150,536925038]],["^15",[1170,"^V",1150,536925038]],["^15",[1170,"^U",1150,536925039]],["^15",[1170,"^?",["^ "],536925038]],["^15",[1170,"^17",true,536925038]],["^15",[1170,"^;","~u64c9f274-4026-4414-a303-72f6186ae024",536925038]],["^15",[1171,"^Q","~``join!``\nWe can execute multiple futures with ``join!(…)`` or ``try_join!(…)``. The try variant just drops all futures if a future returns an ``Err`` [[Result Type]].",536925075]],["^15",[1171,"^O","^16",536925043]],["^15",[1171,"^@",false,536925043]],["^15",[1171,"^F",1131,536925043]],["^15",[1171,"^X",1131,536925043]],["^15",[1171,"^V",1131,536925043]],["^15",[1171,"^U",687,536925072]],["^15",[1171,"^U",1131,536925072]],["^15",[1171,"^?",["^ "],536925075]],["^15",[1171,"^H",687,536925075]],["^15",[1171,"^17",true,536925043]],["^15",[1171,"^;","~u64c9f28f-c0c7-4bad-aa2b-ae4f2e3c6af3",536925043]],["^15",[1172,"^3","- ``join!``\n  We can execute multiple futures with ``join!(…)`` or ``try_join!(…)``. The try variant just drops all futures if a future returns an ``Err`` [[Result Type]].\n- ``select!``\n  It looks much like ``Match`` from [[Pattern Matching]], each arm in a ``select!`` accepts a ``<pattern> = <expression> => <code>``, where expression is a Future that implements the ``Unpin`` and ``FusedFuture`` [[Trait]]s. \n  In a ``select!``, each future is concurrently ran (meaning all futures are polled, if a future waits, another is continued and so on), and whichever future finishes first returns its value, stops all the other futures and the code corresponding it is executed.\n  \n  For ex.:\n  ```rust\n  use futures::{\n      future::FutureExt, // for `.fuse()`\n      pin_mut,\n      select,\n     future::ready\n  };\n   \n  async fn task_one() { /* ... */ }\n  async fn task_two() { /* ... */ }\n   \n  async fn race_tasks() {\n      let t1 = task_one().fuse();\n      let t2 = task_two().fuse();\n   \n      pin_mut!(t1, t2);\n   \n      select! {\n          () = t1 => println!(\"task one completed first\"),\n          () = t2 => println!(\"task two completed first\"),\n      }\n  }\n  \n  async fn count() {\n      let mut a_fut = future::ready(4); //future::ready already implements FusedFuture and Unpin\n      let mut b_fut = future::ready(6);\n      let mut total = 0;\n  \n      loop {\n          select! {\n              a = a_fut => total += a, //assign returned value to a \n              b = b_fut => total += b,\n              complete => break, //ran if all futures are completed, as would be case in a loop\n              default => unreachable!(), // never runs (futures are ready, then complete)\n          };\n      }\n      assert_eq!(total, 10);\n  }\n  ``` \n  ``FusedFuture`` is necessary in ``select!`` as it can be looped over, when a ``select!`` is looped over, it continues the other futures which are not completed, this is why ``complete`` is a keyword in ``select!``, it's code is ran if all the futures are completed and we are still looping over it. ``default`` on the other hand is ran if no future has immediately returned, it's code is ran if no future is completed yet.\n  \n  [[Pinning]] is necessary with ``select!`` as the futures aren't taken by value, but by mutable [[Reference Type]] by ``select!`` and are continued, this requires their values to not move around between each ``select!`` call in a [[Loop]].\n  \n  * ``Fuse::terminated()`` returns a ``FutureUnordered`` that is a Future which is already completed and terminated, but we can pass it a new future later and it will continue it. \n  Here [Docs](https://rust-lang.github.io/async-book/06_multiple_futures/03_select.html#concurrent-tasks-in-a-select-loop-with-fuse-and-futuresunordered).",536925576]],["^15",[1172,"^18","~m1690967325336",536925577]],["^15",[1172,"^Z","pages/Future.md",536925047]],["^15",[1173,"^Q","~``select!``\nIt looks much like ``Match`` from [[Pattern Matching]], each arm in a ``select!`` accepts a ``<pattern> = <expression> => <code>``, where expression is a Future that implements the ``Unpin`` and ``FusedFuture`` [[Trait]]s. \nIn a ``select!``, each future is concurrently ran (meaning all futures are polled, if a future waits, another is continued and so on), and whichever future finishes first returns its value, stops all the other futures and the code corresponding it is executed.\n\nFor ex.:\n```rust\nuse futures::{\n    future::FutureExt, // for `.fuse()`\n    pin_mut,\n    select,\n   future::ready\n};\n \nasync fn task_one() { /* ... */ }\nasync fn task_two() { /* ... */ }\n \nasync fn race_tasks() {\n    let t1 = task_one().fuse();\n    let t2 = task_two().fuse();\n \n    pin_mut!(t1, t2);\n \n    select! {\n        () = t1 => println!(\"task one completed first\"),\n        () = t2 => println!(\"task two completed first\"),\n    }\n}\n\nasync fn count() {\n    let mut a_fut = future::ready(4); //future::ready already implements FusedFuture and Unpin\n    let mut b_fut = future::ready(6);\n    let mut total = 0;\n\n    loop {\n        select! {\n            a = a_fut => total += a, //assign returned value to a \n            b = b_fut => total += b,\n            complete => break, //ran if all futures are completed, as would be case in a loop\n            default => unreachable!(), // never runs (futures are ready, then complete)\n        };\n    }\n    assert_eq!(total, 10);\n}\n``` \n``FusedFuture`` is necessary in ``select!`` as it can be looped over, when a ``select!`` is looped over, it continues the other futures which are not completed, this is why ``complete`` is a keyword in ``select!``, it's code is ran if all the futures are completed and we are still looping over it. ``default`` on the other hand is ran if no future has immediately returned, it's code is ran if no future is completed yet.\n\n[[Pinning]] is necessary with ``select!`` as the futures aren't taken by value, but by mutable [[Reference Type]] by ``select!`` and are continued, this requires their values to not move around between each ``select!`` call in a [[Loop]].\n\n* ``Fuse::terminated()`` returns a ``FutureUnordered`` that is a Future which is already completed and terminated, but we can pass it a new future later and it will continue it. \nHere [Docs](https://rust-lang.github.io/async-book/06_multiple_futures/03_select.html#concurrent-tasks-in-a-select-loop-with-fuse-and-futuresunordered).",536925574]],["^15",[1173,"^O","^16",536925078]],["^15",[1173,"^@",false,536925078]],["^15",[1173,"^F",1171,536925078]],["^15",[1173,"^X",1131,536925078]],["^15",[1173,"^V",1131,536925078]],["^15",[1173,"^U",202,536925513]],["^15",[1173,"^U",253,536925513]],["^15",[1173,"^U",259,536925513]],["^15",[1173,"^U",414,536925513]],["^15",[1173,"^U",1131,536925513]],["^15",[1173,"^U",1150,536925513]],["^15",[1173,"^?",["^ "],536925574]],["^15",[1173,"^H",202,536925574]],["^15",[1173,"^H",253,536925574]],["^15",[1173,"^H",259,536925574]],["^15",[1173,"^H",414,536925574]],["^15",[1173,"^H",1150,536925574]],["^15",[1173,"^17",true,536925078]],["^15",[1173,"^;","~u64c9f2be-efd6-4739-babd-a456f54ed136",536925078]],["^15",[1174,"^Q","~``async_std`` is in [[Standard Library]]\nIt provides some async features such as ``async_std::task::spawn``. This allows task spawning. Meaning, we can pass a [[Future]] to ``spawn(...)`` [[Function]] and it is executed asynchronously, it returns a ``JoinHandle`` which can be ``.await``ed.",536925652]],["^15",[1174,"^O","^16",536925579]],["^15",[1174,"^@",false,536925579]],["^15",[1174,"^F",1146,536925579]],["^15",[1174,"^X",1128,536925579]],["^15",[1174,"^V",1128,536925579]],["^15",[1174,"^U",93,536925625]],["^15",[1174,"^U",130,536925625]],["^15",[1174,"^U",1128,536925625]],["^15",[1174,"^U",1131,536925625]],["^15",[1174,"^?",["^ "],536925652]],["^15",[1174,"^H",93,536925652]],["^15",[1174,"^H",130,536925652]],["^15",[1174,"^H",1131,536925652]],["^15",[1174,"^17",true,536925579]],["^15",[1174,"^;","~u64ca1d7e-5843-43a6-9089-a48cea80605d",536925579]],["^15",[1175,"^Q","~``?`` with ``await`` on [[Result Type]]s\nFor ex.:\n```rust\nlet fut = async {\n    foo().await?;\n    bar().await?;\n    //Ok(()) //error\n    Ok::<(), MyError>(()) // <- note the explicit type annotation here\n};\n```\nWe need to use the ``Turbofish`` [[Operator]] to explicitly define the return type with ``?``. This is a known limitation with Rust's compiler.",536925754]],["^15",[1175,"^O","^16",536925655]],["^15",[1175,"^@",false,536925655]],["^15",[1175,"^F",1174,536925655]],["^15",[1175,"^X",1128,536925655]],["^15",[1175,"^V",1128,536925655]],["^15",[1175,"^U",206,536925703]],["^15",[1175,"^U",687,536925703]],["^15",[1175,"^U",1128,536925703]],["^15",[1175,"^?",["^ "],536925754]],["^15",[1175,"^H",206,536925754]],["^15",[1175,"^H",687,536925754]],["^15",[1175,"^17",true,536925655]],["^15",[1175,"^;","~u64ca1df1-24a8-484c-8aa9-33ee468daa3c",536925655]],["^15",[1176,"^Q","Explicit Type Annotation: \nTo explicitly give [[Data Type]] for any type annotation, such as in [[Generic Type]]s, we can use ``::<T>``. The ``::<>`` is called the [*Turbofish Operator*](https://turbo.fish/).\n\nFor ex.:\n```rust\nfn yo<T>(x:T){}\n\nfn main() {\nlet x= yo::<i32>(2); //works\n}\n```",536925807]],["^15",[1176,"^O","^16",536925765]],["^15",[1176,"^@",false,536925765]],["^15",[1176,"^F",1139,536925765]],["^15",[1176,"^X",206,536925765]],["^15",[1176,"^V",206,536925765]],["^15",[1176,"^U",131,536925808]],["^15",[1176,"^U",148,536925808]],["^15",[1176,"^U",206,536925808]],["^15",[1176,"^?",["^ "],536925807]],["^15",[1176,"^H",131,536925807]],["^15",[1176,"^H",148,536925807]],["^15",[1176,"^17",true,536925765]],["^15",[1176,"^;","~u64ca1ed3-38f0-498c-8ebb-e8e7506575b2",536925769]],["^15",[1177,"^U",206,536925770]],["^15",[1178,"^U",206,536925770]],["^15",[1180,"^Q","",536925803]],["^15",[1180,"^O","^16",536925803]],["^15",[1180,"^@",false,536925803]],["^15",[1180,"^?",["^ "],536925803]],["^15",[1180,"^17",true,536925803]],["^15",[1180,"^;","~u64ca1ef8-7ee8-4519-a8a4-3274864905fe",536925803]],["^15",[1181,"^12",2,536925813]],["^15",[1182,"^Q","",536926073]],["^15",[1182,"^O","^16",536926073]],["^15",[1182,"^@",false,536926073]],["^15",[1182,"^F",1070,536926073]],["^15",[1182,"^X",1066,536926073]],["^15",[1182,"^V",1066,536926073]],["^15",[1182,"^U",1066,536926074]],["^15",[1182,"^?",["^ "],536926073]],["^15",[1182,"^;","~u64ca2343-4823-4f1a-a226-12a1e8887d46",536926073]],["^15",[1183,"^Q","Rust doesn't implicitly cast any [[Data Type]]s.\n\nExplicit type conversion can be done with [[as]].\nFor ex.:\n```rust\n// Suppress all warnings from casts which overflow.\n#![allow(overflowing_literals)]\n\nfn main() {\n    let decimal = 65.4321_f32;\n\n    // Error! No implicit conversion\n    let integer: u8 = decimal;\n    // FIXME ^ Comment out this line\n\n    // Explicit conversion\n    let integer = decimal as u8;\n    let character = integer as char;\n\n    // The results might overflow and\n    // return **unsound values**. Use these methods wisely:\n     unsafe {\n        // 300.0 as u8 is 44\n        println!(\" 300.0 as u8 is : {}\", 300.0_f32.to_int_unchecked::<u8>());\n        // -100.0 as u8 is 156\n        println!(\"-100.0 as u8 is : {}\", (-100.0_f32).to_int_unchecked::<u8>());\n        // nan as u8 is 0\n        println!(\"   nan as u8 is : {}\", f32::NAN.to_int_unchecked::<u8>());\n    }\n}\n```",536926128]],["^15",[1183,"^O","^16",536926080]],["^15",[1183,"^@",false,536926080]],["^15",[1183,"^F",922,536926080]],["^15",[1183,"^X",922,536926080]],["^15",[1183,"^V",922,536926080]],["^15",[1183,"^U",148,536926097]],["^15",[1183,"^U",922,536926097]],["^15",[1183,"^U",923,536926097]],["^15",[1183,"^?",["^ "],536926128]],["^15",[1183,"^H",148,536926128]],["^15",[1183,"^H",923,536926128]],["^15",[1183,"^;","~u64ca2391-4767-4b7a-8821-80e99a78d737",536926080]],["^15",[1184,"^3","- Rust doesn't implicitly cast any [[Data Type]]s.\n  \n  Explicit type conversion can be done with [[as]].\n  For ex.:\n  ```rust\n  // Suppress all warnings from casts which overflow.\n  #![allow(overflowing_literals)]\n  \n  fn main() {\n      let decimal = 65.4321_f32;\n  \n      // Error! No implicit conversion\n      let integer: u8 = decimal;\n      // FIXME ^ Comment out this line\n  \n      // Explicit conversion\n      let integer = decimal as u8;\n      let character = integer as char;\n  \n      // The results might overflow and\n      // return **unsound values**. Use these methods wisely:\n       unsafe {\n          // 300.0 as u8 is 44\n          println!(\" 300.0 as u8 is : {}\", 300.0_f32.to_int_unchecked::<u8>());\n          // -100.0 as u8 is 156\n          println!(\"-100.0 as u8 is : {}\", (-100.0_f32).to_int_unchecked::<u8>());\n          // nan as u8 is 0\n          println!(\"   nan as u8 is : {}\", f32::NAN.to_int_unchecked::<u8>());\n      }\n  }\n  ```\n-",536926130]],["^15",[1184,"^18","~m1690969068110",536926129]],["^15",[1184,"^Z","pages/Cast.md",536926083]],["^15",[1185,"^Q","",536926106]],["^15",[1185,"^O","^16",536926106]],["^15",[1185,"^@",false,536926106]],["^15",[1185,"^F",1183,536926106]],["^15",[1185,"^X",922,536926106]],["^15",[1185,"^V",922,536926106]],["^15",[1185,"^U",922,536926107]],["^15",[1185,"^?",["^ "],536926106]],["^15",[1185,"^;","~u64ca23b3-3ad3-4ce4-99ed-341ec8acad53",536926106]],["^15",[1186,"^12",2,536926132]],["^15",[1187,"^K",1691036709396,536926133]],["^15",[1187,"^O","^16",536926133]],["^15",[1187,"^N",20230803,536926133]],["^15",[1187,"^@",true,536926133]],["^15",[1187,"^Y","aug 3rd, 2023",536926133]],["^15",[1187,"^11","Aug 3rd, 2023",536926133]],["^15",[1187,"^B",1691036709396,536926133]],["^15",[1187,"^;","~u64cb2c25-af33-4c4e-9541-f10c1f8ebea4",536926133]],["^15",[1188,"^Q","",536926134]],["^15",[1188,"^O","^16",536926134]],["^15",[1188,"^N",20230803,536926134]],["^15",[1188,"^@",true,536926134]],["^15",[1188,"^F",1187,536926134]],["^15",[1188,"^X",1187,536926134]],["^15",[1188,"^V",1187,536926134]],["^15",[1188,"^U",1187,536926135]],["^15",[1188,"^?",["^ "],536926134]],["^15",[1188,"^;","~u64cb2c25-7cab-420f-9625-681d35df4681",536926134]],["^15",[1189,"^12",2,536926137]],["^15",[1190,"^K",1692199755721,536926138]],["^15",[1190,"^O","^16",536926138]],["^15",[1190,"^N",20230816,536926138]],["^15",[1190,"^@",true,536926138]],["^15",[1190,"^Y","aug 16th, 2023",536926138]],["^15",[1190,"^11","Aug 16th, 2023",536926138]],["^15",[1190,"^B",1692199755721,536926138]],["^15",[1190,"^;","~u64dceb4b-ea84-4e91-a2fa-6bbd88521c9d",536926138]],["^15",[1191,"^Q","",536926139]],["^15",[1191,"^O","^16",536926139]],["^15",[1191,"^N",20230816,536926139]],["^15",[1191,"^@",true,536926139]],["^15",[1191,"^F",1190,536926139]],["^15",[1191,"^X",1190,536926139]],["^15",[1191,"^V",1190,536926139]],["^15",[1191,"^U",1190,536926140]],["^15",[1191,"^?",["^ "],536926139]],["^15",[1191,"^;","~u64dceb4b-65b4-45f3-95d6-1dec44c41cc4",536926139]],["^15",[1193,"^K",1692210650416,536926179]],["^15",[1193,"^O","^16",536926179]],["^15",[1193,"^N",20230817,536926179]],["^15",[1193,"^@",true,536926179]],["^15",[1193,"^Y","aug 17th, 2023",536926179]],["^15",[1193,"^11","Aug 17th, 2023",536926179]],["^15",[1193,"^B",1692210650416,536926179]],["^15",[1193,"^;","~u64dd15da-3df8-45c8-a1af-2ec91c107fc8",536926179]],["^15",[1194,"^Q","",536926180]],["^15",[1194,"^O","^16",536926180]],["^15",[1194,"^N",20230817,536926180]],["^15",[1194,"^@",true,536926180]],["^15",[1194,"^F",1193,536926180]],["^15",[1194,"^X",1193,536926180]],["^15",[1194,"^V",1193,536926180]],["^15",[1194,"^U",1193,536926181]],["^15",[1194,"^?",["^ "],536926180]],["^15",[1194,"^;","~u64dd15da-510a-4d2d-85ff-ca8e0075f6ba",536926180]],["^15",[1195,"^12",2,536926183]],["^15",[1196,"^K",1698414490489,536926184]],["^15",[1196,"^O","^16",536926184]],["^15",[1196,"^N",20231027,536926184]],["^15",[1196,"^@",true,536926184]],["^15",[1196,"^Y","oct 27th, 2023",536926184]],["^15",[1196,"^11","Oct 27th, 2023",536926184]],["^15",[1196,"^B",1698414490489,536926184]],["^15",[1196,"^;","~u653bbf9a-0b04-4482-80ef-3197928bc968",536926184]],["^15",[1197,"^Q","",536926185]],["^15",[1197,"^O","^16",536926185]],["^15",[1197,"^N",20231027,536926185]],["^15",[1197,"^@",true,536926185]],["^15",[1197,"^F",1196,536926185]],["^15",[1197,"^X",1196,536926185]],["^15",[1197,"^V",1196,536926185]],["^15",[1197,"^U",1196,536926186]],["^15",[1197,"^?",["^ "],536926185]],["^15",[1197,"^;","~u653bbf9a-475b-4d3b-a6da-79057fc154ae",536926185]],["^15",[1198,"^12",2,536926194]],["^15",[1199,"^K",1702301651142,536926195]],["^15",[1199,"^O","^16",536926195]],["^15",[1199,"^N",20231211,536926195]],["^15",[1199,"^@",true,536926195]],["^15",[1199,"^Y","dec 11th, 2023",536926195]],["^15",[1199,"^11","Dec 11th, 2023",536926195]],["^15",[1199,"^B",1702301651142,536926195]],["^15",[1199,"^;","~u65770fd3-d807-4160-87d7-f37dee2ae586",536926195]],["^15",[1200,"^Q","",536926196]],["^15",[1200,"^O","^16",536926196]],["^15",[1200,"^N",20231211,536926196]],["^15",[1200,"^@",true,536926196]],["^15",[1200,"^F",1199,536926196]],["^15",[1200,"^X",1199,536926196]],["^15",[1200,"^V",1199,536926196]],["^15",[1200,"^U",1199,536926197]],["^15",[1200,"^?",["^ "],536926196]],["^15",[1200,"^;","~u65770fd3-57d3-4e96-86f9-2b590999ceff",536926196]],["^15",[1201,"^12",2,536926200]],["^15",[1202,"^K",1704064287626,536926201]],["^15",[1202,"^O","^16",536926201]],["^15",[1202,"^N",20240101,536926201]],["^15",[1202,"^@",true,536926201]],["^15",[1202,"^Y","jan 1st, 2024",536926201]],["^15",[1202,"^11","Jan 1st, 2024",536926201]],["^15",[1202,"^B",1704064287626,536926201]],["^15",[1202,"^;","~u6591f51f-b8d8-492d-9e5e-d929d1503b75",536926201]],["^15",[1203,"^Q","",536926202]],["^15",[1203,"^O","^16",536926202]],["^15",[1203,"^N",20240101,536926202]],["^15",[1203,"^@",true,536926202]],["^15",[1203,"^F",1202,536926202]],["^15",[1203,"^X",1202,536926202]],["^15",[1203,"^V",1202,536926202]],["^15",[1203,"^U",1202,536926203]],["^15",[1203,"^?",["^ "],536926202]],["^15",[1203,"^;","~u6591f51f-db79-4691-96cc-6d3d0f63647e",536926202]],["^15",[1204,"^12",2,536926317]],["^15",[1205,"^12",2,536926320]],["^15",[1206,"^K",1704194251087,536926321]],["^15",[1206,"^O","^16",536926321]],["^15",[1206,"^N",20240102,536926321]],["^15",[1206,"^@",true,536926321]],["^15",[1206,"^Y","jan 2nd, 2024",536926321]],["^15",[1206,"^11","Jan 2nd, 2024",536926321]],["^15",[1206,"^B",1704194251087,536926321]],["^15",[1206,"^;","~u6593f0cb-57de-4bc9-a829-d30bd0c0531a",536926321]],["^15",[1207,"^Q","",536926322]],["^15",[1207,"^O","^16",536926322]],["^15",[1207,"^N",20240102,536926322]],["^15",[1207,"^@",true,536926322]],["^15",[1207,"^F",1206,536926322]],["^15",[1207,"^X",1206,536926322]],["^15",[1207,"^V",1206,536926322]],["^15",[1207,"^U",1206,536926323]],["^15",[1207,"^?",["^ "],536926322]],["^15",[1207,"^;","~u6593f0cb-bea8-45fb-9a57-8abd76bb5f55",536926322]],["^15",[1208,"^12",2,536926325]],["^15",[1209,"^K",1705298915943,536926326]],["^15",[1209,"^O","^16",536926326]],["^15",[1209,"^N",20240115,536926326]],["^15",[1209,"^@",true,536926326]],["^15",[1209,"^Y","jan 15th, 2024",536926326]],["^15",[1209,"^11","Jan 15th, 2024",536926326]],["^15",[1209,"^B",1705298915943,536926326]],["^15",[1209,"^;","~u65a4cbe3-2cb3-4c73-bca6-0152472aca6c",536926326]],["^15",[1210,"^Q","",536926327]],["^15",[1210,"^O","^16",536926327]],["^15",[1210,"^N",20240115,536926327]],["^15",[1210,"^@",true,536926327]],["^15",[1210,"^F",1209,536926327]],["^15",[1210,"^X",1209,536926327]],["^15",[1210,"^V",1209,536926327]],["^15",[1210,"^U",1209,536926328]],["^15",[1210,"^?",["^ "],536926327]],["^15",[1210,"^;","~u65a4cbe3-66b6-40c1-9600-28d59242229c",536926327]]]]]]